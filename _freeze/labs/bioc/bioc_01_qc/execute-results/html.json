{
  "hash": "b4c32f3fecc230e19140d5a0cf731ed5",
  "result": {
    "markdown": "---\ntitle: \"{{< meta qc_title >}}\"\nsubtitle: \"{{< meta subtitle_bioc >}}\"\ndescription: \"{{< meta qc_description >}}\"\nformat: html\n---\n\n\n::: {.callout-note}\nCode chunks run R commands unless otherwise specified.\n:::\n\n## {{< meta qc_data >}}\n\n\n{{< meta qc_data_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath_data = \"https://export.uppmax.uu.se/naiss2023-23-3/workshops/workshop-scrnaseq\"\n\npath_covid <- \"./data/covid\"\nif (!dir.exists(path_covid)) dir.create(path_covid, recursive = T)\n\npath_results <- \"data/covid/results\"\nif (!dir.exists(path_results)) dir.create(path_results, recursive = T)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_list <- c(\n  \"normal_pbmc_13.h5\", \"normal_pbmc_14.h5\", \"normal_pbmc_19.h5\", \"normal_pbmc_5.h5\",\n  \"ncov_pbmc_15.h5\", \"ncov_pbmc_16.h5\", \"ncov_pbmc_17.h5\", \"ncov_pbmc_1.h5\"\n)\n\nfor (i in file_list) {\n  path_file <- file.path(path_covid, i)\n  if (!file.exists(path_file)) {\n    download.file(url = file.path(file.path(path_data, \"covid\"), i), destfile = path_file)\n  }\n}\n```\n:::\n\n{{< meta qc_data_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(scater)\n  library(scran)\n  library(patchwork) # combining figures\n  library(org.Hs.eg.db)\n  # remotes::install_github('chris-mcginnis-ucsf/DoubletFinder',upgrade = F, dependencies=F)\n  # library(DoubletFinder)\n})\n```\n:::\n\n{{< meta qc_data_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncov.15 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"ncov_pbmc_15.h5\"),\n    use.names = T\n)\ncov.1 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"ncov_pbmc_1.h5\"),\n    use.names = T\n)\ncov.16 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"ncov_pbmc_16.h5\"),\n    use.names = T\n)\ncov.17 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"ncov_pbmc_17.h5\"),\n    use.names = T\n)\n\nctrl.5 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"normal_pbmc_5.h5\"),\n    use.names = T\n)\nctrl.13 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"normal_pbmc_13.h5\"),\n    use.names = T\n)\nctrl.14 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"normal_pbmc_14.h5\"),\n    use.names = T\n)\nctrl.19 <- Seurat::Read10X_h5(\n    filename = file.path(path_covid, \"normal_pbmc_19.h5\"),\n    use.names = T\n)\n```\n:::\n\n\n## {{< meta qc_collate >}}\n\n\n{{< meta qc_collate_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- SingleCellExperiment( assays = list(counts = cbind(cov.1,cov.15, cov.17, ctrl.5, ctrl.13, ctrl.14)) )\ndim(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33538  9000\n```\n:::\n\n```{.r .cell-code}\n#Adding metadata\nsce@colData$sample <- unlist(sapply(c(\"cov.1\",\"cov.15\",\"cov.17\", \"ctrl.5\",\"ctrl.13\",\"ctrl.14\"),function(x) rep(x,ncol(get(x)))))\nsce@colData$type <- ifelse(grepl(\"cov\",sce@colData$sample), \"Covid\",\"Control\")\n```\n:::\n\n{{< meta qc_collate_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove all objects that will not be used.\nrm(cov.15, cov.1, cov.17, ctrl.5, ctrl.13, ctrl.14)\n# run garbage collect to free up memory\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 10216331 545.7   17147045 915.8 13915135 743.2\nVcells 44612091 340.4   94441066 720.6 83350463 636.0\n```\n:::\n:::\n\n{{< meta qc_collate_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(counts(sce)[,1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6 x 10 sparse Matrix of class \"dgCMatrix\"\n                               \nMIR1302-2HG . . . . . . . . . .\nFAM138A     . . . . . . . . . .\nOR4F5       . . . . . . . . . .\nAL627309.1  . . . . . . . . . .\nAL627309.3  . . . . . . . . . .\nAL627309.2  . . . . . . . . . .\n```\n:::\n\n```{.r .cell-code}\nhead(sce@colData,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 2 columns\n                        sample        type\n                   <character> <character>\nAGGTAGGTCGTTGTTT-1       cov.1       Covid\nTAGAGTCGTCCTCCAT-1       cov.1       Covid\nCCCTGATAGCGAACTG-1       cov.1       Covid\nTCATCATTCCACGTAA-1       cov.1       Covid\nATTTACCCAAGCCTGC-1       cov.1       Covid\nGTTGTCCTCTAGAACC-1       cov.1       Covid\nCCTCCAACAAGAGATT-1       cov.1       Covid\nAATAGAGGTGTGAGCA-1       cov.1       Covid\nGGTGGCTAGCGAATGC-1       cov.1       Covid\nTCGGGCACAGTGTGGA-1       cov.1       Covid\n```\n:::\n:::\n\n\n## {{< meta qc_calqc >}}\n\n\n{{< meta qc_calqc_1 >}}\n\n\n{{< meta qc_calqc_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mitochondrial genes\nmito_genes <- rownames(sce)[grep(\"^MT-\",rownames(sce))]\n# Ribosomal genes\nribo_genes <- rownames(sce)[grep(\"^RP[SL]\",rownames(sce))]\n# Hemoglobin genes - includes all genes starting with HB except HBP.\nhb_genes <- rownames(sce)[grep(\"^HB[^(P)]\",rownames(sce))]\n```\n:::\n\n\nFirst, let Scran calculate some general qc-stats for genes and cells with the function `perCellQCMetrics`. It can also calculate proportion of counts for specific gene subsets, so first we need to define which genes are mitochondrial, ribosomal and hemoglobin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- addPerCellQC(sce, flatten = T, subsets = list(mt=mito_genes, hb=hb_genes, ribo=ribo_genes))\n\n# Way2: Doing it manually\nsce@colData$percent_mito <- Matrix::colSums(counts(sce)[mito_genes, ]) / sce@colData$total\n```\n:::\n\n{{< meta qc_calqc_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(colData(sce))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 15 columns\n                        sample        type       sum  detected subsets_mt_sum\n                   <character> <character> <numeric> <integer>      <numeric>\nAGGTAGGTCGTTGTTT-1       cov.1       Covid      1396       656             26\nTAGAGTCGTCCTCCAT-1       cov.1       Covid      1613       779            186\nCCCTGATAGCGAACTG-1       cov.1       Covid      9482      2036            761\nTCATCATTCCACGTAA-1       cov.1       Covid      4357       875           2960\nATTTACCCAAGCCTGC-1       cov.1       Covid     12466      3290            686\nGTTGTCCTCTAGAACC-1       cov.1       Covid      5541      1606            707\n                   subsets_mt_detected subsets_mt_percent subsets_hb_sum\n                             <integer>          <numeric>      <numeric>\nAGGTAGGTCGTTGTTT-1                   8            1.86246              1\nTAGAGTCGTCCTCCAT-1                  10           11.53131              0\nCCCTGATAGCGAACTG-1                  11            8.02573              3\nTCATCATTCCACGTAA-1                  13           67.93665              2\nATTTACCCAAGCCTGC-1                  12            5.50297              3\nGTTGTCCTCTAGAACC-1                  12           12.75943              3\n                   subsets_hb_detected subsets_hb_percent subsets_ribo_sum\n                             <integer>          <numeric>        <numeric>\nAGGTAGGTCGTTGTTT-1                   1          0.0716332               11\nTAGAGTCGTCCTCCAT-1                   0          0.0000000               96\nCCCTGATAGCGAACTG-1                   1          0.0316389             4157\nTCATCATTCCACGTAA-1                   2          0.0459031               99\nATTTACCCAAGCCTGC-1                   2          0.0240655             2281\nGTTGTCCTCTAGAACC-1                   2          0.0541419             1664\n                   subsets_ribo_detected subsets_ribo_percent     total\n                               <integer>            <numeric> <numeric>\nAGGTAGGTCGTTGTTT-1                     9             0.787966      1396\nTAGAGTCGTCCTCCAT-1                    45             5.951643      1613\nCCCTGATAGCGAACTG-1                    85            43.840962      9482\nTCATCATTCCACGTAA-1                    52             2.272206      4357\nATTTACCCAAGCCTGC-1                    82            18.297770     12466\nGTTGTCCTCTAGAACC-1                    80            30.030680      5541\n                   percent_mito\n                      <numeric>\nAGGTAGGTCGTTGTTT-1    0.0186246\nTAGAGTCGTCCTCCAT-1    0.1153131\nCCCTGATAGCGAACTG-1    0.0802573\nTCATCATTCCACGTAA-1    0.6793665\nATTTACCCAAGCCTGC-1    0.0550297\nGTTGTCCTCTAGAACC-1    0.1275943\n```\n:::\n:::\n\n\n## {{< meta qc_plotqc >}}\n\n\n{{< meta qc_plotqc_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# total is total UMIs per cell\n# detected is number of detected genes.\n# the different gene subset percentages are listed as subsets_mt_percent etc.\n\nwrap_plots(\n    plotColData(sce, y = \"detected\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"total\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"subsets_mt_percent\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"subsets_ribo_percent\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"subsets_hb_percent\", x = \"sample\", colour_by = \"sample\"),\n    ncol = 3\n)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n{{< meta qc_plotqc_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce,x = \"total\", y = \"detected\", colour_by = \"sample\")\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-12-1.png){width=576}\n:::\n:::\n\n\n:::{.callout-note title=\"Discuss\"}\n\n{{< meta qc_plotqc_3 >}}\n\n\n:::\n\n## {{< meta qc_filter >}}\n\n### {{< meta qc_filter_detect >}}\n\n\n{{< meta qc_filter_detect_1 >}}\n\n\n\nIn Scran, we can use the function `quickPerCellQC` to filter out outliers from distributions of qc stats, such as detected genes, gene subsets etc. But in this case, we will take one setting at a time and run through the steps of filtering cells.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33538  9000\n```\n:::\n\n```{.r .cell-code}\nselected_c <-  colnames(sce)[sce$detected > 200]\nselected_f <- rownames(sce)[ Matrix::rowSums(counts(sce)) > 3]\n\nsce.filt <- sce[selected_f , selected_c]\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18209  8095\n```\n:::\n:::\n\n{{< meta qc_filter_detect_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# skip for now and run doublet detection instead...\n\n#high.det.v3 <- sce.filt$nFeatures > 4100\n#high.det.v2 <- (sce.filt$nFeatures > 2000) & (sce.filt$sample_id == \"v2.1k\")\n\n# remove these cells\n#sce.filt <- sce.filt[ , (!high.det.v3) & (!high.det.v2)]\n\n# check number of cells\n#ncol(sce.filt)\n```\n:::\n\n{{< meta qc_filter_detect_4 >}}\n\n\n\nIn Scater, you can also use the function `plotHighestExprs()` to plot the gene contribution, but the function is quite slow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Compute the relative expression of each gene per cell\n#Use sparse matrix operations, if your dataset is large, doing matrix devisions the regular way will take a very long time.\nC = counts(sce)\nC@x = C@x / rep.int(colSums(C), diff(C@p))\nmost_expressed <- order(Matrix::rowSums( C ),decreasing = T)[20:1]\nboxplot( as.matrix(t(C[most_expressed,])),cex=.1, las=1, xlab=\"% total count per cell\",col=scales::hue_pal()(20)[20:1],horizontal=TRUE)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nrm(C)\n\n# also, there is the option of running the function \"plotHighestExprs\" in the scater package, however, this function takes very long to execute.\n```\n:::\n\n{{< meta qc_filter_detect_5 >}}\n\n\n\n### {{< meta qc_filter_mr >}}\n\n\n{{< meta qc_filter_mr_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselected_mito <- sce.filt$subsets_mt_percent < 30\nselected_ribo <- sce.filt$subsets_ribo_percent > 5\n\n# and subset the object to only keep those cells\nsce.filt <- sce.filt[, selected_mito & selected_ribo ]\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18209  6023\n```\n:::\n:::\n\n{{< meta qc_filter_mr_2 >}}\n\n\n\n### {{< meta qc_filter_plot >}}\n\n\n{{< meta qc_filter_plot_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrap_plots(\n    plotColData(sce, y = \"detected\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"total\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"subsets_mt_percent\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"subsets_ribo_percent\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce, y = \"subsets_hb_percent\", x = \"sample\", colour_by = \"sample\"),\n    ncol = 3\n)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-17-1.png){width=960}\n:::\n:::\n\n\n### {{< meta qc_filter_genes >}}\n\n\n{{< meta qc_filter_genes_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18209  6023\n```\n:::\n\n```{.r .cell-code}\n# Filter MALAT1\nsce.filt <- sce.filt[ ! grepl(\"MALAT1\", rownames(sce.filt)), ]\n\n# Filter Mitocondrial\nsce.filt <- sce.filt[ ! grepl(\"^MT-\", rownames(sce.filt)), ]\n\n# Filter Ribossomal gene (optional if that is a problem on your data)\n# sce.filt <- sce.filt[ ! grepl(\"^RP[SL]\", rownames(sce.filt)), ]\n\n# Filter Hemoglobin gene\nsce.filt <- sce.filt[ ! grepl(\"^HB[^(P)]\", rownames(sce.filt)), ]\n\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18183  6023\n```\n:::\n:::\n\n\n\n## {{< meta qc_sex >}}\n\n\n{{< meta qc_sex_1 >}}\n\n\n{{< meta qc_sex_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this code chunk is not executed\nsuppressMessages(library(biomaRt))\n\n# initialize connection to mart, may take some time if the sites are unresponsive.\nmart <- useMart(\"ENSEMBL_MART_ENSEMBL\", dataset=\"hsapiens_gene_ensembl\")\n\n# fetch chromosome info plus some other annotations\ngenes_table <- try(biomaRt::getBM(attributes = c(\"ensembl_gene_id\", \"external_gene_name\", \n\"description\",\"gene_biotype\", \"chromosome_name\",\"start_position\"), mart = mart, useCache = F))\n\nwrite.csv(genes_table, file = \"data/results/genes_table.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngenes_file <- file.path(path_results, \"genes_table.csv\")\n\nif (!file.exists(genes_file)) download.file(file.path(path_data, \"covid/results/genes_table.csv\"), destfile = genes_file)\ngenes.table <- read.csv(genes_file)\n\ngenes.table <- genes.table[genes.table$external_gene_name %in% rownames(sce.filt), ]\n```\n:::\n\n{{< meta qc_sex_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchrY.gene = genes.table$external_gene_name[genes.table$chromosome_name == \"Y\"]\nsce.filt@colData$pct_chrY  = Matrix::colSums(counts(sce.filt)[chrY.gene,]) / colSums(counts(sce.filt))\n```\n:::\n\n{{< meta qc_sex_4 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# as plotColData cannot take an expression vs metadata, we need to add in XIST expression to colData\nsce.filt@colData$XIST = counts(sce.filt)[\"XIST\",] /  colSums(counts(sce.filt)) * 10000\nplotColData(sce.filt,  \"XIST\",  \"pct_chrY\")\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-22-1.png){width=480}\n:::\n:::\n\n{{< meta qc_sex_5 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrap_plots(\n    plotColData(sce.filt, y = \"XIST\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce.filt, y = \"pct_chrY\", x = \"sample\", colour_by = \"sample\"),\n    ncol = 2\n)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-23-1.png){width=960}\n:::\n:::\n\n{{< meta qc_sex_6 >}}\n\n\n\n## {{< meta qc_cellcycle >}}\n\n\n{{< meta qc_cellcycle_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhs.pairs <- readRDS(system.file(\"exdata\", \"human_cycle_markers.rds\", package = \"scran\"))\nanno <- select(org.Hs.eg.db, keys = rownames(sce.filt), keytype = \"SYMBOL\", column = \"ENSEMBL\")\nensembl <- anno$ENSEMBL[match(rownames(sce.filt), anno$SYMBOL)]\n\n# Use only genes related to biological process cell cycle to speed up\n# https://www.ebi.ac.uk/QuickGO/term/GO:0007049 = cell cycle (BP,Biological Process)\nGOs <- na.omit(select(org.Hs.eg.db, keys = na.omit(ensembl), keytype = \"ENSEMBL\", column = \"GO\"))\nGOs <- GOs[GOs$GO == \"GO:0007049\", \"ENSEMBL\"]\nhs.pairs <- lapply(hs.pairs, function(x) {\n    x[rowSums(apply(x, 2, function(i) i %in% GOs)) >= 1, ]\n})\nstr(hs.pairs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ G1 :'data.frame':\t6592 obs. of  2 variables:\n  ..$ first : chr [1:6592] \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" ...\n  ..$ second: chr [1:6592] \"ENSG00000065135\" \"ENSG00000080345\" \"ENSG00000101266\" \"ENSG00000135679\" ...\n $ S  :'data.frame':\t8284 obs. of  2 variables:\n  ..$ first : chr [1:8284] \"ENSG00000255302\" \"ENSG00000119969\" \"ENSG00000179051\" \"ENSG00000127586\" ...\n  ..$ second: chr [1:8284] \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000136856\" ...\n $ G2M:'data.frame':\t6200 obs. of  2 variables:\n  ..$ first : chr [1:6200] \"ENSG00000100519\" \"ENSG00000136856\" \"ENSG00000136856\" \"ENSG00000136856\" ...\n  ..$ second: chr [1:6200] \"ENSG00000146457\" \"ENSG00000227268\" \"ENSG00000101265\" \"ENSG00000117676\" ...\n```\n:::\n\n```{.r .cell-code}\ncc.ensembl <- ensembl[ensembl %in% GOs] # This is the fastest (less genes), but less accurate too\n# cc.ensembl <- ensembl[ ensembl %in% unique(unlist(hs.pairs))]\n\nassignments <- cyclone(sce.filt[ensembl %in% cc.ensembl, ], hs.pairs, gene.names = ensembl[ensembl %in% cc.ensembl])\nsce.filt$G1.score <- assignments$scores$G1\nsce.filt$G2M.score <- assignments$scores$G2M\nsce.filt$S.score <- assignments$scores$S\n```\n:::\n\n{{< meta qc_cellcycle_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrap_plots(\n    plotColData(sce.filt, y = \"G2M.score\", x = \"G1.score\", colour_by = \"sample\"),\n    plotColData(sce.filt, y = \"G2M.score\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce.filt, y = \"G1.score\", x = \"sample\", colour_by = \"sample\"),\n    plotColData(sce.filt, y = \"S.score\", x = \"sample\", colour_by = \"sample\"),\n    ncol = 4\n)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-25-1.png){width=1536}\n:::\n:::\n\n\nCyclone predicts most cells as G1, but also quite a lot of cells with high S-Phase scores. Compare to results with Seurat and Scanpy and see how different predictors will give clearly different results.\n\n## {{< meta qc_doublet >}}\n\n\n{{< meta qc_doublet_1 >}}\n\n\n\n:::{.callout-caution}\n\n{{< meta qc_doublet_2 >}}\n\n\n:::\n\nThere is a method to predict if a cluster consists of mainly doublets `findDoubletClusters()`, but we can also predict individual cells based on simulations using the function `computeDoubletDensity()` which we will do here. Doublet detection will be performed using PCA, so we need to first normalize the data and run variable gene detection, as well as UMAP for visualization. These steps will be explored in more detail in coming exercises.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce.filt <- logNormCounts(sce.filt)\ndec <- modelGeneVar(sce.filt, block = sce.filt$sample)\nhvgs = getTopHVGs(dec, n=2000)\n\nsce.filt <- runPCA(sce.filt, subset_row=hvgs)\n\nsce.filt <- runUMAP(sce.filt, pca = 10)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(library(scDblFinder))\n\n# run computeDoubletDensity with 10 principal components.\nsce.filt <- scDblFinder(sce.filt, dims = 10)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrap_plots(\n    plotUMAP(sce.filt, colour_by = \"scDblFinder.score\"),\n    plotUMAP(sce.filt, colour_by = \"scDblFinder.class\"),\n    plotUMAP(sce.filt, colour_by = \"sample\"),\n    ncol = 3\n)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-28-1.png){width=1344}\n:::\n:::\n\n{{< meta qc_doublet_4 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce.filt = sce.filt[,sce.filt$scDblFinder.score < 2]\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18183  6023\n```\n:::\n:::\n\n\n## {{< meta qc_save >}}\n\n\n{{< meta qc_save_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(sce.filt, file.path(path_results, \"bioc_covid_qc.rds\"))\n```\n:::\n\n\n## {{< meta session >}}\n\n<details>\n  <summary>Click here</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Etc/UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] scDblFinder_1.16.0          org.Hs.eg.db_3.18.0        \n [3] AnnotationDbi_1.64.1        patchwork_1.1.2            \n [5] scran_1.30.0                scater_1.30.1              \n [7] ggplot2_3.4.2               scuttle_1.12.0             \n [9] SingleCellExperiment_1.24.0 SummarizedExperiment_1.32.0\n[11] Biobase_2.62.0              GenomicRanges_1.54.1       \n[13] GenomeInfoDb_1.38.2         IRanges_2.36.0             \n[15] S4Vectors_0.40.2            BiocGenerics_0.48.1        \n[17] MatrixGenerics_1.14.0       matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.20          splines_4.3.0            \n  [3] later_1.3.1               BiocIO_1.12.0            \n  [5] bitops_1.0-7              tibble_3.2.1             \n  [7] polyclip_1.10-4           XML_3.99-0.14            \n  [9] lifecycle_1.0.3           edgeR_4.0.3              \n [11] hdf5r_1.3.8               globals_0.16.2           \n [13] lattice_0.21-8            MASS_7.3-58.4            \n [15] magrittr_2.0.3            limma_3.58.1             \n [17] plotly_4.10.2             rmarkdown_2.22           \n [19] yaml_2.3.7                metapod_1.10.1           \n [21] httpuv_1.6.11             Seurat_4.3.0             \n [23] sctransform_0.3.5         sp_1.6-1                 \n [25] spatstat.sparse_3.0-1     reticulate_1.30          \n [27] cowplot_1.1.1             pbapply_1.7-0            \n [29] DBI_1.1.3                 RColorBrewer_1.1-3       \n [31] abind_1.4-5               zlibbioc_1.48.0          \n [33] Rtsne_0.16                purrr_1.0.1              \n [35] RCurl_1.98-1.12           GenomeInfoDbData_1.2.11  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] goftest_1.2-3             spatstat.random_3.1-5    \n [43] dqrng_0.3.0               fitdistrplus_1.1-11      \n [45] parallelly_1.36.0         DelayedMatrixStats_1.24.0\n [47] leiden_0.4.3              codetools_0.2-19         \n [49] DelayedArray_0.28.0       tidyselect_1.2.0         \n [51] farver_2.1.1              ScaledMatrix_1.10.0      \n [53] viridis_0.6.3             spatstat.explore_3.2-1   \n [55] GenomicAlignments_1.38.0  jsonlite_1.8.5           \n [57] BiocNeighbors_1.20.1      ellipsis_0.3.2           \n [59] progressr_0.13.0          ggridges_0.5.4           \n [61] survival_3.5-5            tools_4.3.0              \n [63] ica_1.0-3                 Rcpp_1.0.10              \n [65] glue_1.6.2                gridExtra_2.3            \n [67] SparseArray_1.2.3         xfun_0.39                \n [69] dplyr_1.1.2               withr_2.5.0              \n [71] fastmap_1.1.1             bluster_1.12.0           \n [73] fansi_1.0.4               digest_0.6.31            \n [75] rsvd_1.0.5                R6_2.5.1                 \n [77] mime_0.12                 colorspace_2.1-0         \n [79] scattermore_1.2           tensor_1.5               \n [81] spatstat.data_3.0-1       RSQLite_2.3.1            \n [83] utf8_1.2.3                tidyr_1.3.0              \n [85] generics_0.1.3            data.table_1.14.8        \n [87] rtracklayer_1.62.0        httr_1.4.6               \n [89] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [91] uwot_0.1.14               pkgconfig_2.0.3          \n [93] gtable_0.3.3              blob_1.2.4               \n [95] lmtest_0.9-40             XVector_0.42.0           \n [97] htmltools_0.5.5           SeuratObject_4.1.3       \n [99] scales_1.2.1              png_0.1-8                \n[101] knitr_1.43                rstudioapi_0.14          \n[103] rjson_0.2.21              reshape2_1.4.4           \n[105] nlme_3.1-162              cachem_1.0.8             \n[107] zoo_1.8-12                stringr_1.5.0            \n[109] KernSmooth_2.23-20        parallel_4.3.0           \n[111] miniUI_0.1.1.1            vipor_0.4.5              \n[113] restfulr_0.0.15           pillar_1.9.0             \n[115] grid_4.3.0                vctrs_0.6.2              \n[117] RANN_2.6.1                promises_1.2.0.1         \n[119] BiocSingular_1.18.0       beachmat_2.18.0          \n[121] xtable_1.8-4              cluster_2.1.4            \n[123] beeswarm_0.4.0            evaluate_0.21            \n[125] Rsamtools_2.18.0          cli_3.6.1                \n[127] locfit_1.5-9.8            compiler_4.3.0           \n[129] rlang_1.1.1               crayon_1.5.2             \n[131] future.apply_1.11.0       labeling_0.4.2           \n[133] plyr_1.8.8                ggbeeswarm_0.7.2         \n[135] stringi_1.7.12            deldir_1.0-9             \n[137] viridisLite_0.4.2         BiocParallel_1.36.0      \n[139] munsell_0.5.0             Biostrings_2.70.1        \n[141] lazyeval_0.2.2            spatstat.geom_3.2-1      \n[143] Matrix_1.5-4              sparseMatrixStats_1.14.0 \n[145] bit64_4.0.5               future_1.32.0            \n[147] KEGGREST_1.42.0           statmod_1.5.0            \n[149] shiny_1.7.4               ROCR_1.0-11              \n[151] igraph_1.4.3              memoise_2.0.1            \n[153] xgboost_1.7.5.1           bit_4.0.5                \n```\n:::\n:::\n\n\n</details>\n",
    "supporting": [
      "bioc_01_qc_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}