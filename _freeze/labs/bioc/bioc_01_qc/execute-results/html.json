{
  "hash": "bf1da3f24916b9142665e786ffbb4913",
  "result": {
    "markdown": "---\ntitle: \"{{< meta qc_title >}}\"\nsubtitle: \"{{< meta subtitle_bioc >}}\"\ndescription: \"{{< meta qc_description >}}\"\nformat: html\n---\n\n\n::: {.callout-note}\nCode chunks run R commands unless otherwise specified.\n:::\n\n## {{< meta qc_data >}}\n\n\n{{< meta qc_data_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwebpath <- \"https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/\"\n\nif(!dir.exists(\"./data/raw\")){\n  dir.create(\"./data/raw\", recursive = T)\n  file_list <- c(\n    \"Normal_PBMC_13.h5\", \"Normal_PBMC_14.h5\", \"Normal_PBMC_5.h5\",\n    \"nCoV_PBMC_15.h5\", \"nCoV_PBMC_17.h5\", \"nCoV_PBMC_1.h5\"\n  )\n  for (i in file_list) {\n    download.file(\n      url = paste0(webpath, i),\n      destfile = paste0(\"./data/raw/\", i)\n    )\n  }\n}\n```\n:::\n\n{{< meta qc_data_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(require(scater))\nsuppressMessages(require(scran))\nsuppressMessages(require(cowplot))\nsuppressMessages(require(org.Hs.eg.db))\n\nif(!require(DoubletFinder)){\n   remotes::install_github('chris-mcginnis-ucsf/DoubletFinder',upgrade = F, dependencies=F)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n── R CMD build ─────────────────────────────────────────────────────────────────\n* checking for file ‘/tmp/RtmpPlVPyp/remotes491861800b/chris-mcginnis-ucsf-DoubletFinder-853e2de/DESCRIPTION’ ... OK\n* preparing ‘DoubletFinder’:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\nOmitted ‘LazyData’ from DESCRIPTION\n* building ‘DoubletFinder_2.0.4.tar.gz’\n```\n:::\n\n```{.r .cell-code}\nsuppressMessages(require(DoubletFinder))\n```\n:::\n\n{{< meta qc_data_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncov.15 <- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_15.h5\",\n  use.names = T)\ncov.1 <- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_1.h5\",\n  use.names = T)\ncov.17 <- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_17.h5\",\n  use.names = T)\n\nctrl.5 <- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_5.h5\",\n  use.names = T)\nctrl.13 <- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_13.h5\",\n  use.names = T)\nctrl.14 <- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_14.h5\",\n  use.names = T)\n```\n:::\n\n\n## {{< meta qc_collate >}}\n\n\n{{< meta qc_collate_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- SingleCellExperiment( assays = list(counts = cbind(cov.1,cov.15, cov.17, ctrl.5, ctrl.13, ctrl.14)) )\ndim(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33538  9000\n```\n:::\n\n```{.r .cell-code}\n#Adding metadata\nsce@colData$sample <- unlist(sapply(c(\"cov.1\",\"cov.15\",\"cov.17\", \"ctrl.5\",\"ctrl.13\",\"ctrl.14\"),function(x) rep(x,ncol(get(x)))))\nsce@colData$type <- ifelse(grepl(\"cov\",sce@colData$sample), \"Covid\",\"Control\")\n```\n:::\n\n{{< meta qc_collate_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove all objects that will not be used.\nrm(cov.15, cov.1, cov.17, ctrl.5, ctrl.13, ctrl.14)\n# run garbage collect to free up memory\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 10396735 555.3   17150762 916.0 13462564 719.0\nVcells 38692256 295.2  102507668 782.1 76325095 582.4\n```\n:::\n:::\n\n{{< meta qc_collate_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(counts(sce)[,1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6 x 10 sparse Matrix of class \"dgCMatrix\"\n                               \nMIR1302-2HG . . . . . . . . . .\nFAM138A     . . . . . . . . . .\nOR4F5       . . . . . . . . . .\nAL627309.1  . . . . . . . . . .\nAL627309.3  . . . . . . . . . .\nAL627309.2  . . . . . . . . . .\n```\n:::\n\n```{.r .cell-code}\nhead(sce@colData,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 2 columns\n                        sample        type\n                   <character> <character>\nAGGGTCCCATGACCCG-1       cov.1       Covid\nTACCCACAGCGGGTTA-1       cov.1       Covid\nCCCAACTTCATATGGC-1       cov.1       Covid\nTCAAGTGTCCGAACGC-1       cov.1       Covid\nATTCCTAGTGACTGTT-1       cov.1       Covid\nGTGTTCCGTGGGCTCT-1       cov.1       Covid\nCCTAAGACAGATTAAG-1       cov.1       Covid\nAATAGAGAGGGTTAGC-1       cov.1       Covid\nGGGTCACTCACCTACC-1       cov.1       Covid\nTCCTCTTGTACAGTCT-1       cov.1       Covid\n```\n:::\n:::\n\n\n## {{< meta qc_calqc >}}\n\n\n{{< meta qc_calqc_1 >}}\n\n\n{{< meta qc_calqc_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mitochondrial genes\nmito_genes <- rownames(sce)[grep(\"^MT-\",rownames(sce))]\n# Ribosomal genes\nribo_genes <- rownames(sce)[grep(\"^RP[SL]\",rownames(sce))]\n# Hemoglobin genes - includes all genes starting with HB except HBP.\nhb_genes <- rownames(sce)[grep(\"^HB[^(P)]\",rownames(sce))]\n```\n:::\n\n\nFirst, let Scran calculate some general qc-stats for genes and cells with the function `perCellQCMetrics`. It can also calculate proportion of counts for specific gene subsets, so first we need to define which genes are mitochondrial, ribosomal and hemoglobin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- addPerCellQC(sce, flatten = T, subsets = list(mt=mito_genes, hb=hb_genes, ribo=ribo_genes))\n\n# Way2: Doing it manually\nsce@colData$percent_mito <- Matrix::colSums(counts(sce)[mito_genes, ]) / sce@colData$total\n```\n:::\n\n{{< meta qc_calqc_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(colData(sce))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 15 columns\n                        sample        type       sum  detected subsets_mt_sum\n                   <character> <character> <numeric> <integer>      <numeric>\nAGGGTCCCATGACCCG-1       cov.1       Covid      7698      2140            525\nTACCCACAGCGGGTTA-1       cov.1       Covid     13416      3391            952\nCCCAACTTCATATGGC-1       cov.1       Covid     16498      3654           1253\nTCAAGTGTCCGAACGC-1       cov.1       Covid      1425       608            141\nATTCCTAGTGACTGTT-1       cov.1       Covid      7535      1808            470\nGTGTTCCGTGGGCTCT-1       cov.1       Covid      4378      1345            352\n                   subsets_mt_detected subsets_mt_percent subsets_hb_sum\n                             <integer>          <numeric>      <numeric>\nAGGGTCCCATGACCCG-1                  11            6.81995              2\nTACCCACAGCGGGTTA-1                  11            7.09600              6\nCCCAACTTCATATGGC-1                  12            7.59486              1\nTCAAGTGTCCGAACGC-1                  10            9.89474              1\nATTCCTAGTGACTGTT-1                  11            6.23756              4\nGTGTTCCGTGGGCTCT-1                  10            8.04020              1\n                   subsets_hb_detected subsets_hb_percent subsets_ribo_sum\n                             <integer>          <numeric>        <numeric>\nAGGGTCCCATGACCCG-1                   1         0.02598077             2564\nTACCCACAGCGGGTTA-1                   2         0.04472272             2264\nCCCAACTTCATATGGC-1                   1         0.00606134             2723\nTCAAGTGTCCGAACGC-1                   1         0.07017544              444\nATTCCTAGTGACTGTT-1                   3         0.05308560             3397\nGTGTTCCGTGGGCTCT-1                   1         0.02284148             1588\n                   subsets_ribo_detected subsets_ribo_percent     total\n                               <integer>            <numeric> <numeric>\nAGGGTCCCATGACCCG-1                    82              33.3074      7698\nTACCCACAGCGGGTTA-1                    85              16.8754     13416\nCCCAACTTCATATGGC-1                    87              16.5050     16498\nTCAAGTGTCCGAACGC-1                    68              31.1579      1425\nATTCCTAGTGACTGTT-1                    81              45.0829      7535\nGTGTTCCGTGGGCTCT-1                    79              36.2723      4378\n                   percent_mito\n                      <numeric>\nAGGGTCCCATGACCCG-1    0.0681995\nTACCCACAGCGGGTTA-1    0.0709600\nCCCAACTTCATATGGC-1    0.0759486\nTCAAGTGTCCGAACGC-1    0.0989474\nATTCCTAGTGACTGTT-1    0.0623756\nGTGTTCCGTGGGCTCT-1    0.0804020\n```\n:::\n:::\n\n\n## {{< meta qc_plotqc >}}\n\n\n{{< meta qc_plotqc_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# total is total UMIs per cell\n# detected is number of detected genes.\n# the different gene subset percentages are listed as subsets_mt_percent etc.\n\nplot_grid(plotColData(sce,y = \"detected\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"total\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_mt_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_ribo_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_hb_percent\",x = \"sample\",colour_by = \"sample\"),ncol = 3)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n{{< meta qc_plotqc_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce,x = \"total\", y = \"detected\",colour_by = \"sample\")\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-11-1.png){width=576}\n:::\n:::\n\n\n:::{.callout-note title=\"Discuss\"}\n\n{{< meta qc_plotqc_3 >}}\n\n\n:::\n\n## {{< meta qc_filter >}}\n\n### {{< meta qc_filter_detect >}}\n\n\n{{< meta qc_filter_detect_1 >}}\n\n\n\nIn Scran, we can use the function `quickPerCellQC` to filter out outliers from distributions of qc stats, such as detected genes, gene subsets etc. But in this case, we will take one setting at a time and run through the steps of filtering cells.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33538  9000\n```\n:::\n\n```{.r .cell-code}\nselected_c <-  colnames(sce)[sce$detected > 200]\nselected_f <- rownames(sce)[ Matrix::rowSums(counts(sce)) > 3]\n\nsce.filt <- sce[selected_f , selected_c]\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18147  7973\n```\n:::\n:::\n\n{{< meta qc_filter_detect_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# skip for now and run doublet detection instead...\n\n#high.det.v3 <- sce.filt$nFeatures > 4100\n#high.det.v2 <- (sce.filt$nFeatures > 2000) & (sce.filt$sample_id == \"v2.1k\")\n\n# remove these cells\n#sce.filt <- sce.filt[ , (!high.det.v3) & (!high.det.v2)]\n\n# check number of cells\n#ncol(sce.filt)\n```\n:::\n\n{{< meta qc_filter_detect_4 >}}\n\n\n\nIn Scater, you can also use the function `plotHighestExprs()` to plot the gene contribution, but the function is quite slow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Compute the relative expression of each gene per cell\n#Use sparse matrix operations, if your dataset is large, doing matrix devisions the regular way will take a very long time.\nC = counts(sce)\nC@x = C@x / rep.int(colSums(C), diff(C@p))\nmost_expressed <- order(Matrix::rowSums( C ),decreasing = T)[20:1]\nboxplot( as.matrix(t(C[most_expressed,])),cex=.1, las=1, xlab=\"% total count per cell\",col=scales::hue_pal()(20)[20:1],horizontal=TRUE)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\nrm(C)\n\n# also, there is the option of running the function \"plotHighestExprs\" in the scater package, however, this function takes very long to execute.\n```\n:::\n\n{{< meta qc_filter_detect_5 >}}\n\n\n\n### {{< meta qc_filter_mr >}}\n\n\n{{< meta qc_filter_mr_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselected_mito <- sce.filt$subsets_mt_percent < 30\nselected_ribo <- sce.filt$subsets_ribo_percent > 5\n\n# and subset the object to only keep those cells\nsce.filt <- sce.filt[, selected_mito & selected_ribo ]\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18147  5896\n```\n:::\n:::\n\n{{< meta qc_filter_mr_2 >}}\n\n\n\n### {{< meta qc_filter_plot >}}\n\n\n{{< meta qc_filter_plot_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_grid(plotColData(sce,y = \"detected\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"total\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_mt_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_ribo_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_hb_percent\",x = \"sample\",colour_by = \"sample\"),ncol = 3)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\n### {{< meta qc_filter_genes >}}\n\n\n{{< meta qc_filter_genes_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18147  5896\n```\n:::\n\n```{.r .cell-code}\n# Filter MALAT1\nsce.filt <- sce.filt[ ! grepl(\"MALAT1\", rownames(sce.filt)), ]\n\n# Filter Mitocondrial\nsce.filt <- sce.filt[ ! grepl(\"^MT-\", rownames(sce.filt)), ]\n\n# Filter Ribossomal gene (optional if that is a problem on your data)\n# sce.filt <- sce.filt[ ! grepl(\"^RP[SL]\", rownames(sce.filt)), ]\n\n# Filter Hemoglobin gene\nsce.filt <- sce.filt[ ! grepl(\"^HB[^(P)]\", rownames(sce.filt)), ]\n\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18121  5896\n```\n:::\n:::\n\n\n\n## {{< meta qc_sex >}}\n\n\n{{< meta qc_sex_1 >}}\n\n\n{{< meta qc_sex_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenes.file = \"data/results/genes.table.csv\"\n\nif (!file.exists(genes.file)){\n  suppressMessages(require(biomaRt))\n\n  # initialize connection to mart, may take some time if the sites are unresponsive.\n  mart <- useMart(\"ENSEMBL_MART_ENSEMBL\", dataset=\"hsapiens_gene_ensembl\")\n\n  # fetch chromosome info plus some other annotations\n  genes.table <- try(biomaRt::getBM(attributes = c(\"ensembl_gene_id\",\n              \"external_gene_name\", \"description\",\"gene_biotype\", \"chromosome_name\",\"start_position\"),\n              mart = mart, useCache = F))\n\n  if(!dir.exists(\"data/results\")){dir.create(\"data/results\")}\n  if(is.data.frame(genes.table)){write.csv(genes.table, file = genes.file)}\n\n  if (!file.exists(genes.file)){\n  download.file(\"https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/labs/misc/genes.table.csv\",destfile = \"data/results/genes.table.csv\")\n    genes.table = read.csv(genes.file)\n    }\n}else{\n  genes.table = read.csv(genes.file)\n}\n\ngenes.table <- genes.table[genes.table$external_gene_name %in% rownames(sce.filt),]\n```\n:::\n\n{{< meta qc_sex_3 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchrY.gene = genes.table$external_gene_name[genes.table$chromosome_name == \"Y\"]\nsce.filt@colData$pct_chrY  = Matrix::colSums(counts(sce.filt)[chrY.gene,]) / colSums(counts(sce.filt))\n```\n:::\n\n{{< meta qc_sex_4 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# as plotColData cannot take an expression vs metadata, we need to add in XIST expression to colData\nsce.filt@colData$XIST = counts(sce.filt)[\"XIST\",] /  colSums(counts(sce.filt)) * 10000\nplotColData(sce.filt,  \"XIST\",  \"pct_chrY\")\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-20-1.png){width=480}\n:::\n:::\n\n{{< meta qc_sex_5 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_grid(plotColData(sce.filt, y = \"XIST\", x = \"sample\", colour_by = \"sample\"),\n          plotColData(sce.filt, y = \"pct_chrY\", x = \"sample\", colour_by = \"sample\"),  ncol = 2)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-21-1.png){width=960}\n:::\n:::\n\n{{< meta qc_sex_6 >}}\n\n\n\n## {{< meta qc_cellcycle >}}\n\n\n{{< meta qc_cellcycle_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhs.pairs <- readRDS(system.file(\"exdata\", \"human_cycle_markers.rds\", package=\"scran\"))\nanno <- select(org.Hs.eg.db, keys=rownames(sce.filt), keytype=\"SYMBOL\", column=\"ENSEMBL\")\nensembl <- anno$ENSEMBL[match(rownames(sce.filt), anno$SYMBOL)]\n\n#Use only genes related to biological process cell cycle to speed up\n#https://www.ebi.ac.uk/QuickGO/term/GO:0007049 = cell cycle (BP,Biological Process)\nGOs <- na.omit(select(org.Hs.eg.db, keys=na.omit(ensembl), keytype=\"ENSEMBL\", column=\"GO\"))\nGOs <- GOs[GOs$GO == \"GO:0007049\",\"ENSEMBL\"]\nhs.pairs <- lapply(hs.pairs,function(x){ x[rowSums( apply(x, 2, function(i) i %in% GOs)) >= 1,]})\nstr(hs.pairs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ G1 :'data.frame':\t6592 obs. of  2 variables:\n  ..$ first : chr [1:6592] \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" ...\n  ..$ second: chr [1:6592] \"ENSG00000065135\" \"ENSG00000080345\" \"ENSG00000101266\" \"ENSG00000135679\" ...\n $ S  :'data.frame':\t8282 obs. of  2 variables:\n  ..$ first : chr [1:8282] \"ENSG00000255302\" \"ENSG00000119969\" \"ENSG00000179051\" \"ENSG00000127586\" ...\n  ..$ second: chr [1:8282] \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000136856\" ...\n $ G2M:'data.frame':\t6200 obs. of  2 variables:\n  ..$ first : chr [1:6200] \"ENSG00000100519\" \"ENSG00000136856\" \"ENSG00000136856\" \"ENSG00000136856\" ...\n  ..$ second: chr [1:6200] \"ENSG00000146457\" \"ENSG00000227268\" \"ENSG00000101265\" \"ENSG00000117676\" ...\n```\n:::\n\n```{.r .cell-code}\ncc.ensembl <- ensembl[ensembl %in% GOs] #This is the fastest (less genes), but less accurate too\n#cc.ensembl <- ensembl[ ensembl %in% unique(unlist(hs.pairs))]\n\nassignments <- cyclone(sce.filt[ensembl %in% cc.ensembl,], hs.pairs, gene.names= ensembl[ ensembl %in% cc.ensembl])\nsce.filt$G1.score <- assignments$scores$G1\nsce.filt$G2M.score <- assignments$scores$G2M\nsce.filt$S.score <- assignments$scores$S\n```\n:::\n\n{{< meta qc_cellcycle_2 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_grid(plotColData(sce.filt,y = \"G2M.score\",x = \"G1.score\",colour_by = \"sample\"),\n          plotColData(sce.filt,y = \"G2M.score\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce.filt,y = \"G1.score\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce.filt,y = \"S.score\",x = \"sample\",colour_by = \"sample\"),ncol = 4)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-23-1.png){width=1536}\n:::\n:::\n\n\nCyclone predicts most cells as G1, but also quite a lot of cells with high S-Phase scores. Compare to results with Seurat and Scanpy and see how different predictors will give clearly different results.\n\n## {{< meta qc_doublet >}}\n\n\n{{< meta qc_doublet_1 >}}\n\n\n\n:::{.callout-caution}\n\n{{< meta qc_doublet_2 >}}\n\n\n:::\n\nThere is a method to predict if a cluster consists of mainly doublets `findDoubletClusters()`, but we can also predict individual cells based on simulations using the function `computeDoubletDensity()` which we will do here. Doublet detection will be performed using PCA, so we need to first normalize the data and run variable gene detection, as well as UMAP for visualization. These steps will be explored in more detail in coming exercises.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce.filt <- logNormCounts(sce.filt)\ndec <- modelGeneVar(sce.filt, block = sce.filt$sample)\nhvgs = getTopHVGs(dec, n=2000)\n\nsce.filt <- runPCA(sce.filt, subset_row=hvgs)\n\nsce.filt <- runUMAP(sce.filt, pca = 10)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(require(scDblFinder))\n\n# run computeDoubletDensity with 10 principal components.\nsce.filt <- scDblFinder(sce.filt, dims = 10)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_grid(plotUMAP(sce.filt, colour_by=\"scDblFinder.score\"),\n          plotUMAP(sce.filt, colour_by=\"scDblFinder.class\"),\n          plotUMAP(sce.filt, colour_by=\"sample\"), ncol = 3)\n```\n\n::: {.cell-output-display}\n![](bioc_01_qc_files/figure-html/unnamed-chunk-26-1.png){width=1344}\n:::\n:::\n\n{{< meta qc_doublet_4 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce.filt = sce.filt[,sce.filt$scDblFinder.score < 2]\ndim(sce.filt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18121  5896\n```\n:::\n:::\n\n\n## {{< meta qc_save >}}\n\n\n{{< meta qc_save_1 >}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!dir.exists(\"data/results\")) dir.create(\"data/results\", showWarnings = F)\nif (!file.exists(\"data/results/covid_qc.rds\")) saveRDS(sce.filt, \"data/results/covid_qc.rds\")\n```\n:::\n\n\n## {{< meta session >}}\n\n<details>\n  <summary>Click here</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Etc/UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] scDblFinder_1.16.0          org.Hs.eg.db_3.18.0        \n [3] AnnotationDbi_1.64.1        cowplot_1.1.1              \n [5] scran_1.30.0                scater_1.30.1              \n [7] ggplot2_3.4.2               scuttle_1.12.0             \n [9] SingleCellExperiment_1.24.0 SummarizedExperiment_1.32.0\n[11] Biobase_2.62.0              GenomicRanges_1.54.1       \n[13] GenomeInfoDb_1.38.2         IRanges_2.36.0             \n[15] S4Vectors_0.40.2            BiocGenerics_0.48.1        \n[17] MatrixGenerics_1.14.0       matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.20          splines_4.3.0            \n  [3] later_1.3.1               BiocIO_1.12.0            \n  [5] bitops_1.0-7              tibble_3.2.1             \n  [7] polyclip_1.10-4           XML_3.99-0.14            \n  [9] lifecycle_1.0.3           edgeR_4.0.3              \n [11] rprojroot_2.0.3           hdf5r_1.3.8              \n [13] globals_0.16.2            processx_3.8.1           \n [15] lattice_0.21-8            MASS_7.3-58.4            \n [17] magrittr_2.0.3            limma_3.58.1             \n [19] plotly_4.10.2             rmarkdown_2.22           \n [21] yaml_2.3.7                remotes_2.4.2            \n [23] metapod_1.10.1            httpuv_1.6.11            \n [25] Seurat_4.3.0              sctransform_0.3.5        \n [27] spatstat.sparse_3.0-1     sp_1.6-1                 \n [29] pkgbuild_1.4.0            reticulate_1.30          \n [31] pbapply_1.7-0             DBI_1.1.3                \n [33] RColorBrewer_1.1-3        abind_1.4-5              \n [35] zlibbioc_1.48.0           Rtsne_0.16               \n [37] purrr_1.0.1               RCurl_1.98-1.12          \n [39] GenomeInfoDbData_1.2.11   ggrepel_0.9.3            \n [41] irlba_2.3.5.1             spatstat.utils_3.0-3     \n [43] listenv_0.9.0             goftest_1.2-3            \n [45] spatstat.random_3.1-5     dqrng_0.3.0              \n [47] fitdistrplus_1.1-11       parallelly_1.36.0        \n [49] DelayedMatrixStats_1.24.0 leiden_0.4.3             \n [51] codetools_0.2-19          DelayedArray_0.28.0      \n [53] tidyselect_1.2.0          farver_2.1.1             \n [55] ScaledMatrix_1.10.0       viridis_0.6.3            \n [57] spatstat.explore_3.2-1    GenomicAlignments_1.38.0 \n [59] jsonlite_1.8.5            BiocNeighbors_1.20.1     \n [61] ellipsis_0.3.2            progressr_0.13.0         \n [63] ggridges_0.5.4            survival_3.5-5           \n [65] tools_4.3.0               ica_1.0-3                \n [67] Rcpp_1.0.10               glue_1.6.2               \n [69] gridExtra_2.3             SparseArray_1.2.3        \n [71] xfun_0.39                 dplyr_1.1.2              \n [73] withr_2.5.0               fastmap_1.1.1            \n [75] bluster_1.12.0            fansi_1.0.4              \n [77] callr_3.7.3               digest_0.6.31            \n [79] rsvd_1.0.5                R6_2.5.1                 \n [81] mime_0.12                 colorspace_2.1-0         \n [83] scattermore_1.2           tensor_1.5               \n [85] spatstat.data_3.0-1       RSQLite_2.3.1            \n [87] utf8_1.2.3                tidyr_1.3.0              \n [89] generics_0.1.3            data.table_1.14.8        \n [91] rtracklayer_1.62.0        prettyunits_1.1.1        \n [93] httr_1.4.6                htmlwidgets_1.6.2        \n [95] S4Arrays_1.2.0            uwot_0.1.14              \n [97] pkgconfig_2.0.3           gtable_0.3.3             \n [99] blob_1.2.4                lmtest_0.9-40            \n[101] XVector_0.42.0            htmltools_0.5.5          \n[103] SeuratObject_4.1.3        scales_1.2.1             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.14           rjson_0.2.21             \n[109] reshape2_1.4.4            nlme_3.1-162             \n[111] curl_5.0.1                cachem_1.0.8             \n[113] zoo_1.8-12                stringr_1.5.0            \n[115] KernSmooth_2.23-20        parallel_4.3.0           \n[117] miniUI_0.1.1.1            vipor_0.4.5              \n[119] restfulr_0.0.15           desc_1.4.2               \n[121] pillar_1.9.0              grid_4.3.0               \n[123] vctrs_0.6.2               RANN_2.6.1               \n[125] promises_1.2.0.1          BiocSingular_1.18.0      \n[127] beachmat_2.18.0           xtable_1.8-4             \n[129] cluster_2.1.4             beeswarm_0.4.0           \n[131] evaluate_0.21             Rsamtools_2.18.0         \n[133] cli_3.6.1                 locfit_1.5-9.8           \n[135] compiler_4.3.0            rlang_1.1.1              \n[137] crayon_1.5.2              future.apply_1.11.0      \n[139] labeling_0.4.2            ps_1.7.5                 \n[141] plyr_1.8.8                ggbeeswarm_0.7.2         \n[143] stringi_1.7.12            deldir_1.0-9             \n[145] viridisLite_0.4.2         BiocParallel_1.36.0      \n[147] munsell_0.5.0             Biostrings_2.70.1        \n[149] lazyeval_0.2.2            spatstat.geom_3.2-1      \n[151] Matrix_1.5-4              patchwork_1.1.2          \n[153] sparseMatrixStats_1.14.0  bit64_4.0.5              \n[155] future_1.32.0             KEGGREST_1.42.0          \n[157] statmod_1.5.0             shiny_1.7.4              \n[159] ROCR_1.0-11               igraph_1.4.3             \n[161] memoise_2.0.1             xgboost_1.7.5.1          \n[163] bit_4.0.5                \n```\n:::\n:::\n\n\n</details>\n",
    "supporting": [
      "bioc_01_qc_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}