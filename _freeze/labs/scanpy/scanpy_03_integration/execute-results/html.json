{
  "hash": "ee6137dd43de29ff948ae25d0a2141e3",
  "result": {
    "markdown": "---\ntitle: \"{{< meta int_title >}}\"\nsubtitle: \"{{< meta subtitle_scanpy >}}\"\ndescription: \"{{< meta int_description >}}\"\nformat: html\nengine: jupyter\n---\n\n::: {.callout-note}\nCode chunks run Python commands unless it starts with `%%bash`, in which case, those chunks run shell commands.\n:::\n\n\n{{< meta int_1 >}}\n\n\n\n|Markdown | Language | Library | Ref|\n|:---|:---|:---|:---|\n|CCA | R | Seurat | [Cell](https://www.sciencedirect.com/science/article/pii/S0092867419305598?via%3Dihub)|\n|MNN | R/Python | Scater/Scanpy | [Nat. Biotech.](https://www.nature.com/articles/nbt.4091)|\n|Conos | R | conos | [Nat. Methods](https://www.nature.com/articles/s41592-019-0466-z?error=cookies_not_supported&code=5680289b-6edb-40ad-9934-415dac4fdb2f)|\n|Scanorama | Python | scanorama | [Nat. Biotech.](https://www.nature.com/articles/s41587-019-0113-3)|\n\n## {{< meta int_prep >}}\n\n\n{{< meta int_prep_1 >}}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\nimport warnings\nimport os\nimport urllib.request\n\nwarnings.simplefilter(action='ignore', category=Warning)\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3             \n\nsc.settings.set_figure_params(dpi=80)\n%matplotlib inline\n```\n:::\n\n\nCreate individual **adata** objects per batch.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npath_data = \"https://export.uppmax.uu.se/naiss2023-23-3/workshops/workshop-scrnaseq\"\n\npath_file = \"data/covid/results/scanpy_covid_qc_dr.h5ad\"\nif not os.path.exists(path_file):\n    urllib.request.urlretrieve(os.path.join(\n        path_data, 'covid/results/scanpy_covid_qc_dr.h5ad'), path_file)\n\nadata = sc.read_h5ad(path_file)\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nAnnData object with n_obs × n_vars = 5725 × 2727\n    obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n    obsm: 'X_pca', 'X_tsne', 'X_umap'\n    varm: 'PCs'\n    obsp: 'connectivities', 'distances'\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(adata.X.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5725, 2727)\n```\n:::\n:::\n\n\nAs the stored AnnData object contains scaled data based on variable genes, we need to make a new object with the logtransformed normalized counts. The new variable gene selection should not be performed on the scaled data matrix.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nadata2 = adata.raw.to_adata() \n\nadata2.uns['log1p']['base']=None\n\n# check that the matrix looks like normalized counts\nprint(adata2.X[1:10,1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  (0, 2)\t0.7825693876867097\n  (7, 5)\t1.1311041336746985\n```\n:::\n:::\n\n\n## Detect variable genes\n\nVariable genes can be detected across the full dataset, but then we run the risk of getting many batch-specific genes that will drive a lot of the variation. Or we can select variable genes from each batch separately to get only celltype variation. In the dimensionality reduction exercise, we already selected variable genes, so they are already stored in `adata.var.highly_variable`.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nvar_genes_all = adata.var.highly_variable\n\nprint(\"Highly variable genes: %d\"%sum(var_genes_all))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHighly variable genes: 2727\n```\n:::\n:::\n\n\nDetect variable genes in each dataset separately using the `batch_key` parameter.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsc.pp.highly_variable_genes(adata2, min_mean=0.0125, max_mean=3, min_disp=0.5, batch_key = 'sample')\n\nprint(\"Highly variable genes intersection: %d\"%sum(adata2.var.highly_variable_intersection))\n\nprint(\"Number of batches where gene is variable:\")\nprint(adata2.var.highly_variable_nbatches.value_counts())\n\nvar_genes_batch = adata2.var.highly_variable_nbatches > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nextracting highly variable genes\n    finished (0:00:02)\n--> added\n    'highly_variable', boolean vector (adata.var)\n    'means', float vector (adata.var)\n    'dispersions', float vector (adata.var)\n    'dispersions_norm', float vector (adata.var)\nHighly variable genes intersection: 196\nNumber of batches where gene is variable:\nhighly_variable_nbatches\n0    8436\n1    4729\n2    3037\n3    1504\n4     627\n5     301\n6     196\nName: count, dtype: int64\n```\n:::\n:::\n\n\nCompare overlap of variable genes with batches or with all data.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(\"Any batch var genes: %d\"%sum(var_genes_batch))\nprint(\"All data var genes: %d\"%sum(var_genes_all))\nprint(\"Overlap: %d\"%sum(var_genes_batch & var_genes_all))\nprint(\"Variable genes in all batches: %d\"%sum(adata2.var.highly_variable_nbatches == 6))\nprint(\"Overlap batch instersection and all: %d\"%sum(var_genes_all & adata2.var.highly_variable_intersection))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAny batch var genes: 10394\nAll data var genes: 2727\nOverlap: 2724\nVariable genes in all batches: 196\nOverlap batch instersection and all: 193\n```\n:::\n:::\n\n\nSelect all genes that are variable in at least 2 datasets and use for remaining analysis.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nvar_select = adata2.var.highly_variable_nbatches > 2\nvar_genes = var_select.index[var_select]\nlen(var_genes)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n2628\n```\n:::\n:::\n\n\n## BBKNN\n\nFirst, we will run BBKNN that is implemented in scanpy.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport bbknn\nbbknn.bbknn(adata2,batch_key='sample')\n\n# then run umap on the integrated space\nsc.tl.umap(adata2)\nsc.tl.tsne(adata2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing batch balanced neighbors\n\tfinished: added to `.uns['neighbors']`\n    `.obsp['distances']`, distances for each pair of neighbors\n    `.obsp['connectivities']`, weighted adjacency matrix (0:00:02)\ncomputing UMAP\n    finished: added\n    'X_umap', UMAP coordinates (adata.obsm) (0:00:09)\ncomputing tSNE\n    using 'X_pca' with n_pcs = 50\n    using sklearn.manifold.TSNE\n    finished: added\n    'X_tsne', tSNE coordinates (adata.obsm) (0:00:11)\n```\n:::\n:::\n\n\n{{< meta int_plot >}}\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.tsne(adata2, color=\"sample\", title=\"BBKNN Corrected tsne\", ax=axs[0,0], show=False)\nsc.pl.tsne(adata, color=\"sample\", title=\"Uncorrected tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN Corrected umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected umap\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n<Axes: title={'center': 'Uncorrected umap'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-11-output-2.png){}\n:::\n:::\n\n\n{{< meta int_save >}}\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsave_file = './data/covid/results/scanpy_covid_qc_dr_bbknn.h5ad'\nadata2.write_h5ad(save_file)\n```\n:::\n\n\n## Combat\n\nBatch correction can also be performed with combat. Note that ComBat batch correction requires a dense matrix format as input (which is already the case in this example).\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# create a new object with lognormalized counts\nadata_combat = sc.AnnData(X=adata.raw.X, var=adata.raw.var, obs = adata.obs)\n\n# first store the raw data \nadata_combat.raw = adata_combat\n\n# run combat\nsc.pp.combat(adata_combat, key='sample')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandardizing Data across genes.\n\nFound 6 batches\n\nFound 0 numerical variables:\n\t\n\nFound 37 genes with zero variance.\nFitting L/S model and finding priors\n\nFinding parametric adjustments\n\nAdjusting data\n\n```\n:::\n:::\n\n\nThen we run the regular steps of dimensionality reduction on the combat corrected data. Variable gene selection, pca and umap with combat data.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nsc.pp.highly_variable_genes(adata_combat)\nprint(\"Highly variable genes: %d\"%sum(adata_combat.var.highly_variable))\nsc.pl.highly_variable_genes(adata_combat)\n\nsc.pp.pca(adata_combat, n_comps=30, use_highly_variable=True, svd_solver='arpack')\n\nsc.pp.neighbors(adata_combat)\n\nsc.tl.umap(adata_combat)\nsc.tl.tsne(adata_combat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nextracting highly variable genes\n    finished (0:00:01)\n--> added\n    'highly_variable', boolean vector (adata.var)\n    'means', float vector (adata.var)\n    'dispersions', float vector (adata.var)\n    'dispersions_norm', float vector (adata.var)\nHighly variable genes: 3533\ncomputing PCA\n    on highly variable genes\n    with n_comps=30\n    finished (0:00:01)\ncomputing neighbors\n    using 'X_pca' with n_pcs = 30\n    finished: added to `.uns['neighbors']`\n    `.obsp['distances']`, distances for each pair of neighbors\n    `.obsp['connectivities']`, weighted adjacency matrix (0:00:00)\ncomputing UMAP\n    finished: added\n    'X_umap', UMAP coordinates (adata.obsm) (0:00:08)\ncomputing tSNE\n    using 'X_pca' with n_pcs = 30\n    using sklearn.manifold.TSNE\n    finished: added\n    'X_tsne', tSNE coordinates (adata.obsm) (0:00:10)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-14-output-2.png){}\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# compare var_genes\nvar_genes_combat = adata_combat.var.highly_variable\nprint(\"With all data %d\"%sum(var_genes_all))\nprint(\"With combat %d\"%sum(var_genes_combat))\nprint(\"Overlap %d\"%sum(var_genes_all & var_genes_combat))\n\nprint(\"With 2 batches %d\"%sum(var_select))\nprint(\"Overlap %d\"%sum(var_genes_combat & var_select))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWith all data 2727\nWith combat 3533\nOverlap 2003\nWith 2 batches 2628\nOverlap 1896\n```\n:::\n:::\n\n\n{{< meta int_plot >}}\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.tsne(adata2, color=\"sample\", title=\"BBKNN tsne\", ax=axs[0,0], show=False)\nsc.pl.tsne(adata_combat, color=\"sample\", title=\"Combat tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata_combat, color=\"sample\", title=\"Combat umap\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n<Axes: title={'center': 'Combat umap'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-16-output-2.png){}\n:::\n:::\n\n\n{{< meta int_save >}}\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n#save to file\nsave_file = './data/covid/results/scanpy_covid_qc_dr_combat.h5ad'\nadata_combat.write_h5ad(save_file)\n```\n:::\n\n\n## {{< meta int_scanorama >}}\n\n\n{{< meta int_scanorama_1 >}}\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# split per batch into new objects.\nbatches = adata.obs['sample'].cat.categories.tolist()\nalldata = {}\nfor batch in batches:\n    alldata[batch] = adata2[adata2.obs['sample'] == batch,]\n\nalldata   \n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n{'covid_1': View of AnnData object with n_obs × n_vars = 875 × 18830\n     obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'covid_15': View of AnnData object with n_obs × n_vars = 591 × 18830\n     obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'covid_17': View of AnnData object with n_obs × n_vars = 1083 × 18830\n     obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_5': View of AnnData object with n_obs × n_vars = 1028 × 18830\n     obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_13': View of AnnData object with n_obs × n_vars = 1117 × 18830\n     obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_14': View of AnnData object with n_obs × n_vars = 1031 × 18830\n     obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances'}\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nimport scanorama\n\n#subset the individual dataset to the variable genes we defined at the beginning\nalldata2 = dict()\nfor ds in alldata.keys():\n    print(ds)\n    alldata2[ds] = alldata[ds][:,var_genes]\n\n#convert to list of AnnData objects\nadatas = list(alldata2.values())\n\n# run scanorama.integrate\nscanorama.integrate_scanpy(adatas, dimred = 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncovid_1\ncovid_15\ncovid_17\nctrl_5\nctrl_13\nctrl_14\nFound 2628 genes among all datasets\n[[0.         0.74450085 0.2843952  0.63521401 0.456      0.37485714]\n [0.         0.         0.5177665  0.48346304 0.32656514 0.36886633]\n [0.         0.         0.         0.32976654 0.11080332 0.15327793]\n [0.         0.         0.         0.         0.83754864 0.74319066]\n [0.         0.         0.         0.         0.         0.85675918]\n [0.         0.         0.         0.         0.         0.        ]]\nProcessing datasets (4, 5)\nProcessing datasets (3, 4)\nProcessing datasets (0, 1)\nProcessing datasets (3, 5)\nProcessing datasets (0, 3)\nProcessing datasets (1, 2)\nProcessing datasets (1, 3)\nProcessing datasets (0, 4)\nProcessing datasets (0, 5)\nProcessing datasets (1, 5)\nProcessing datasets (2, 3)\nProcessing datasets (1, 4)\nProcessing datasets (0, 2)\nProcessing datasets (2, 5)\nProcessing datasets (2, 4)\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n#scanorama adds the corrected matrix to adata.obsm in each of the datasets in adatas.\nadatas[0].obsm['X_scanorama'].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n(875, 50)\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Get all the integrated matrices.\nscanorama_int = [ad.obsm['X_scanorama'] for ad in adatas]\n\n# make into one matrix.\nall_s = np.concatenate(scanorama_int)\nprint(all_s.shape)\n\n# add to the AnnData object, create a new object first\nadata_sc = adata.copy()\nadata_sc.obsm[\"Scanorama\"] = all_s\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5725, 50)\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# tsne and umap\nsc.pp.neighbors(adata_sc, n_pcs =30, use_rep = \"Scanorama\")\nsc.tl.umap(adata_sc)\nsc.tl.tsne(adata_sc, n_pcs = 30, use_rep = \"Scanorama\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing neighbors\n    finished: added to `.uns['neighbors']`\n    `.obsp['distances']`, distances for each pair of neighbors\n    `.obsp['connectivities']`, weighted adjacency matrix (0:00:00)\ncomputing UMAP\n    finished: added\n    'X_umap', UMAP coordinates (adata.obsm) (0:00:08)\ncomputing tSNE\n    using sklearn.manifold.TSNE\n    finished: added\n    'X_tsne', tSNE coordinates (adata.obsm) (0:00:11)\n```\n:::\n:::\n\n\n{{< meta int_plot >}}\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN tsne\", ax=axs[0,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Scanorama tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Scanorama umap\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n<Axes: title={'center': 'Scanorama umap'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-23-output-2.png){}\n:::\n:::\n\n\n{{< meta int_save >}}\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n#save to file\nsave_file = './data/covid/results/scanpy_covid_qc_dr_scanorama.h5ad'\nadata_sc.write_h5ad(save_file)\n```\n:::\n\n\n## Compare all\n\n:::{.callout-note title=\"Discuss\"}\nPlot umap of all the methods we tested here. Which do you think looks better and why?\n:::\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected\", ax=axs[0,0], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN\", ax=axs[0,1], show=False)\nsc.pl.umap(adata_combat, color=\"sample\", title=\"Combat\", ax=axs[1,0], show=False)\nsc.pl.umap(adata_sc, color=\"sample\", title=\"Scanorama\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n<Axes: title={'center': 'Scanorama'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-25-output-2.png){}\n:::\n:::\n\n\n:::{.callout-note title=\"Discuss\"}\nHave a look at the documentation for [BBKNN](https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.bbknn.html#scanpy-external-pp-bbknn)\n\nTry changing some of the parameteres in BBKNN, such as distance metric, number of PCs and number of neighbors. How does the results change with different parameters? Can you explain why?\n:::\n\n## {{< meta session >}}\n\n<details>\n  <summary>Click here</summary>\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nsc.logging.print_versions()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-----\nanndata     0.10.3\nscanpy      1.9.6\n-----\nPIL                 10.0.0\nannoy               NA\nanyio               NA\nasttokens           NA\nattr                23.1.0\nbabel               2.12.1\nbackcall            0.2.0\nbbknn               1.6.0\ncertifi             2023.11.17\ncffi                1.15.1\ncharset_normalizer  3.1.0\ncolorama            0.4.6\ncomm                0.1.3\ncycler              0.12.1\ncython_runtime      NA\ndateutil            2.8.2\ndebugpy             1.6.7\ndecorator           5.1.1\ndefusedxml          0.7.1\nexceptiongroup      1.2.0\nexecuting           1.2.0\nfastjsonschema      NA\nfbpca               NA\ngmpy2               2.1.2\nh5py                3.9.0\nidna                3.4\nigraph              0.10.8\nintervaltree        NA\nipykernel           6.23.1\nipython_genutils    0.2.0\njedi                0.18.2\njinja2              3.1.2\njoblib              1.3.2\njson5               NA\njsonpointer         2.0\njsonschema          4.17.3\njupyter_events      0.6.3\njupyter_server      2.6.0\njupyterlab_server   2.22.1\nkiwisolver          1.4.5\nleidenalg           0.10.1\nllvmlite            0.41.1\nlouvain             0.8.1\nmarkupsafe          2.1.2\nmatplotlib          3.8.0\nmatplotlib_inline   0.1.6\nmpl_toolkits        NA\nmpmath              1.3.0\nnatsort             8.4.0\nnbformat            5.8.0\nnumba               0.58.1\nnumpy               1.26.2\nopt_einsum          v3.3.0\noverrides           NA\npackaging           23.1\npandas              2.1.4\nparso               0.8.3\npatsy               0.5.5\npexpect             4.8.0\npickleshare         0.7.5\npkg_resources       NA\nplatformdirs        3.5.1\nprometheus_client   NA\nprompt_toolkit      3.0.38\npsutil              5.9.5\nptyprocess          0.7.0\npure_eval           0.2.2\npvectorc            NA\npycparser           2.21\npydev_ipython       NA\npydevconsole        NA\npydevd              2.9.5\npydevd_file_utils   NA\npydevd_plugins      NA\npydevd_tracing      NA\npygments            2.15.1\npynndescent         0.5.11\npyparsing           3.1.1\npyrsistent          NA\npythonjsonlogger    NA\npytz                2023.3\nrequests            2.31.0\nrfc3339_validator   0.1.4\nrfc3986_validator   0.1.1\nscanorama           1.7.4\nscipy               1.11.4\nsend2trash          NA\nsession_info        1.0.0\nsix                 1.16.0\nsklearn             1.3.2\nsniffio             1.3.0\nsocks               1.7.1\nsortedcontainers    2.4.0\nsparse              0.14.0\nstack_data          0.6.2\nsympy               1.12\ntexttable           1.7.0\nthreadpoolctl       3.2.0\ntorch               2.0.0\ntornado             6.3.2\ntqdm                4.65.0\ntraitlets           5.9.0\ntyping_extensions   NA\numap                0.5.5\nurllib3             2.0.2\nwcwidth             0.2.6\nwebsocket           1.5.2\nyaml                6.0\nzmq                 25.0.2\nzoneinfo            NA\nzstandard           0.19.0\n-----\nIPython             8.13.2\njupyter_client      8.2.0\njupyter_core        5.3.0\njupyterlab          4.0.1\nnotebook            6.5.4\n-----\nPython 3.10.11 | packaged by conda-forge | (main, May 10 2023, 18:58:44) [GCC 11.3.0]\nLinux-6.5.11-linuxkit-x86_64-with-glibc2.35\n-----\nSession information updated at 2024-01-07 15:50\n```\n:::\n:::\n\n\n</details>\n\n",
    "supporting": [
      "scanpy_03_integration_files"
    ],
    "filters": [],
    "includes": {}
  }
}