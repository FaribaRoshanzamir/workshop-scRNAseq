{
  "hash": "c3475c6d5b8e354ca9da33e698fa10c2",
  "result": {
    "markdown": "---\ntitle: \"{{< meta int_title >}}\"\nsubtitle: \"{{< meta subtitle_scanpy >}}\"\ndescription: \"{{< meta int_description >}}\"\nformat: html\nengine: jupyter\n---\n\n::: {.callout-note}\nCode chunks run Python commands unless it starts with `%%bash`, in which case, those chunks run shell commands.\n:::\n\n\n{{< meta int_1 >}}\n\n\n\n|Markdown | Language | Library | Ref|\n|:---|:---|:---|:---|\n|CCA | R | Seurat | [Cell](https://www.sciencedirect.com/science/article/pii/S0092867419305598?via%3Dihub)|\n|MNN | R/Python | Scater/Scanpy | [Nat. Biotech.](https://www.nature.com/articles/nbt.4091)|\n|Conos | R | conos | [Nat. Methods](https://www.nature.com/articles/s41592-019-0466-z?error=cookies_not_supported&code=5680289b-6edb-40ad-9934-415dac4fdb2f)|\n|Scanorama | Python | scanorama | [Nat. Biotech.](https://www.nature.com/articles/s41587-019-0113-3)|\n\n## {{< meta int_prep >}}\n\n\n{{< meta int_prep_1 >}}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3             \n\nsc.settings.set_figure_params(dpi=80)\n%matplotlib inline\n```\n:::\n\n\nCreate individual **adata** objects per batch.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Load the stored data object\nsave_file = './data/results/scanpy_dr_covid.h5ad'\nadata = sc.read_h5ad(save_file)\n\nprint(adata.X.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5646, 3090)\n```\n:::\n:::\n\n\nAs the stored AnnData object contains scaled data based on variable genes, we need to make a new object with the logtransformed normalized counts. The new variable gene selection should not be performed on the scaled data matrix.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nadata2 = adata.raw.to_adata() \n\nadata2.uns['log1p']['base']=None\n\n# check that the matrix looks like normalized counts\nprint(adata2.X[1:10,1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  (0, 5)\t0.9678402572038912\n  (1, 5)\t0.5124039238100646\n```\n:::\n:::\n\n\n## Detect variable genes\n\nVariable genes can be detected across the full dataset, but then we run the risk of getting many batch-specific genes that will drive a lot of the variation. Or we can select variable genes from each batch separately to get only celltype variation. In the dimensionality reduction exercise, we already selected variable genes, so they are already stored in `adata.var.highly_variable`.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nvar_genes_all = adata.var.highly_variable\n\nprint(\"Highly variable genes: %d\"%sum(var_genes_all))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHighly variable genes: 3090\n```\n:::\n:::\n\n\nDetect variable genes in each dataset separately using the `batch_key` parameter.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nsc.pp.highly_variable_genes(adata2, min_mean=0.0125, max_mean=3, min_disp=0.5, batch_key = 'sample')\n\nprint(\"Highly variable genes intersection: %d\"%sum(adata2.var.highly_variable_intersection))\n\nprint(\"Number of batches where gene is variable:\")\nprint(adata2.var.highly_variable_nbatches.value_counts())\n\nvar_genes_batch = adata2.var.highly_variable_nbatches > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHighly variable genes intersection: 147\nNumber of batches where gene is variable:\n0    8103\n1    4754\n2    3154\n3    1638\n4     705\n5     251\n6     147\nName: highly_variable_nbatches, dtype: int64\n```\n:::\n:::\n\n\nCompare overlap of variable genes with batches or with all data.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nprint(\"Any batch var genes: %d\"%sum(var_genes_batch))\nprint(\"All data var genes: %d\"%sum(var_genes_all))\nprint(\"Overlap: %d\"%sum(var_genes_batch & var_genes_all))\nprint(\"Variable genes in all batches: %d\"%sum(adata2.var.highly_variable_nbatches == 6))\nprint(\"Overlap batch instersection and all: %d\"%sum(var_genes_all & adata2.var.highly_variable_intersection))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAny batch var genes: 10649\nAll data var genes: 3090\nOverlap: 3086\nVariable genes in all batches: 147\nOverlap batch instersection and all: 147\n```\n:::\n:::\n\n\nSelect all genes that are variable in at least 2 datasets and use for remaining analysis.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nvar_select = adata2.var.highly_variable_nbatches > 2\nvar_genes = var_select.index[var_select]\nlen(var_genes)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n2741\n```\n:::\n:::\n\n\n## BBKNN\n\nFirst, we will run BBKNN that is implemented in scanpy.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport bbknn\nbbknn.bbknn(adata2,batch_key='sample')\n\n# then run umap on the integrated space\nsc.tl.umap(adata2)\nsc.tl.tsne(adata2)\n```\n:::\n\n\n{{< meta int_plot >}}\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.tsne(adata2, color=\"sample\", title=\"BBKNN Corrected tsne\", ax=axs[0,0], show=False)\nsc.pl.tsne(adata, color=\"sample\", title=\"Uncorrected tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN Corrected umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected umap\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<AxesSubplot: title={'center': 'Uncorrected umap'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-10-output-2.png){}\n:::\n:::\n\n\n{{< meta int_save >}}\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsave_file = './data/results/scanpy_bbknn_corrected_covid.h5ad'\nadata2.write_h5ad(save_file)\n```\n:::\n\n\n## Combat\n\nBatch correction can also be performed with combat. Note that ComBat batch correction requires a dense matrix format as input (which is already the case in this example).\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# create a new object with lognormalized counts\nadata_combat = sc.AnnData(X=adata.raw.X, var=adata.raw.var, obs = adata.obs)\n\n# first store the raw data \nadata_combat.raw = adata_combat\n\n# run combat\nsc.pp.combat(adata_combat, key='sample')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound 25 genes with zero variance.\n```\n:::\n:::\n\n\nThen we run the regular steps of dimensionality reduction on the combat corrected data. Variable gene selection, pca and umap with combat data.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsc.pp.highly_variable_genes(adata_combat)\nprint(\"Highly variable genes: %d\"%sum(adata_combat.var.highly_variable))\nsc.pl.highly_variable_genes(adata_combat)\n\nsc.pp.pca(adata_combat, n_comps=30, use_highly_variable=True, svd_solver='arpack')\n\nsc.pp.neighbors(adata_combat)\n\nsc.tl.umap(adata_combat)\nsc.tl.tsne(adata_combat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHighly variable genes: 3915\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-13-output-2.png){}\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# compare var_genes\nvar_genes_combat = adata_combat.var.highly_variable\nprint(\"With all data %d\"%sum(var_genes_all))\nprint(\"With combat %d\"%sum(var_genes_combat))\nprint(\"Overlap %d\"%sum(var_genes_all & var_genes_combat))\n\nprint(\"With 2 batches %d\"%sum(var_select))\nprint(\"Overlap %d\"%sum(var_genes_combat & var_select))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWith all data 3090\nWith combat 3915\nOverlap 2268\nWith 2 batches 2741\nOverlap 2040\n```\n:::\n:::\n\n\n{{< meta int_plot >}}\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.tsne(adata2, color=\"sample\", title=\"BBKNN tsne\", ax=axs[0,0], show=False)\nsc.pl.tsne(adata_combat, color=\"sample\", title=\"Combat tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata_combat, color=\"sample\", title=\"Combat umap\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n<AxesSubplot: title={'center': 'Combat umap'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-15-output-2.png){}\n:::\n:::\n\n\n{{< meta int_save >}}\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n#save to file\nsave_file = './data/results/scanpy_combat_corrected_covid.h5ad'\nadata_combat.write_h5ad(save_file)\n```\n:::\n\n\n## {{< meta int_scanorama >}}\n\n\n{{< meta int_scanorama_1 >}}\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# split per batch into new objects.\nbatches = adata.obs['sample'].cat.categories.tolist()\nalldata = {}\nfor batch in batches:\n    alldata[batch] = adata2[adata2.obs['sample'] == batch,]\n\nalldata   \n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n{'covid_1': View of AnnData object with n_obs × n_vars = 844 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'covid_15': View of AnnData object with n_obs × n_vars = 583 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'covid_17': View of AnnData object with n_obs × n_vars = 1018 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_5': View of AnnData object with n_obs × n_vars = 1028 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_13': View of AnnData object with n_obs × n_vars = 1132 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_14': View of AnnData object with n_obs × n_vars = 1041 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances'}\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport scanorama\n\n#subset the individual dataset to the variable genes we defined at the beginning\nalldata2 = dict()\nfor ds in alldata.keys():\n    print(ds)\n    alldata2[ds] = alldata[ds][:,var_genes]\n\n#convert to list of AnnData objects\nadatas = list(alldata2.values())\n\n# run scanorama.integrate\nscanorama.integrate_scanpy(adatas, dimred = 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncovid_1\ncovid_15\ncovid_17\nctrl_5\nctrl_13\nctrl_14\nFound 2741 genes among all datasets\n[[0.         0.78216123 0.3497053  0.57345972 0.45260664 0.40521327]\n [0.         0.         0.55403087 0.5        0.31903945 0.37049743]\n [0.         0.         0.         0.36770428 0.10314342 0.1453831 ]\n [0.         0.         0.         0.         0.86770428 0.72568093]\n [0.         0.         0.         0.         0.         0.85424028]\n [0.         0.         0.         0.         0.         0.        ]]\nProcessing datasets (3, 4)\nProcessing datasets (4, 5)\nProcessing datasets (0, 1)\nProcessing datasets (3, 5)\nProcessing datasets (0, 3)\nProcessing datasets (1, 2)\nProcessing datasets (1, 3)\nProcessing datasets (0, 4)\nProcessing datasets (0, 5)\nProcessing datasets (1, 5)\nProcessing datasets (2, 3)\nProcessing datasets (0, 2)\nProcessing datasets (1, 4)\nProcessing datasets (2, 5)\nProcessing datasets (2, 4)\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n#scanorama adds the corrected matrix to adata.obsm in each of the datasets in adatas.\nadatas[0].obsm['X_scanorama'].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n(844, 50)\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Get all the integrated matrices.\nscanorama_int = [ad.obsm['X_scanorama'] for ad in adatas]\n\n# make into one matrix.\nall_s = np.concatenate(scanorama_int)\nprint(all_s.shape)\n\n# add to the AnnData object, create a new object first\nadata_sc = adata.copy()\nadata_sc.obsm[\"Scanorama\"] = all_s\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5646, 50)\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# tsne and umap\nsc.pp.neighbors(adata_sc, n_pcs =30, use_rep = \"Scanorama\")\nsc.tl.umap(adata_sc)\nsc.tl.tsne(adata_sc, n_pcs = 30, use_rep = \"Scanorama\")\n```\n:::\n\n\n{{< meta int_plot >}}\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN tsne\", ax=axs[0,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Scanorama tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Scanorama umap\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n<AxesSubplot: title={'center': 'Scanorama umap'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-22-output-2.png){}\n:::\n:::\n\n\n{{< meta int_save >}}\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n#save to file\nsave_file = './data/results/scanpy_scanorama_corrected_covid.h5ad'\nadata_sc.write_h5ad(save_file)\n```\n:::\n\n\n## Compare all\n\n:::{.callout-note title=\"Discuss\"}\nPlot umap of all the methods we tested here. Which do you think looks better and why?\n:::\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected\", ax=axs[0,0], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN\", ax=axs[0,1], show=False)\nsc.pl.umap(adata_combat, color=\"sample\", title=\"Combat\", ax=axs[1,0], show=False)\nsc.pl.umap(adata_sc, color=\"sample\", title=\"Scanorama\", ax=axs[1,1], show=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n<AxesSubplot: title={'center': 'Scanorama'}, xlabel='UMAP1', ylabel='UMAP2'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_03_integration_files/figure-html/cell-24-output-2.png){}\n:::\n:::\n\n\n:::{.callout-note title=\"Discuss\"}\nHave a look at the documentation for [BBKNN](https://scanpy.readthedocs.io/en/latest/generated/scanpy.external.pp.bbknn.html#scanpy-external-pp-bbknn)\n\nTry changing some of the parameteres in BBKNN, such as distance metric, number of PCs and number of neighbors. How does the results change with different parameters? Can you explain why?\n:::\n\n## {{< meta session >}}\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nsc.logging.print_versions()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nannoy                       NA\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbbknn                       1.6.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfbpca                       NA\nfqdn                        NA\nget_version                 3.5.4\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nintervaltree                NA\nipykernel                   6.25.2\nipywidgets                  8.1.1\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npatsy                       0.5.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npycparser                   2.21\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npynndescent                 0.5.10\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanorama                   1.7.3\nscanpy                      1.7.2\nscipy                       1.10.1\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nsortedcontainers            2.4.0\nstack_data                  0.6.2\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntqdm                        4.65.0\ntraitlets                   5.11.2\ntyping_extensions           NA\numap                        0.5.4\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-11 20:50\n\n```\n:::\n:::\n\n\n",
    "supporting": [
      "scanpy_03_integration_files"
    ],
    "filters": [],
    "includes": {}
  }
}