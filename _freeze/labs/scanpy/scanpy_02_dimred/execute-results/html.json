{
  "hash": "7f70b32e920370c20a0b41607419a33b",
  "result": {
    "markdown": "---\ntitle: \"{{< meta dimred_title >}}\"\nsubtitle: \"{{< meta subtitle_scanpy >}}\"\ndescription: \"{{< meta dimred_description >}}\"\nformat: html\nengine: jupyter\n---\n\n::: {.callout-note}\nCode chunks run Python commands unless it starts with `%%bash`, in which case, those chunks run shell commands.\n:::\n\n## {{< meta dimred_prep >}}\n\n\n{{< meta dimred_prep_1 >}}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3\n#sc.logging.print_versions()\n\nsc.settings.set_figure_params(dpi=80)\nadata = sc.read_h5ad('data/results/scanpy_qc_filtered_covid.h5ad')\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nAnnData object with n_obs × n_vars = 5646 × 18752\n    obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'connectivities', 'distances'\n```\n:::\n:::\n\n\nBefore variable gene selection we need to normalize and log transform the data. Then  store the full matrix in the `raw` slot before doing variable gene selection.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# normalize to depth 10 000\nsc.pp.normalize_per_cell(adata, counts_per_cell_after=1e4)\n\n# log transform\nsc.pp.log1p(adata)\n\n# store normalized counts in the raw slot, \n# we will subset adata.X for variable genes, but want to keep all genes matrix as well.\nadata.raw = adata\n\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nAnnData object with n_obs × n_vars = 5646 × 18752\n    obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'connectivities', 'distances'\n```\n:::\n:::\n\n\n## {{< meta dimred_fs >}}\n\n\n{{< meta dimred_fs_2 >}}\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# compute variable genes\nsc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)\nprint(\"Highly variable genes: %d\"%sum(adata.var.highly_variable))\n\n#plot variable genes\nsc.pl.highly_variable_genes(adata)\n\n# subset for variable genes in the dataset\nadata = adata[:, adata.var['highly_variable']]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHighly variable genes: 3090\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-4-output-2.png){}\n:::\n:::\n\n\n## {{< meta dimred_zs >}}\n\n\n{{< meta dimred_zs_1 >}}\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n#run this line if you get the \"AttributeError: swapaxes not found\" \n# adata = adata.copy()\n\n# regress out unwanted variables\nsc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt'])\n\n# scale data, clip values exceeding standard deviation 10.\nsc.pp.scale(adata, max_value=10)\n```\n:::\n\n\n## {{< meta dimred_pca >}}\n\n\n{{< meta dimred_pca_1 >}}\n\n\n\nTo run PCA, you can use the function `pca()`.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nsc.tl.pca(adata, svd_solver='arpack')\n```\n:::\n\n\n{{< meta dimred_pca_2 >}}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# plot more PCS\nsc.pl.pca(adata, color='sample', components = ['1,2','3,4','5,6','7,8'], ncols=2)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-7-output-1.png){}\n:::\n:::\n\n\nTo identify genes that contribute most to each PC, one can retrieve the loading matrix information.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n#Plot loadings\nsc.pl.pca_loadings(adata, components=[1,2,3,4,5,6,7,8])\n\n# OBS! only plots the positive axes genes from each PC!!\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\nThe function to plot loading genes only plots genes on the positive axes. Instead plot as a heatmaps, with genes on both positive and negative side, one per pc, and plot their expression amongst cells ordered by their position along the pc.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# adata.obsm[\"X_pca\"] is the embeddings\n# adata.uns[\"pca\"] is pc variance\n# adata.varm['PCs'] is the loadings\n\ngenes = adata.var['gene_ids']\n\nfor pc in [1,2,3,4]:\n    g = adata.varm['PCs'][:,pc-1]\n    o = np.argsort(g)\n    sel = np.concatenate((o[:10],o[-10:])).tolist()\n    emb = adata.obsm['X_pca'][:,pc-1]\n    # order by position on that pc\n    tempdata = adata[np.argsort(emb),]\n    sc.pl.heatmap(tempdata, var_names = genes[sel].index.tolist(), groupby='predicted_doublets', swap_axes = True, use_raw=False)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-9-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-9-output-2.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-9-output-3.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-9-output-4.png){}\n:::\n:::\n\n\n{{< meta dimred_pca_4 >}}\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nsc.pl.pca_variance_ratio(adata, log=True, n_pcs = 50)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-10-output-1.png){}\n:::\n:::\n\n\n{{< meta dimred_pca_5 >}}\n\n\n\n## {{< meta dimred_tsne >}}\n\n\n{{< meta dimred_tsne_1 >}}\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsc.tl.tsne(adata, n_pcs = 30)\n```\n:::\n\n\n{{< meta dimred_tsne_2 >}}\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsc.pl.tsne(adata, color='sample')\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-12-output-1.png){}\n:::\n:::\n\n\n## {{< meta dimred_umap >}}\n\nThe UMAP implementation in SCANPY uses a neighborhood graph as the distance matrix, so we need to first calculate the graph.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsc.pp.neighbors(adata, n_pcs = 30, n_neighbors = 20)\n```\n:::\n\n\n{{< meta dimred_umap_1 >}}\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nsc.tl.umap(adata)\nsc.pl.umap(adata, color='sample')\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-14-output-1.png){}\n:::\n:::\n\n\n{{< meta dimred_umap_2 >}}\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n#run with 10 components, save to a new object so that the umap with 2D is not overwritten.\numap10 = sc.tl.umap(adata, n_components=10, copy=True)\nfig, axs = plt.subplots(1, 3, figsize=(10,4),constrained_layout=True)\n\nsc.pl.umap(adata, color='sample',  title=\"UMAP\", show=False, ax=axs[0])\nsc.pl.umap(umap10, color='sample', title=\"UMAP10\", show=False, ax=axs[1], components=['1,2'])\nsc.pl.umap(umap10, color='sample', title=\"UMAP10\", show=False, ax=axs[2], components=['3,4'])\n\n# we can also plot the umap with neighbor edges\nsc.pl.umap(adata, color='sample', title=\"UMAP\", edges=True)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-15-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-15-output-2.png){}\n:::\n:::\n\n\n{{< meta dimred_umap_3 >}}\n\n\n\nTODO: [pca, tsne and umap plots side by side]\n\n::: {.callout-note title=\"Discuss\"}\n\n{{< meta dimred_umap_4 >}}\n\n\n:::\n\n## {{< meta dimred_plotgenes >}}\n\n\n{{< meta dimred_plotgenes_1 >}}\n\n\n\n|Markers|Cell Type|\n|:---|:---|\n|CD3E|T cells|\n|CD3E CD4|CD4+ T cells|\n|CD3E CD8A|CD8+ T cells|\n|GNLY, NKG7|NK cells|\n|MS4A1|B cells|\n|CD14, LYZ, CST3, MS4A7|CD14+ Monocytes|\n|FCGR3A, LYZ, CST3, MS4A7|FCGR3A+  Monocytes|\n|FCER1A, CST3|DCs|\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nsc.pl.umap(adata, color=[\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR3A\"])\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-16-output-1.png){}\n:::\n:::\n\n\nThe default is to plot gene expression in the normalized and log-transformed data. You can also plot it on the scaled and corrected data by using `use_raw=False`. However, not all of these genes are included in the variable gene set so we first need to filter them.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ngenes  = [\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR3A\"]\nvar_genes = adata.var.highly_variable\nvar_genes.index[var_genes]\nvarg = [x for x in genes if x in var_genes.index[var_genes]]\nsc.pl.umap(adata, color=varg, use_raw=False)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-17-output-1.png){}\n:::\n:::\n\n\n:::{.callout-note title=\"Discuss\"}\n\n{{< meta dimred_plotgenes_2 >}}\n\n\n:::\n\n## {{< meta dimred_save >}}\n\n\n{{< meta dimred_save_1 >}}\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport os\npath = \"./data/results/scanpy_dr_covid.h5ad\"\nif not os.path.exists(path):\n    adata.write_h5ad(path)\n```\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nprint(adata.X.shape)\nprint(adata.raw.X.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5646, 3090)\n(5646, 18752)\n```\n:::\n:::\n\n\n## {{< meta session >}}\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nsc.logging.print_versions()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfqdn                        NA\nget_version                 3.5.4\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nipykernel                   6.25.2\nipywidgets                  8.1.1\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnetworkx                    3.1\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npatsy                       0.5.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npycparser                   2.21\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npynndescent                 0.5.10\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanpy                      1.7.2\nscipy                       1.10.1\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nstack_data                  0.6.2\nstatsmodels                 0.14.0\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntqdm                        4.65.0\ntraitlets                   5.11.2\ntyping_extensions           NA\numap                        0.5.4\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-11 20:49\n\n```\n:::\n:::\n\n\n",
    "supporting": [
      "scanpy_02_dimred_files"
    ],
    "filters": [],
    "includes": {}
  }
}