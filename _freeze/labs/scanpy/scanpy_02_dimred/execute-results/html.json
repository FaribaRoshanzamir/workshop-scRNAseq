{
  "hash": "4e02d7ac9b90ec42be7026703bacb387",
  "result": {
    "markdown": "---\ntitle: \"{{< meta dimred_title >}}\"\nsubtitle: \"{{< meta subtitle_scanpy >}}\"\ndescription: \"{{< meta dimred_description >}}\"\nformat: html\nengine: jupyter\n---\n\n::: {.callout-note}\nCode chunks run Python commands unless it starts with `%%bash`, in which case, those chunks run shell commands.\n:::\n\n## {{< meta dimred_prep >}}\n\n\n{{< meta dimred_prep_1 >}}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\nimport warnings\nimport os\nimport urllib.request\n\nwarnings.simplefilter(action=\"ignore\", category=Warning)\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3\n# sc.logging.print_versions()\n\nsc.settings.set_figure_params(dpi=80)\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npath_data = \"https://export.uppmax.uu.se/naiss2023-23-3/workshops/workshop-scrnaseq\"\n\npath_file = \"data/covid/results/scanpy_covid_qc.h5ad\"\nif not os.path.exists(path_file):\n    urllib.request.urlretrieve(os.path.join(\n        path_data, 'covid/results/scanpy_covid_qc.h5ad'), path_file)\n\nadata = sc.read_h5ad(path_file)\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nAnnData object with n_obs × n_vars = 5725 × 18830\n    obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'connectivities', 'distances'\n```\n:::\n:::\n\n\nBefore variable gene selection we need to normalize and log transform the data. Then  store the full matrix in the `raw` slot before doing variable gene selection.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# normalize to depth 10 000\nsc.pp.normalize_per_cell(adata, counts_per_cell_after=1e4)\n\n# log transform\nsc.pp.log1p(adata)\n\n# store normalized counts in the raw slot, \n# we will subset adata.X for variable genes, but want to keep all genes matrix as well.\nadata.raw = adata\n\nadata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnormalizing by total count per cell\n    finished (0:00:00): normalized adata.X and added    'n_counts', counts per cell before normalization (adata.obs)\nWARNING: adata.X seems to be already log-transformed.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nAnnData object with n_obs × n_vars = 5725 × 18830\n    obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'connectivities', 'distances'\n```\n:::\n:::\n\n\n## {{< meta dimred_fs >}}\n\n\n{{< meta dimred_fs_2 >}}\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# compute variable genes\nsc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)\nprint(\"Highly variable genes: %d\"%sum(adata.var.highly_variable))\n\n#plot variable genes\nsc.pl.highly_variable_genes(adata)\n\n# subset for variable genes in the dataset\nadata = adata[:, adata.var['highly_variable']]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nextracting highly variable genes\n    finished (0:00:01)\n--> added\n    'highly_variable', boolean vector (adata.var)\n    'means', float vector (adata.var)\n    'dispersions', float vector (adata.var)\n    'dispersions_norm', float vector (adata.var)\nHighly variable genes: 2727\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-5-output-2.png){}\n:::\n:::\n\n\n## {{< meta dimred_zs >}}\n\n\n{{< meta dimred_zs_1 >}}\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n#run this line if you get the \"AttributeError: swapaxes not found\" \n# adata = adata.copy()\n\n# regress out unwanted variables\nsc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt'])\n\n# scale data, clip values exceeding standard deviation 10.\nsc.pp.scale(adata, max_value=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nregressing out ['total_counts', 'pct_counts_mt']\n    sparse input is densified and may lead to high memory use\n    finished (0:00:38)\n```\n:::\n:::\n\n\n## {{< meta dimred_pca >}}\n\n\n{{< meta dimred_pca_1 >}}\n\n\n\nTo run PCA, you can use the function `pca()`.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsc.tl.pca(adata, svd_solver='arpack')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing PCA\n    on highly variable genes\n    with n_comps=50\n    finished (0:00:01)\n```\n:::\n:::\n\n\n{{< meta dimred_pca_2 >}}\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# plot more PCS\nsc.pl.pca(adata, color='sample', components = ['1,2','3,4','5,6','7,8'], ncols=2)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\nTo identify genes that contribute most to each PC, one can retrieve the loading matrix information.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n#Plot loadings\nsc.pl.pca_loadings(adata, components=[1,2,3,4,5,6,7,8])\n\n# OBS! only plots the positive axes genes from each PC!!\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\nThe function to plot loading genes only plots genes on the positive axes. Instead plot as a heatmaps, with genes on both positive and negative side, one per pc, and plot their expression amongst cells ordered by their position along the pc.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# adata.obsm[\"X_pca\"] is the embeddings\n# adata.uns[\"pca\"] is pc variance\n# adata.varm['PCs'] is the loadings\n\ngenes = adata.var['gene_ids']\n\nfor pc in [1,2,3,4]:\n    g = adata.varm['PCs'][:,pc-1]\n    o = np.argsort(g)\n    sel = np.concatenate((o[:10],o[-10:])).tolist()\n    emb = adata.obsm['X_pca'][:,pc-1]\n    # order by position on that pc\n    tempdata = adata[np.argsort(emb),]\n    sc.pl.heatmap(tempdata, var_names = genes[sel].index.tolist(), groupby='predicted_doublets', swap_axes = True, use_raw=False)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-10-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-10-output-2.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-10-output-3.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-10-output-4.png){}\n:::\n:::\n\n\n{{< meta dimred_pca_4 >}}\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsc.pl.pca_variance_ratio(adata, log=True, n_pcs = 50)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-11-output-1.png){}\n:::\n:::\n\n\n{{< meta dimred_pca_5 >}}\n\n\n\n## {{< meta dimred_tsne >}}\n\n\n{{< meta dimred_tsne_1 >}}\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsc.tl.tsne(adata, n_pcs = 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing tSNE\n    using 'X_pca' with n_pcs = 30\n    using sklearn.manifold.TSNE\n    finished: added\n    'X_tsne', tSNE coordinates (adata.obsm) (0:00:10)\n```\n:::\n:::\n\n\n{{< meta dimred_tsne_2 >}}\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsc.pl.tsne(adata, color='sample')\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-13-output-1.png){}\n:::\n:::\n\n\n## {{< meta dimred_umap >}}\n\nThe UMAP implementation in SCANPY uses a neighborhood graph as the distance matrix, so we need to first calculate the graph.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nsc.pp.neighbors(adata, n_pcs = 30, n_neighbors = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing neighbors\n    using 'X_pca' with n_pcs = 30\n    finished: added to `.uns['neighbors']`\n    `.obsp['distances']`, distances for each pair of neighbors\n    `.obsp['connectivities']`, weighted adjacency matrix (0:00:08)\n```\n:::\n:::\n\n\n{{< meta dimred_umap_1 >}}\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nsc.tl.umap(adata)\nsc.pl.umap(adata, color='sample')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing UMAP\n    finished: added\n    'X_umap', UMAP coordinates (adata.obsm) (0:00:09)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-15-output-2.png){}\n:::\n:::\n\n\n{{< meta dimred_umap_2 >}}\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n#run with 10 components, save to a new object so that the umap with 2D is not overwritten.\numap10 = sc.tl.umap(adata, n_components=10, copy=True)\nfig, axs = plt.subplots(1, 3, figsize=(10,4),constrained_layout=True)\n\nsc.pl.umap(adata, color='sample',  title=\"UMAP\", show=False, ax=axs[0])\nsc.pl.umap(umap10, color='sample', title=\"UMAP10\", show=False, ax=axs[1], components=['1,2'])\nsc.pl.umap(umap10, color='sample', title=\"UMAP10\", show=False, ax=axs[2], components=['3,4'])\n\n# we can also plot the umap with neighbor edges\nsc.pl.umap(adata, color='sample', title=\"UMAP\", edges=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing UMAP\n    finished: added\n    'X_umap', UMAP coordinates (adata.obsm) (0:00:10)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-16-output-2.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-16-output-3.png){}\n:::\n:::\n\n\n{{< meta dimred_umap_3 >}}\n\n\n\nTODO: [pca, tsne and umap plots side by side]\n\n::: {.callout-note title=\"Discuss\"}\n\n{{< meta dimred_umap_4 >}}\n\n\n:::\n\n## {{< meta dimred_plotgenes >}}\n\n\n{{< meta dimred_plotgenes_1 >}}\n\n\n\n|Markers|Cell Type|\n|:---|:---|\n|CD3E|T cells|\n|CD3E CD4|CD4+ T cells|\n|CD3E CD8A|CD8+ T cells|\n|GNLY, NKG7|NK cells|\n|MS4A1|B cells|\n|CD14, LYZ, CST3, MS4A7|CD14+ Monocytes|\n|FCGR3A, LYZ, CST3, MS4A7|FCGR3A+  Monocytes|\n|FCER1A, CST3|DCs|\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nsc.pl.umap(adata, color=[\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR3A\"])\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-17-output-1.png){}\n:::\n:::\n\n\nThe default is to plot gene expression in the normalized and log-transformed data. You can also plot it on the scaled and corrected data by using `use_raw=False`. However, not all of these genes are included in the variable gene set so we first need to filter them.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ngenes  = [\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR3A\"]\nvar_genes = adata.var.highly_variable\nvar_genes.index[var_genes]\nvarg = [x for x in genes if x in var_genes.index[var_genes]]\nsc.pl.umap(adata, color=varg, use_raw=False)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_02_dimred_files/figure-html/cell-18-output-1.png){}\n:::\n:::\n\n\n:::{.callout-note title=\"Discuss\"}\n\n{{< meta dimred_plotgenes_2 >}}\n\n\n:::\n\n## {{< meta dimred_save >}}\n\n\n{{< meta dimred_save_1 >}}\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nadata.write_h5ad('data/covid/results/scanpy_covid_qc_dr.h5ad')\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nprint(adata.X.shape)\nprint(adata.raw.X.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5725, 2727)\n(5725, 18830)\n```\n:::\n:::\n\n\n## {{< meta session >}}\n\n<details>\n  <summary>Click here</summary>\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nsc.logging.print_versions()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-----\nanndata     0.10.3\nscanpy      1.9.6\n-----\nPIL                 10.0.0\nanyio               NA\nasttokens           NA\nattr                23.1.0\nbabel               2.12.1\nbackcall            0.2.0\ncertifi             2023.11.17\ncffi                1.15.1\ncharset_normalizer  3.1.0\ncolorama            0.4.6\ncomm                0.1.3\ncycler              0.12.1\ncython_runtime      NA\ndateutil            2.8.2\ndebugpy             1.6.7\ndecorator           5.1.1\ndefusedxml          0.7.1\nexceptiongroup      1.2.0\nexecuting           1.2.0\nfastjsonschema      NA\ngmpy2               2.1.2\nh5py                3.9.0\nidna                3.4\nigraph              0.10.8\nipykernel           6.23.1\nipython_genutils    0.2.0\njedi                0.18.2\njinja2              3.1.2\njoblib              1.3.2\njson5               NA\njsonpointer         2.0\njsonschema          4.17.3\njupyter_events      0.6.3\njupyter_server      2.6.0\njupyterlab_server   2.22.1\nkiwisolver          1.4.5\nleidenalg           0.10.1\nllvmlite            0.41.1\nlouvain             0.8.1\nmarkupsafe          2.1.2\nmatplotlib          3.8.0\nmatplotlib_inline   0.1.6\nmpl_toolkits        NA\nmpmath              1.3.0\nnatsort             8.4.0\nnbformat            5.8.0\nnetworkx            3.2.1\nnumba               0.58.1\nnumpy               1.26.2\nopt_einsum          v3.3.0\noverrides           NA\npackaging           23.1\npandas              2.1.4\nparso               0.8.3\npatsy               0.5.5\npexpect             4.8.0\npickleshare         0.7.5\npkg_resources       NA\nplatformdirs        3.5.1\nprometheus_client   NA\nprompt_toolkit      3.0.38\npsutil              5.9.5\nptyprocess          0.7.0\npure_eval           0.2.2\npvectorc            NA\npycparser           2.21\npydev_ipython       NA\npydevconsole        NA\npydevd              2.9.5\npydevd_file_utils   NA\npydevd_plugins      NA\npydevd_tracing      NA\npygments            2.15.1\npynndescent         0.5.11\npyparsing           3.1.1\npyrsistent          NA\npythonjsonlogger    NA\npytz                2023.3\nrequests            2.31.0\nrfc3339_validator   0.1.4\nrfc3986_validator   0.1.1\nscipy               1.11.4\nsend2trash          NA\nsession_info        1.0.0\nsix                 1.16.0\nsklearn             1.3.2\nsniffio             1.3.0\nsocks               1.7.1\nsparse              0.14.0\nstack_data          0.6.2\nstatsmodels         0.14.1\nsympy               1.12\ntexttable           1.7.0\nthreadpoolctl       3.2.0\ntorch               2.0.0\ntornado             6.3.2\ntqdm                4.65.0\ntraitlets           5.9.0\ntyping_extensions   NA\numap                0.5.5\nurllib3             2.0.2\nwcwidth             0.2.6\nwebsocket           1.5.2\nyaml                6.0\nzmq                 25.0.2\nzoneinfo            NA\nzstandard           0.19.0\n-----\nIPython             8.13.2\njupyter_client      8.2.0\njupyter_core        5.3.0\njupyterlab          4.0.1\nnotebook            6.5.4\n-----\nPython 3.10.11 | packaged by conda-forge | (main, May 10 2023, 18:58:44) [GCC 11.3.0]\nLinux-6.5.11-linuxkit-x86_64-with-glibc2.35\n-----\nSession information updated at 2024-01-14 12:19\n```\n:::\n:::\n\n\n</details>\n\n",
    "supporting": [
      "scanpy_02_dimred_files"
    ],
    "filters": [],
    "includes": {}
  }
}