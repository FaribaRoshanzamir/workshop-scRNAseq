{
  "hash": "d9ac83e441210810f0767773d4f2d101",
  "result": {
    "markdown": "---\ntitle: \"{{< meta ct_title >}}\"\nsubtitle: \"{{< meta subtitle_scanpy >}}\"\ndescription: \"{{< meta ct_description >}}\"\nformat: html\nengine: jupyter\n---\n\n::: {.callout-note}\nCode chunks run Python commands unless it starts with `%%bash`, in which case, those chunks run shell commands.\n:::\n\n\n{{< meta ct_1 >}}\n\n\n\nHere we will use a reference PBMC dataset that we get from scanpy\ndatasets and classify celltypes based on two methods:\n\n-   Using scanorama for integration just as in the integration lab, and\n    then do label transfer based on closest neighbors.\n-   Using ingest to project the data onto the reference data and\n    transfer labels.\n\n\n{{< meta ct_read_1 >}}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\nimport warnings\nimport os\nimport urllib.request\n\nwarnings.simplefilter(action=\"ignore\", category=Warning)\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 2\nsc.settings.set_figure_params(dpi=80)\n```\n:::\n\n\n{{< meta ct_read_2 >}}\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npath_data = \"https://export.uppmax.uu.se/naiss2023-23-3/workshops/workshop-scrnaseq\"\n\n#path_file = \"data/covid/results/scanpy_covid_qc_dr_scanorama_cl.h5ad\"\npath_file = \"data/covid/results/scanpy_clustered_covid.h5ad\"\nif not os.path.exists(path_file):\n    urllib.request.urlretrieve(os.path.join(\n        path_data, 'covid/results/scanpy_covid_qc_dr_scanorama_cl.h5ad'), path_file)\n\nadata = sc.read_h5ad(path_file)\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nAnnData object with n_obs × n_vars = 5725 × 2727\n    obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info', 'leiden_1.0', 'leiden_0.6', 'leiden_0.4', 'leiden_1.4', 'louvain_1.0', 'louvain_0.6', 'louvain_0.4', 'louvain_1.4', 'kmeans5', 'kmeans10', 'kmeans15', 'hclust_5', 'hclust_10', 'hclust_15'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'\n    uns: 'dendrogram_leiden_0.6', 'dendrogram_louvain_0.6', 'doublet_info_colors', 'hclust_10_colors', 'hclust_15_colors', 'hclust_5_colors', 'hvg', 'kmeans10_colors', 'kmeans15_colors', 'kmeans5_colors', 'leiden', 'leiden_0.4_colors', 'leiden_0.6_colors', 'leiden_1.0_colors', 'leiden_1.4_colors', 'log1p', 'louvain', 'louvain_0.4_colors', 'louvain_0.6_colors', 'louvain_1.0_colors', 'louvain_1.4_colors', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap'\n    obsm: 'Scanorama', 'X_pca', 'X_tsne', 'X_umap'\n    varm: 'PCs'\n    obsp: 'connectivities', 'distances'\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nadata.uns['log1p']['base']=None\nprint(adata.shape)\nprint(adata.raw.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5725, 2727)\n(5725, 18830)\n```\n:::\n:::\n\n\n{{< meta ct_read_3 >}}\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nadata = adata[adata.obs[\"sample\"] == \"ctrl_13\",:]\nprint(adata.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1117, 2727)\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nsc.pl.umap(\n    adata, color=[\"louvain_0.6\"], palette=sc.pl.palettes.default_20\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-6-output-1.png){}\n:::\n:::\n\n\n## {{< meta ct_ref >}}\n\nLoad the reference data from `scanpy.datasets`. It is the annotated and processed pbmc3k dataset from 10x.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nadata_ref = sc.datasets.pbmc3k_processed() \n\nadata_ref.obs['sample']='pbmc3k'\n\nprint(adata_ref.shape)\nadata_ref.obs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntry downloading from url\nhttps://raw.githubusercontent.com/chanzuckerberg/cellxgene/main/example-dataset/pbmc3k.h5ad\n... this may take a while but only happens once\n(2638, 1838)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>n_genes</th>\n      <th>percent_mito</th>\n      <th>n_counts</th>\n      <th>louvain</th>\n      <th>sample</th>\n    </tr>\n    <tr>\n      <th>index</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AAACATACAACCAC-1</th>\n      <td>781</td>\n      <td>0.030178</td>\n      <td>2419.0</td>\n      <td>CD4 T cells</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>AAACATTGAGCTAC-1</th>\n      <td>1352</td>\n      <td>0.037936</td>\n      <td>4903.0</td>\n      <td>B cells</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>AAACATTGATCAGC-1</th>\n      <td>1131</td>\n      <td>0.008897</td>\n      <td>3147.0</td>\n      <td>CD4 T cells</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>AAACCGTGCTTCCG-1</th>\n      <td>960</td>\n      <td>0.017431</td>\n      <td>2639.0</td>\n      <td>CD14+ Monocytes</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>AAACCGTGTATGCG-1</th>\n      <td>522</td>\n      <td>0.012245</td>\n      <td>980.0</td>\n      <td>NK cells</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>TTTCGAACTCTCAT-1</th>\n      <td>1155</td>\n      <td>0.021104</td>\n      <td>3459.0</td>\n      <td>CD14+ Monocytes</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>TTTCTACTGAGGCA-1</th>\n      <td>1227</td>\n      <td>0.009294</td>\n      <td>3443.0</td>\n      <td>B cells</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>TTTCTACTTCCTCG-1</th>\n      <td>622</td>\n      <td>0.021971</td>\n      <td>1684.0</td>\n      <td>B cells</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>TTTGCATGAGAGGC-1</th>\n      <td>454</td>\n      <td>0.020548</td>\n      <td>1022.0</td>\n      <td>B cells</td>\n      <td>pbmc3k</td>\n    </tr>\n    <tr>\n      <th>TTTGCATGCCTCAC-1</th>\n      <td>724</td>\n      <td>0.008065</td>\n      <td>1984.0</td>\n      <td>CD4 T cells</td>\n      <td>pbmc3k</td>\n    </tr>\n  </tbody>\n</table>\n<p>2638 rows × 5 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nsc.pl.umap(adata_ref, color='louvain')\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\nMake sure we have the same genes in both datset by taking the intersection\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(adata_ref.shape[1])\nprint(adata.shape[1])\nvar_names = adata_ref.var_names.intersection(adata.var_names)\nprint(len(var_names))\n\nadata_ref = adata_ref[:, var_names]\nadata = adata[:, var_names]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1838\n2727\n427\n```\n:::\n:::\n\n\nFirst we need to rerun pca and umap with the same gene set for both datasets.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nsc.pp.pca(adata_ref)\nsc.pp.neighbors(adata_ref)\nsc.tl.umap(adata_ref)\nsc.pl.umap(adata_ref, color='louvain')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing PCA\n    with n_comps=50\n    finished (0:00:00)\ncomputing neighbors\n    using 'X_pca' with n_pcs = 50\n    finished (0:00:08)\ncomputing UMAP\n    finished (0:00:04)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-10-output-2.png){}\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsc.pp.pca(adata)\nsc.pp.neighbors(adata)\nsc.tl.umap(adata)\nsc.pl.umap(adata, color='louvain_0.6')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing PCA\n    on highly variable genes\n    with n_comps=50\n    finished (0:00:00)\ncomputing neighbors\n    using 'X_pca' with n_pcs = 50\n    finished (0:00:00)\ncomputing UMAP\n    finished (0:00:02)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-11-output-2.png){}\n:::\n:::\n\n\n## Integrate with scanorama\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport scanorama\n\n#subset the individual dataset to the same variable genes as in MNN-correct.\nalldata = dict()\nalldata['ctrl']=adata\nalldata['ref']=adata_ref\n\n#convert to list of AnnData objects\nadatas = list(alldata.values())\n\n# run scanorama.integrate\nscanorama.integrate_scanpy(adatas, dimred = 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound 427 genes among all datasets\n[[0.         0.96329454]\n [0.         0.        ]]\nProcessing datasets (0, 1)\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# add in sample info\nadata_ref.obs['sample']='pbmc3k'\n\n# create a merged scanpy object and add in the scanorama \nadata_merged = alldata['ctrl'].concatenate(alldata['ref'], batch_key='sample', batch_categories=['ctrl','pbmc3k'])\n\nembedding = np.concatenate([ad.obsm['X_scanorama'] for ad in adatas], axis=0)\nadata_merged.obsm['Scanorama'] = embedding\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n#run  umap.\nsc.pp.neighbors(adata_merged, n_pcs =50, use_rep = \"Scanorama\")\nsc.tl.umap(adata_merged)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncomputing neighbors\n    finished (0:00:00)\ncomputing UMAP\n    finished (0:00:05)\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nsc.pl.umap(adata_merged, color=[\"sample\",\"louvain\"])\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-15-output-1.png){}\n:::\n:::\n\n\n### Label transfer\n\nUsing the function in the Spatial tutorial at the scanpy website we will calculate normalized cosine distances between the two datasets and tranfer labels to the celltype with the highest scores.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfrom sklearn.metrics.pairwise import cosine_distances\n\ndistances = 1 - cosine_distances(\n    adata_merged[adata_merged.obs['sample'] == \"pbmc3k\"].obsm[\"Scanorama\"],\n    adata_merged[adata_merged.obs['sample'] == \"ctrl\"].obsm[\"Scanorama\"],\n)\n\ndef label_transfer(dist, labels, index):\n    lab = pd.get_dummies(labels)\n    class_prob = lab.to_numpy().T @ dist\n    norm = np.linalg.norm(class_prob, 2, axis=0)\n    class_prob = class_prob / norm\n    class_prob = (class_prob.T - class_prob.min(1)) / class_prob.ptp(1)\n    # convert to df\n    cp_df = pd.DataFrame(\n        class_prob, columns=lab.columns\n    )\n    cp_df.index = index\n    # classify as max score\n    m = cp_df.idxmax(axis=1)\n    \n    return m\n\nclass_def = label_transfer(distances, adata_ref.obs.louvain, adata.obs.index)\n\n# add to obs section of the original object\nadata.obs['predicted'] = class_def\n\nsc.pl.umap(adata, color=\"predicted\")\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-16-output-1.png){}\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# add to merged object.\nadata_merged.obs[\"predicted\"] = pd.concat(\n    [class_def, adata_ref.obs[\"louvain\"]], axis=0\n).tolist()\n\nsc.pl.umap(adata_merged, color=[\"sample\",\"louvain\",'predicted'])\n#plot only ctrl cells.\nsc.pl.umap(adata_merged[adata_merged.obs['sample']=='ctrl'], color='predicted')\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-17-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-17-output-2.png){}\n:::\n:::\n\n\n## Ingest\n\nAnother method for celltype prediction is Ingest, for more information, please look at\nhttps://scanpy-tutorials.readthedocs.io/en/latest/integrating-data-using-ingest.html\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nsc.tl.ingest(adata, adata_ref, obs='louvain')\nsc.pl.umap(adata, color=['louvain','louvain_0.6'], wspace=0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrunning ingest\n    finished (0:00:20)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-18-output-2.png){}\n:::\n:::\n\n\n## Compare results\n\nThe predictions from ingest is stored in the column 'louvain' while we\nnamed the label transfer with scanorama as 'predicted'\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nsc.pl.umap(adata, color=['louvain','predicted'], wspace=0.5)\n```\n\n::: {.cell-output .cell-output-display}\n![](scanpy_06_celltyping_files/figure-html/cell-19-output-1.png){}\n:::\n:::\n\n\nAs you can see, the main celltypes are the same, but dendritic cells are mainly predicted to cluster 8 by ingest and the proportions of the different celltypes are different.\n\nThe only way to make sure which method you trust is to look at what genes the different celltypes express and use your biological knowledge to make decisions.\n\n## Gene set analysis\n\nAnother way of predicting celltypes is to use the differentially expressed genes per cluster and compare to lists of known cell marker genes. This requires a list of genes that you trust and that is relevant\nfor the tissue you are working on.\n\nYou can either run it with a marker list from the ontology or a list of your choice as in the example below.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\npath_file = 'data/human_cell_markers.txt'\nif not os.path.exists(path_file):\n    urllib.request.urlretrieve(os.path.join(\n        path_data, 'human_cell_markers.txt'), path_file)\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndf = pd.read_table(path_file)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>speciesType</th>\n      <th>tissueType</th>\n      <th>UberonOntologyID</th>\n      <th>cancerType</th>\n      <th>cellType</th>\n      <th>cellName</th>\n      <th>CellOntologyID</th>\n      <th>cellMarker</th>\n      <th>geneSymbol</th>\n      <th>geneID</th>\n      <th>proteinName</th>\n      <th>proteinID</th>\n      <th>markerResource</th>\n      <th>PMID</th>\n      <th>Company</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Human</td>\n      <td>Kidney</td>\n      <td>UBERON_0002113</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>Proximal tubular cell</td>\n      <td>NaN</td>\n      <td>Intestinal Alkaline Phosphatase</td>\n      <td>ALPI</td>\n      <td>248</td>\n      <td>PPBI</td>\n      <td>P09923</td>\n      <td>Experiment</td>\n      <td>9263997</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Human</td>\n      <td>Liver</td>\n      <td>UBERON_0002107</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>Ito cell (hepatic stellate cell)</td>\n      <td>CL_0000632</td>\n      <td>Synaptophysin</td>\n      <td>SYP</td>\n      <td>6855</td>\n      <td>SYPH</td>\n      <td>P08247</td>\n      <td>Experiment</td>\n      <td>10595912</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Human</td>\n      <td>Endometrium</td>\n      <td>UBERON_0001295</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>Trophoblast cell</td>\n      <td>CL_0000351</td>\n      <td>CEACAM1</td>\n      <td>CEACAM1</td>\n      <td>634</td>\n      <td>CEAM1</td>\n      <td>P13688</td>\n      <td>Experiment</td>\n      <td>10751340</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Human</td>\n      <td>Germ</td>\n      <td>UBERON_0000923</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>Primordial germ cell</td>\n      <td>CL_0000670</td>\n      <td>VASA</td>\n      <td>DDX4</td>\n      <td>54514</td>\n      <td>DDX4</td>\n      <td>Q9NQI0</td>\n      <td>Experiment</td>\n      <td>10920202</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Human</td>\n      <td>Corneal epithelium</td>\n      <td>UBERON_0001772</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>Epithelial cell</td>\n      <td>CL_0000066</td>\n      <td>KLF6</td>\n      <td>KLF6</td>\n      <td>1316</td>\n      <td>KLF6</td>\n      <td>Q99612</td>\n      <td>Experiment</td>\n      <td>12407152</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>2863</th>\n      <td>Human</td>\n      <td>Embryo</td>\n      <td>UBERON_0000922</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>1-cell stage cell (Blastomere)</td>\n      <td>CL_0000353</td>\n      <td>ACCSL, ACVR1B, ARHGEF16, ASF1B, BCL2L10, BLCAP...</td>\n      <td>ACCSL, ACVR1B, ARHGEF16, ASF1B, BCL2L10, BLCAP...</td>\n      <td>390110, 91, 27237, 55723, 10017, 10904, 662, 7...</td>\n      <td>1A1L2, ACV1B, ARHGG, ASF1B, B2L10, BLCAP, SEC2...</td>\n      <td>Q4AC99, P36896, Q5VV41, Q9NVP2, Q9HD36, P62952...</td>\n      <td>Single-cell sequencing</td>\n      <td>23892778</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2864</th>\n      <td>Human</td>\n      <td>Embryo</td>\n      <td>UBERON_0000922</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>4-cell stage cell (Blastomere)</td>\n      <td>CL_0000353</td>\n      <td>ADPGK, AIM1, AIMP2, ARG2, ARHGAP17, ARIH1, CDC...</td>\n      <td>ADPGK, CRYBG1, AIMP2, ARG2, ARHGAP17, ARIH1, C...</td>\n      <td>83440, 202, 7965, 384, 55114, 25820, 55536, 24...</td>\n      <td>ADPGK, CRBG1, AIMP2, ARGI2, RHG17, ARI1, CDA7L...</td>\n      <td>Q9BRR6, Q9Y4K1, Q13155, P78540, Q68EM7, Q9Y4X5...</td>\n      <td>Single-cell sequencing</td>\n      <td>23892778</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2865</th>\n      <td>Human</td>\n      <td>Embryo</td>\n      <td>UBERON_0000922</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>8-cell stage cell (Blastomere)</td>\n      <td>CL_0000353</td>\n      <td>C11orf48, C19orf53, DHX9, DIABLO, EIF1AD, EIF4...</td>\n      <td>LBHD1, C19orf53, DHX9, DIABLO, EIF1AD, EIF4G1,...</td>\n      <td>79081, 28974, 1660, 56616, 84285, 1981, 26017,...</td>\n      <td>LBHD1, L10K, DHX9, DBLOH, EIF1A, IF4G1, FA32A,...</td>\n      <td>Q9BQE6, Q9UNZ5, Q08211, Q9NR28, Q8N9N8, Q04637...</td>\n      <td>Single-cell sequencing</td>\n      <td>23892778</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2866</th>\n      <td>Human</td>\n      <td>Embryo</td>\n      <td>UBERON_0000922</td>\n      <td>Normal</td>\n      <td>Normal cell</td>\n      <td>Morula cell (Blastomere)</td>\n      <td>CL_0000360</td>\n      <td>ADCK1, AGL, AIMP1, AKAP12, ARPC3, ATP1B3, ATP5...</td>\n      <td>ADCK1, AGL, AIMP1, AKAP12, ARPC3, ATP1B3, NA, ...</td>\n      <td>57143, 178, 9255, 9590, 10094, 483, NA, 586, 9...</td>\n      <td>ADCK1, GDE, AIMP1, AKA12, ARPC3, AT1B3, AT5F1,...</td>\n      <td>Q86TW2, P35573, Q12904, Q02952, O15145, P54709...</td>\n      <td>Single-cell sequencing</td>\n      <td>23892778</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2867</th>\n      <td>Human</td>\n      <td>Brain</td>\n      <td>UBERON_0000955</td>\n      <td>oligodendroglioma</td>\n      <td>Cancer cell</td>\n      <td>Cancer stem cell</td>\n      <td>NaN</td>\n      <td>ASCL1, BOC, CCND2, CD24, CHD7, EGFR, NFIB, SOX...</td>\n      <td>ASCL1, BOC, CCND2, CD24, CHD7, EGFR, NFIB, SOX...</td>\n      <td>429, 91653, 894, 100133941, 55636, 1956, 4781,...</td>\n      <td>ASCL1, BOC, CCND2, CD24, CHD7, EGFR, NFIB, SOX...</td>\n      <td>P50553, Q9BWV1, P30279, P25063, Q9P2D1, P00533...</td>\n      <td>Single-cell sequencing</td>\n      <td>27806376</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>2868 rows × 15 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Filter for number of genes per celltype\nprint(df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2868, 15)\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndf['nG'] = df.geneSymbol.str.split(\",\").str.len()\n\ndf = df[df['nG'] > 5]\ndf = df[df['nG'] < 100]\nd = df[df['cancerType'] == \"Normal\"]\nprint(df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(445, 16)\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndf.index = df.cellName\ngene_dict = df.geneSymbol.str.split(\",\").to_dict()\n\n# run differential expression per cluster\nsc.tl.rank_genes_groups(adata, 'louvain_0.6', method='wilcoxon', key_added = \"wilcoxon\")\n```\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# do gene set overlap to the groups in the gene list and top 300 DEGs.\n\nimport gseapy\n\ngsea_res = dict()\npred = dict()\n\nfor cl in adata.obs['louvain_0.6'].cat.categories.tolist():\n    print(cl)\n    glist = sc.get.rank_genes_groups_df(adata, group=cl, key='wilcoxon')[\n        'names'].squeeze().str.strip().tolist()\n    enr_res = gseapy.enrichr(gene_list=glist[:300],\n                             organism='Human',\n                             gene_sets=gene_dict,\n                             background=adata.raw.shape[1],\n                             cutoff=1)\n    if enr_res.results.shape[0] == 0:\n        pred[cl] = \"Unass\"\n    else:\n        enr_res.results.sort_values(\n            by=\"P-value\", axis=0, ascending=True, inplace=True)\n        print(enr_res.results.head(2))\n        gsea_res[cl] = enr_res\n        pred[cl] = enr_res.results[\"Term\"][0]\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# prediction per cluster\npred\n```\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nprediction = [pred[x] for x in adata.obs['louvain_0.6']]\nadata.obs[\"GS_overlap_pred\"] = prediction\n\nsc.pl.umap(adata, color='GS_overlap_pred')\n```\n:::\n\n\n:::{.callout-note title=\"Discuss\"}\nAs you can see, it agrees to some extent with the predictions from label transfer and ingest, but there are clear differences, which do you think looks better?\n:::\n\n## {{< meta session >}}\n\n<details>\n  <summary>Click here</summary>\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nsc.logging.print_versions()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-----\nanndata     0.10.3\nscanpy      1.9.6\n-----\nPIL                 10.0.0\nannoy               NA\nanyio               NA\narray_api_compat    1.4\nasttokens           NA\nattr                23.1.0\nbabel               2.12.1\nbackcall            0.2.0\ncertifi             2023.11.17\ncffi                1.15.1\ncharset_normalizer  3.1.0\ncolorama            0.4.6\ncomm                0.1.3\ncycler              0.12.1\ncython_runtime      NA\ndateutil            2.8.2\ndebugpy             1.6.7\ndecorator           5.1.1\ndefusedxml          0.7.1\nexceptiongroup      1.2.0\nexecuting           1.2.0\nfastjsonschema      NA\nfbpca               NA\ngmpy2               2.1.2\nh5py                3.9.0\nidna                3.4\nigraph              0.10.8\nintervaltree        NA\nipykernel           6.23.1\nipython_genutils    0.2.0\njedi                0.18.2\njinja2              3.1.2\njoblib              1.3.2\njson5               NA\njsonpointer         2.0\njsonschema          4.17.3\njupyter_events      0.6.3\njupyter_server      2.6.0\njupyterlab_server   2.22.1\nkiwisolver          1.4.5\nleidenalg           0.10.1\nllvmlite            0.41.1\nlouvain             0.8.1\nmarkupsafe          2.1.2\nmatplotlib          3.8.0\nmatplotlib_inline   0.1.6\nmpl_toolkits        NA\nmpmath              1.3.0\nnatsort             8.4.0\nnbformat            5.8.0\nnumba               0.58.1\nnumpy               1.26.2\nopt_einsum          v3.3.0\noverrides           NA\npackaging           23.1\npandas              2.1.4\nparso               0.8.3\npexpect             4.8.0\npickleshare         0.7.5\npkg_resources       NA\nplatformdirs        3.5.1\nprometheus_client   NA\nprompt_toolkit      3.0.38\npsutil              5.9.5\nptyprocess          0.7.0\npure_eval           0.2.2\npvectorc            NA\npycparser           2.21\npydev_ipython       NA\npydevconsole        NA\npydevd              2.9.5\npydevd_file_utils   NA\npydevd_plugins      NA\npydevd_tracing      NA\npygments            2.15.1\npynndescent         0.5.11\npyparsing           3.1.1\npyrsistent          NA\npythonjsonlogger    NA\npytz                2023.3\nrequests            2.31.0\nrfc3339_validator   0.1.4\nrfc3986_validator   0.1.1\nscanorama           1.7.4\nscipy               1.11.4\nsend2trash          NA\nsession_info        1.0.0\nsix                 1.16.0\nsklearn             1.3.2\nsniffio             1.3.0\nsocks               1.7.1\nsortedcontainers    2.4.0\nsparse              0.14.0\nstack_data          0.6.2\nsympy               1.12\ntexttable           1.7.0\nthreadpoolctl       3.2.0\ntorch               2.0.0\ntornado             6.3.2\ntqdm                4.65.0\ntraitlets           5.9.0\ntyping_extensions   NA\numap                0.5.5\nurllib3             2.0.2\nwcwidth             0.2.6\nwebsocket           1.5.2\nyaml                6.0\nzmq                 25.0.2\nzoneinfo            NA\nzstandard           0.19.0\n-----\nIPython             8.13.2\njupyter_client      8.2.0\njupyter_core        5.3.0\njupyterlab          4.0.1\nnotebook            6.5.4\n-----\nPython 3.10.11 | packaged by conda-forge | (main, May 10 2023, 18:58:44) [GCC 11.3.0]\nLinux-6.5.11-linuxkit-x86_64-with-glibc2.35\n-----\nSession information updated at 2024-01-14 12:24\n```\n:::\n:::\n\n\n</details>\n\n",
    "supporting": [
      "scanpy_06_celltyping_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}