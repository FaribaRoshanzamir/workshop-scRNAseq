[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Overview of scRNAseq technologies\nQuality control of scRNAseq data\nData normalization and transformation\nDimensionality reduction and clustering\nDifferential gene expression\nCelltype prediction\nTrajectory analysis\nSeurat, Bioconductor and Scanpy toolkits\n\n\n\nUpdated: 10-11-2023 at 18:02:58."
  },
  {
    "objectID": "index.html#single-cell-rna-seq-analysis",
    "href": "index.html#single-cell-rna-seq-analysis",
    "title": "",
    "section": "",
    "text": "Overview of scRNAseq technologies\nQuality control of scRNAseq data\nData normalization and transformation\nDimensionality reduction and clustering\nDifferential gene expression\nCelltype prediction\nTrajectory analysis\nSeurat, Bioconductor and Scanpy toolkits\n\n\n\nUpdated: 10-11-2023 at 18:02:58."
  },
  {
    "objectID": "home_schedule.html",
    "href": "home_schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Note\n\n\n\nSchedule is preliminary and may be subject to changes.\n\n\n\n\n\n\n\n\nTime\nTopic\nTeacher\n\n\n\n\n30-Jan-2024TueUppsala\n\n\n09:00 - 09:30\nWelcome and general introduction \nÅsa Björklund\n\n\n09:30 - 10:30\nLecture: scRNAseq methods and ESCG platform \nHenrik Gezelius\n\n\n10:30 - 11:00\nBreak\n\n\n\n11:00 - 12:00\nLecture: Quality control \nÅsa Björklund\n\n\n11:45 - 13:00\nLunch\n\n\n\n13:00 - 13:30\nIntro to Exercises \nÅsa Björklund\n\n\n13:30 - 15:00\nLab: Quality control \nÅsa Björklund\n\n\n15:00 - 15:30\nBreak\n\n\n\n15:30 - 16:30\nLecture: Data normalization \nÅsa Björklund\n\n\n16:30 - 17:00\nWrap Up\n\n\n\n31-Jan-2024WedUppsala\n\n\n09:00 - 10:00\nLecture: Dimensionality reduction \nPaulo Czarnewski\n\n\n10:00 - 10:30\nBreak\n\n\n\n10:30 - 12:00\nLab: Dimensionality reduction \nPaulo Czarnewski\n\n\n11:45 - 13:00\nLunch\n\n\n\n13:00 - 14:00\nLecture: Batch correction + Integration \nPaulo Czarnewski\n\n\n14:00 - 15:00\nLab: Data integration \n\n\n\n15:00 - 15:30\nBreak\n\n\n\n15:30 - 16:30\nLecture: Clustering \nÅsa Björklund\n\n\n16:30 - 18:00\nWrap Up\n\n\n\n18:00 - 21:00\nCourse Dinner\n\n\n\n01-Feb-2024ThuUppsala\n\n\n09:00 - 10:00\nLab: Clustering \n\n\n\n10:00 - 10:30\nBreak\n\n\n\n10:30 - 12:00\nLecture: Single Cell Epigenetics \nJakub Westholm\n\n\n12:00 - 13:00\nLunch\n\n\n\n13:00 - 14:00\nLecture: Differential Gene Expression \nVincent van Hoef\n\n\n14:00 - 14:30\nLecture: Gene set analysis \nPaulo Czarnewski\n\n\n14:30 - 15:00\nBreak\n\n\n\n15:00 - 16:30\nLab: Differential expression \n\n\n\n16:30 - 17:00\nWrap Up\n\n\n\n02-Feb-2024FriUppsala\n\n\n09:00 - 10:00\nLecture: Celltype prediction \nAhmed Mahfouz\n\n\n10:00 - 10:30\nBreak\n\n\n\n10:30 - 12:00\nLab: Celltype prediction \n\n\n\n12:00 - 13:00\nLunch\n\n\n\n13:00 - 14:00\nLecture: Spatial transcriptomics \nAlma Andersson\n\n\n14:00 - 15:00\nLab: Spatial transcriptomics\n\n\n\n15:00 - 15:30\nBreak\n\n\n\n16:30 - 17:00\nWrap Up\n\n\n\n03-Feb-2024SatUppsala\n\n\n09:00 - 10:00\nLecture: Trajectory inference \nPaulo Czarnewski\n\n\n10:00 - 10:30\nBreak\n\n\n\n10:30 - 11:30\nLab: Trajectory inference \n\n\n\n11:30 - 12:00\nSummary of exercises\n\n\n\n12:00 - 13:00\nLunch\n\n\n\n13:00 - 13:30\nWrap Up \n\n\n\n\n\n\n\n\n   Date    Venue    Slides    Lab    Video"
  },
  {
    "objectID": "home_contents.html",
    "href": "home_contents.html",
    "title": "Contents",
    "section": "",
    "text": "Tip\n\n\n\nIt is up to you which one you want to try. In principle, we perform the same steps with all three toolkits, but there are some small differences as all methods are not implemented everywhere. For toolkit environment, see Precourse instructions.\nMany additional information and explanations can be found in the Single Cell Glossary"
  },
  {
    "objectID": "home_contents.html#faq",
    "href": "home_contents.html#faq",
    "title": "Contents",
    "section": "FAQ",
    "text": "FAQ\nPlease refer to the FAQ for troubleshooting common issues.\n\nUseful resources\n\nSingle cell RNA-seq course at from Hemberg lab \nSingle cell RNA-seq course in Python \nSingle cell RNA-seq course at Broad \nRepository listing many scRNA-seq tools \nSingleCellExperiment objects for many datasets \nConquer datasets - many different datasets based on a salmon pipeline \nThe Human Cell Atlas project \nThe github repository for this course \nBitbucket repository for QC report scripts \nBitbucket repository for the NBIS scRNAseq pipeline"
  },
  {
    "objectID": "home_precourse.html",
    "href": "home_precourse.html",
    "title": "Precourse",
    "section": "",
    "text": "We strongly recommend for those not yet familiar with UNIX and/or R/Python to take this opportunity and take these online tutorials, since those are requirements for the workshop. This will help you to develop your programming skills and we can always learn a few tricks here and there, even if you are already experienced.\n\nUNIX (part_1): http://swcarpentry.github.io/shell-novice/\nUNIX (part_2): https://carpentries-incubator.github.io/shell-extras/\nR (part_1): https://swcarpentry.github.io/r-novice-inflammation/\nR (part_2): http://swcarpentry.github.io/r-novice-gapminder/\nPython (part_1):https://swcarpentry.github.io/python-novice-inflammation/\nPython (part_2): http://swcarpentry.github.io/python-novice-gapminder/\n\nAfter taking those courses (or any other equivalent course in programming in bash and R or Python) will provide you with the basics in, for example:\n\nfile structure and manipulation in bash\nloading, handling and manipulating vectors, matrices, factors and lists\ncreating for-loops\nusing Rmarkdown/Jupyter for reports\nediting and writing files in the command line\nand much more …"
  },
  {
    "objectID": "home_precourse.html#knowledge-requirements",
    "href": "home_precourse.html#knowledge-requirements",
    "title": "Precourse",
    "section": "",
    "text": "We strongly recommend for those not yet familiar with UNIX and/or R/Python to take this opportunity and take these online tutorials, since those are requirements for the workshop. This will help you to develop your programming skills and we can always learn a few tricks here and there, even if you are already experienced.\n\nUNIX (part_1): http://swcarpentry.github.io/shell-novice/\nUNIX (part_2): https://carpentries-incubator.github.io/shell-extras/\nR (part_1): https://swcarpentry.github.io/r-novice-inflammation/\nR (part_2): http://swcarpentry.github.io/r-novice-gapminder/\nPython (part_1):https://swcarpentry.github.io/python-novice-inflammation/\nPython (part_2): http://swcarpentry.github.io/python-novice-gapminder/\n\nAfter taking those courses (or any other equivalent course in programming in bash and R or Python) will provide you with the basics in, for example:\n\nfile structure and manipulation in bash\nloading, handling and manipulating vectors, matrices, factors and lists\ncreating for-loops\nusing Rmarkdown/Jupyter for reports\nediting and writing files in the command line\nand much more …"
  },
  {
    "objectID": "home_precourse.html#slack",
    "href": "home_precourse.html#slack",
    "title": "Precourse",
    "section": "2 Slack",
    "text": "2 Slack\nMake sure that you have Slack installed because we will use it a lot during the workshop. Communication, troubleshooting and group discussions will happen via Slack workspace NBIS-workshop-RNAseq. All accepted students will receive an invitation link via email. Please add this workspace to your Slack application on your desktop and NOT use it in the web.\nPlease join the following channels once you are in the workspace:\n\n#software-to-install for questions about installation and troubleshooting\n#general for general questions about the workshop\n\n\n\n\n\n\n\nNote\n\n\n\nPlease post your question in the channel and NOT directly to the teacher. Any participant that knows the answer to any problem is encouraged to help too."
  },
  {
    "objectID": "home_precourse.html#uppmax",
    "href": "home_precourse.html#uppmax",
    "title": "Precourse",
    "section": "3 Uppmax",
    "text": "3 Uppmax\nWe will use the high performance computing cluster (HPC) UPPMAX for the workshop. You will need to create accounts if you don’t already have one. And you will need to join the course project. See instructions here."
  },
  {
    "objectID": "home_precourse.html#dockersingularity",
    "href": "home_precourse.html#dockersingularity",
    "title": "Precourse",
    "section": "4 Docker/Singularity",
    "text": "4 Docker/Singularity\nA Docker/Singularity container allows you to reproducible the results using the same versions of tools as we use on the workshop. To setup / use docker, see here."
  },
  {
    "objectID": "home_precourse.html#conda-optional",
    "href": "home_precourse.html#conda-optional",
    "title": "Precourse",
    "section": "5 Conda (Optional)",
    "text": "5 Conda (Optional)\nA Conda environment allows you to reproducible the results using the same versions of tools as we use on the workshop. Download the conda environment here.\nconda.yml \nFor conda usage instructions, see here."
  },
  {
    "objectID": "home_precourse.html#datasets",
    "href": "home_precourse.html#datasets",
    "title": "Precourse",
    "section": "6 Datasets",
    "text": "6 Datasets\nDatasets for this workshop are hosted on an instance of Figshare."
  },
  {
    "objectID": "home_syllabus.html",
    "href": "home_syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "SyllabusWho can apply?Entry requirements\n\n\nThis workshop will cover the basic steps in single cell RNAseq (scRNAseq) processing and data analysis, with lectures and practical exercises. Topics covered will include:\n\nOverview of the current scRNAseq technologies\nRaw reads into expression values\nQuality control of scRNAseq data\nDimensionality reduction and clustering techniques\nData normalization\nDifferential gene expression for scRNAseq data\nCelltype prediction\nTrajectory analysis\nComparison of sc analysis toolkits: Seurat, Bioconductor and Scanpy\n\n\n\nThis is a national workshop open for PhD students, postdocs, group leaders and core facility staff within all Swedish universities. We do accept application from other countries, but priority is given to applicants from Swedish universities prior to applicants from industry and academics from other countries.\nPlease note that NBIS training events do not provide any formal university credits. The training content is estimated to correspond to a certain number of credits, however the estimated credits are just guidelines. If formal credits are crucial, the student needs to confer with the home department before submitting a workshop application in order to establish whether the workshop is valid for formal credits or not.\nWe cannot invoice private individuals, therefore an affiliation is required.\n\n\nPractical exercises can be performed using R or Python, so we only accept students with previous experience in one of those programming languages.\n\nBasic knowledge in R/Python and command line (bash).\nBe able to use your own computer with R or Python installed for the practical computational exercises. Instructions on installation will be sent by email to accepted participants.\nProgramming/scripting experience is required (in R or python).\nBasic understanding of NGS technologies and RNA-sequencing data.\nDesirable: Previous experience with RNA-seq analysis and/or participation in NGS/RNA-seq workshop is an advantage.\n\nDue to limited space the workshop can accommodate maximum of 25 participants. If we receive more applications, participants will be selected based on several criteria. Selection criteria include correct entry requirements, motivation to attend the workshop as well as gender and geographical balance."
  },
  {
    "objectID": "home_info.html",
    "href": "home_info.html",
    "title": "Practical Info",
    "section": "",
    "text": "Uppsala\n\n\n\n\n\n\n\n\nRoom E10:1309 Entrance C11 Biomedicinskt centrum Uppsala University / ScilifeLab Husargatan 3 75237 Uppsala Sweden\nFew selected hotels are listed below ranked by distance from the venue.\n\nHotel von Kraemer (900 m, 11 min walk)\nAkademihotellet (1.7 Km, 21 min walk)\nCityStay Hotell (1.8 Km, 21 min walk)\nGrand Hotel Hörnan (1.9 Km, 23 min walk)\nHotell Centralstation (2.1 Km, 25 min walk)\nBest Western Svava (2.2 Km, 26 min walk)\n\nThe venue and hotels are also marked on the map.\nUse the UL website or the UL app for bus and train services around Uppsala. For buses from the Centralstation (Train/Bus), take Bus 4 (towards Gottsunda Centrum) or 8 (towards Sunnersta) and get off at the stop Uppsala Science Park. Bus tickets can be purchased in the app or directly from the driver using a credit card."
  },
  {
    "objectID": "home_info.html#location",
    "href": "home_info.html#location",
    "title": "Practical Info",
    "section": "",
    "text": "Uppsala\n\n\n\n\n\n\n\n\nRoom E10:1309 Entrance C11 Biomedicinskt centrum Uppsala University / ScilifeLab Husargatan 3 75237 Uppsala Sweden\nFew selected hotels are listed below ranked by distance from the venue.\n\nHotel von Kraemer (900 m, 11 min walk)\nAkademihotellet (1.7 Km, 21 min walk)\nCityStay Hotell (1.8 Km, 21 min walk)\nGrand Hotel Hörnan (1.9 Km, 23 min walk)\nHotell Centralstation (2.1 Km, 25 min walk)\nBest Western Svava (2.2 Km, 26 min walk)\n\nThe venue and hotels are also marked on the map.\nUse the UL website or the UL app for bus and train services around Uppsala. For buses from the Centralstation (Train/Bus), take Bus 4 (towards Gottsunda Centrum) or 8 (towards Sunnersta) and get off at the stop Uppsala Science Park. Bus tickets can be purchased in the app or directly from the driver using a credit card."
  },
  {
    "objectID": "home_info.html#contact",
    "href": "home_info.html#contact",
    "title": "Practical Info",
    "section": "Contact",
    "text": "Contact\nThis workshop is run by the National Bioinformatics Infrastructure Sweden (NBIS). NBIS is a platform at SciLifeLab.\nIf you would like to get in touch with us regarding this workshop, please contact us at edu.sc [at] nbis.se."
  },
  {
    "objectID": "other/faq.html",
    "href": "other/faq.html",
    "title": "FAQ",
    "section": "",
    "text": "If you don’t yet have Mac OSX command line developer tools, please install it using:\nxcode-select --install"
  },
  {
    "objectID": "other/faq.html#command-line-developer-tools-not-found-fa-brands-apple",
    "href": "other/faq.html#command-line-developer-tools-not-found-fa-brands-apple",
    "title": "FAQ",
    "section": "",
    "text": "If you don’t yet have Mac OSX command line developer tools, please install it using:\nxcode-select --install"
  },
  {
    "objectID": "other/faq.html#error---umap-learn-not-found-or-other-python-packages-fa-brands-r-project",
    "href": "other/faq.html#error---umap-learn-not-found-or-other-python-packages-fa-brands-r-project",
    "title": "FAQ",
    "section": "2 Error - umap-learn not found, or other python packages ",
    "text": "2 Error - umap-learn not found, or other python packages \nIf your R does not find the correct python version, it will complain that umap-learn is not installed and ask you to install it. Here are some tips on how to find the correct python version that was installed in the conda environment.\nTry selecting the correct conda env in R\nIn this example the conda environment is named scRNAseq2021.\nlibrary(reticulate)\nreticulate::use_conda(\"scRNAseq2021\")\nThen check what python you have in R:\nreticulate::py_config()\n# should read at top:\npython:         /Users/asbj/miniconda3/envs/scRNAseq2021/bin/python\nIf that still is not right, you may have an r-reticulate python installation as well and need to perform the steps below.\nRestart R and select python version\nOBS! Before doing anything else you need to select python version.\nFirst, find out what path you have to your conda python (in TERMINAL):\nwhich python\n/Users/asbj/miniconda3/envs/scRNAseq2021/bin/python\nThen in R (after restarting):\nreticulate::use_python(\"/Users/asbj/miniconda3/envs/scRNAseq2021/bin/python\", required=T)\nThen check again with py_config if correct version of python is used:\nreticulate::py_config()\nIf you have the correct version now, you should be able to run UMAP without issues."
  },
  {
    "objectID": "other/faq.html#unable-to-load-stringi.so-fa-brands-windows-fa-brands-ubuntu",
    "href": "other/faq.html#unable-to-load-stringi.so-fa-brands-windows-fa-brands-ubuntu",
    "title": "FAQ",
    "section": "3 Unable to load stringi.so  ",
    "text": "3 Unable to load stringi.so  \nYou can install stringi in R using:\ninstall.packages('stringi')"
  },
  {
    "objectID": "other/faq.html#error-failed-building-wheel-for-gevent-macosx10.9.sdk-missing-fa-brands-apple",
    "href": "other/faq.html#error-failed-building-wheel-for-gevent-macosx10.9.sdk-missing-fa-brands-apple",
    "title": "FAQ",
    "section": "4 ERROR: Failed building wheel for gevent / MacOSX10.9.sdk missing ",
    "text": "4 ERROR: Failed building wheel for gevent / MacOSX10.9.sdk missing \nThis is a problem with the MacOSX compiler, in which conda is unable to find it.\n#Download MacOSX10.9.sdk from Github\ncurl -o MacOSX10.9.sdk.tar.gz \"https://github.com/phracker/MacOSX-SDKs/releases/download/11.3/MacOSX10.9.sdk.tar.xz\"\n\n#extract\nsudo tar -xzf MacOSX10.9.sdk.tar.xz\n\n#copy\nsudo cp -r MacOSX10.9.sdk /opt/\n\n#give executable permissions\nsudo chmod -R a+rX /opt\n\n#Link the path where conda looks to where the file is\nln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk /opt/MacOSX10.9.sdk"
  },
  {
    "objectID": "other/faq.html#error-option-error-has-null-value-fa-brands-r-project",
    "href": "other/faq.html#error-option-error-has-null-value-fa-brands-r-project",
    "title": "FAQ",
    "section": "5 ERROR: option error has NULL value ",
    "text": "5 ERROR: option error has NULL value \nThis error happens when running code inline.\nOne possible solution is to restart Rstudio and type.\nif(interactive()) { options(error = utils::recover)}\nPlease try other solutions listed here: https://github.com/rstudio/rstudio/issues/4723\nIf none of those work, you can click on the wheel engine symbol and check Chunk output in console"
  },
  {
    "objectID": "other/faq.html#r-crashes-due-to-memory-issues-fa-brands-r-project",
    "href": "other/faq.html#r-crashes-due-to-memory-issues-fa-brands-r-project",
    "title": "FAQ",
    "section": "6 R crashes due to memory issues ",
    "text": "6 R crashes due to memory issues \nIf R crashes due to memory issues, it may be a good idea to increase the vector size R_MAX_VSIZE. Put in the file .Renviron either in your home directory or the folder you are launching Rstudio from:\nR_MAX_VSIZE=70Gb\nOr to whatever value matches your computer, the default size is 16Gb."
  },
  {
    "objectID": "other/docker.html",
    "href": "other/docker.html",
    "title": "Docker",
    "section": "",
    "text": "In the last case scenario, if you are having problems installing R packages, please follow these instructions to setup a docker container with R and Rstudio. Then you will need to install packages as usual. See the precourse material for package installations."
  },
  {
    "objectID": "other/docker.html#installing-docker",
    "href": "other/docker.html#installing-docker",
    "title": "Docker",
    "section": "1 Installing Docker",
    "text": "1 Installing Docker\n\nInstall docker. You need permission to both install and use sudo commands.\n\n\nMac: https://docs.docker.com/docker-for-mac/install/\nWindows: https://docs.docker.com/docker-for-windows/install/\nUbuntu: https://docs.docker.com/install/linux/docker-ce/ubuntu/\n\n\nLaunch docker and got to Preferences &gt; Resources &gt; Advanced and set Memory=8gb, cpu=4, swp=1. These will set the maximum values possible for your machine.\nNow go to Preferences &gt; Security and tick on “Allow connections from network clients”, so that you can communicate with DockerServer.\nOpen a terminal shell.\nYou will need to use docker-machine. If your docker version does not automatically install docker-machine in terminal, please follow these instructions to install it. Then create a Virtual Machine (VM) named “default” and set the amount of CPU and RAM available for you:\n\ndocker-machine create default\nVBoxManage modifyvm default --cpus 4\nVBoxManage modifyvm default --memory 8192\n\nYou can now start the machine, the environment (which will give you an IP address to connect to it!) and configure your shell to work with docker.\n\ndocker-machine start\ndocker-machine env\neval \"$(docker-machine env default)\"\nIf at any point from now on you get an error asking you to stop the container, you can do so with:\ndocker-machine stop"
  },
  {
    "objectID": "other/docker.html#using-the-singlecellschool-container",
    "href": "other/docker.html#using-the-singlecellschool-container",
    "title": "Docker",
    "section": "2 Using the SingleCellSchool container",
    "text": "2 Using the SingleCellSchool container\nGo to a folder where you can safelly download the course materials (to make them visible to the container). you can simply use\ngit clone https://github.com/NBISweden/single-cell_sib_scilifelab\nor\ncd ~/\nsvn export -O https://github.com/NBISweden/single-cell_sib_scilifelab/trunk\nmv trunk SingleCellSchool\ncd SingleCellSchool\nNow that you are setup with docker you can launch/fire the container with all packages from the course from a repository. If you already have a copy on your computer it will launch it, otherwise it will download it from the repositiory first and then launch it. czarnewski/single_cell_school is where the docker image is located.\ndocker run -d --rm -v $(pwd):/home/rstudio --memory=8g -p 8787:8787 -e PASSWORD=test czarnewski/single_cell_school\nIf no errors are thrown, you will be able to connect to your Rstudio machine using a webbrowser, just type the IP.\n\nhttp://192.168.99.100:8787 (this might change, check the output from the command docker-machine env on the step above)\nLOGIN=rstudio\nPASS=test\n\nYou can alternativelly check your docker container IP and replace the (192.168.99.100) above:\ndocker-machine ip\nYour RStudio session should look like this now:\n\n\n\n\n\nYou should have for example the package Seurat installed and also be able to see the files from the course on your home folder. Just by navigating thought there you will be able to open the exercise files (.Rmd extension).\nYou can save your container back to an image at any time by typing into the terminal. To run it again just repeat the docker run step above .\ndocker commit &lt;container_ID&gt; YOURusername/NEWimagename\nYou can stop a container from running with:\ndocker container stop &lt;container_ID&gt;"
  },
  {
    "objectID": "other/docker.html#building-a-docker-image-from-scratch",
    "href": "other/docker.html#building-a-docker-image-from-scratch",
    "title": "Docker",
    "section": "3 Building a Docker image from scratch",
    "text": "3 Building a Docker image from scratch\n\nNow we can download a pre-made docker container containing both the latest version R and RStudio (rocker). Here we need to set a new password for the container, which we can set as “test”. The -p 8787:8787 indicates which ports are visible between your computer and the container for visualizing Rstudio. --rm will remove the container after use. -e sets the password.\n\ndocker run -d --rm --memory=8g -p 8787:8787 -e PASSWORD=test --name rstudio rocker/verse\nIf no errors are thrown, you will be able to connect to your Rstudio machine using a webbrowser, just type the IP.\n\nhttp://192.168.99.100:8787 (this might change, check the output from the command docker-machine env on the step above)\nLOGIN=rstudio\nPASS=test\n\nYou can alternativelly check your IP using:\ndocker-machine ip\n\nYou can now proceed with using Rstudio and installing packages as usual.\n\nSee the precourse material\n\nTo save your container status, you can commit the changes back to a new image using. If you plan on sharing your image, YOURusername/NEWimagename must be a valid Repository on your account on DockerHub (see below).\n\n#Login into your DockerHub account\ndocker login --username=YOURusername --email=youremail@company.com\n\n#Get container ID\ndocker container ls\n\n#Create a commit to save alterations to a new image\ndocker commit &lt;container_ID&gt; YOURusername/NEWimagename\nNow you can access your image container at any time by running.\ndocker run -d -rm -v $(pwd):/home/rstudio --memory=8g -p 8787:8787 -e PASSWORD=test czarnewski/single_cell_school\nIf no errors are thrown, you will be able to connect to your Rstudio machine using a webbrowser, just type the IP.\n\nhttp://192.168.99.100:8787 (this might change, check the output from the command docker-machine env on the step above)\nLOGIN=rstudio\nPASS=test\n\nYou can alternativelly check your docker container IP and replace the (192.168.99.100) above:\ndocker-machine ip"
  },
  {
    "objectID": "other/docker.html#sharing-your-docker-image",
    "href": "other/docker.html#sharing-your-docker-image",
    "title": "Docker",
    "section": "4 Sharing your Docker Image",
    "text": "4 Sharing your Docker Image\n\nCreate a account/repository in your DockerHub.\n\n\nLog in on https://hub.docker.com/\nClick on + Create Repository.\nChoose a name (e.g. NEWimagename) and a description for your repository and click Create.\nYour image name from now on should be called YOURusername/NEWimagename (continue below to see how).\n\nYou can apply a tag as of a version of your container. And then push it to your repository\ndocker tag &lt;container_ID&gt; YOURusername/NEWimagename:latest\ndocker push yourhubusername/gapminder_my_analysis"
  },
  {
    "objectID": "other/docker.html#useful-commands-and-links",
    "href": "other/docker.html#useful-commands-and-links",
    "title": "Docker",
    "section": "5 Useful Commands and links",
    "text": "5 Useful Commands and links\nSome of these commands can be used in\n#get container ip address\ndocker-machine ip\n\n#list or remove docker containers\ndocker container ls\ndocker rm &lt;container_id&gt;\n\n#list or remove docker images\ndocker image ls\ndocker rmi &lt;image_id&gt;\n\n#runs a interactive (-ti) shell inside the container.\n#\"-v\" mounts the current directory \"$(pwd)\" to the folder \"/rstudio\".\n#You can use them separately\ndocker run -it -v $(pwd):/home/rstudio &lt;docker_name&gt;\nUseful Links:\n\nhttps://ropenscilabs.github.io/r-docker-tutorial/\nhttps://rmarkdown.rstudio.com/articles_integration.html\nhttps://github.com/rocker-org/rocker/wiki/How-to-save-data"
  },
  {
    "objectID": "other/uppmax.html",
    "href": "other/uppmax.html",
    "title": "UPPMAX Account Guide",
    "section": "",
    "text": "Caution\n\n\n\nDo these steps well in advance as it can take up to 2 weeks for UPPMAX accounts to be approved. If this is incomplete, you may not be able to follow the labs during the workshop.\nThese are the basic steps in this process:"
  },
  {
    "objectID": "other/uppmax.html#create-an-account-in-supr.",
    "href": "other/uppmax.html#create-an-account-in-supr.",
    "title": "UPPMAX Account Guide",
    "section": "1 ​Create an account in SUPR.",
    "text": "1 ​Create an account in SUPR.\n​If you already have a SUPR account, please continue to step 2.\n​Go to​ https://supr.snic.se/​ and click “Register New Person” at the bottom of the first page. Complete the registration process, preferably using SWAMID, and login. If you for some reason can’t use SWAMID to login, you will have to send physical (not electronic) copy of your ID to a place in Gothenburg for manual approval. Do this as ​soon as possible​, as this process can take ​more than 2 weeks."
  },
  {
    "objectID": "other/uppmax.html#apply-for-membership",
    "href": "other/uppmax.html#apply-for-membership",
    "title": "UPPMAX Account Guide",
    "section": "2 ​Apply for membership",
    "text": "2 ​Apply for membership\n\n​Log in using your SUPR account.\n​Under the “Projects” heading, press the “View and Manage Projects” button.\n​Search for the project ID:\n​Press the “Request” button to apply for membership in the project."
  },
  {
    "objectID": "other/uppmax.html#accept-the-snic-user-agreement",
    "href": "other/uppmax.html#accept-the-snic-user-agreement",
    "title": "UPPMAX Account Guide",
    "section": "3 ​Accept the SNIC User Agreement",
    "text": "3 ​Accept the SNIC User Agreement\n\n​In SUPR, click on the link “Personal Information” in the left sidebar. You will have to accept the SNIC User Agreement to be able to get an UPPMAX account."
  },
  {
    "objectID": "other/uppmax.html#apply-for-an-uppmax-account",
    "href": "other/uppmax.html#apply-for-an-uppmax-account",
    "title": "UPPMAX Account Guide",
    "section": "4 Apply for an UPPMAX account",
    "text": "4 Apply for an UPPMAX account\n\n​In SUPR, click on the link “Accounts” in the left sidebar and apply for an UPPMAX account under the heading “Account Requests”."
  },
  {
    "objectID": "other/uppmax.html#uppmax-account-details",
    "href": "other/uppmax.html#uppmax-account-details",
    "title": "UPPMAX Account Guide",
    "section": "5 UPPMAX account details",
    "text": "5 UPPMAX account details\n\n​Within about 2 working days you should get an email with instructions. ​Please, follow these instructions carefully.\n​A while later you will get an email with your user name, and another email with a link to your password.\n\n\n\n\n\n\n\nCaution\n\n\n\nThe link is only valid for ​1​ ​VISIT or 7 days​, so if you click the link you better save the password, because you will not be able to use the link again. Do this before 7 days have passed, otherwise the link will no longer be valid."
  },
  {
    "objectID": "other/uppmax.html#log-in-with-your-new-uppmax-account",
    "href": "other/uppmax.html#log-in-with-your-new-uppmax-account",
    "title": "UPPMAX Account Guide",
    "section": "6 Log in with your new UPPMAX account",
    "text": "6 Log in with your new UPPMAX account\n\n​Open your terminal program (Terminal in OSX and Linux, otherwise download MobaXterm​ (portable edition) if you have Windows).\n​Type this command in your terminal program: ssh username@rackham.uppmax.uu.se\n​You will be asked for your password now, and you will not see any response in the terminal while typing your password. This is to hide the length of your password, i.e. normal. Just press enter when you have typed it in and you should log in. ​If it is the first time you log in, it will ask you to change your LDAP password (the password you just typed). It will directly ask you for your password again, so type it once more. After that it will ask you for your new password, so make up a new one and press enter. After that it will ask you to confirm the new password. When the password change is completed you will be disconnected and you will have to connect again, using your new password to log in this time."
  },
  {
    "objectID": "other/uppmax.html#create-a-new-file-with-your-username-in-the-designated-folder.",
    "href": "other/uppmax.html#create-a-new-file-with-your-username-in-the-designated-folder.",
    "title": "UPPMAX Account Guide",
    "section": "7 ​Create a new file with your username in the designated folder.",
    "text": "7 ​Create a new file with your username in the designated folder.\n\n​After having received information that your membership is approved, ​wait 24 h before continuing, as it takes up to 24 h for SUPR to sync with UPPMAX. Else, you will get the message “permission denied” if you try to create the file before this sync has been performed.\n\n\n\n\n\nbash\n\ntouch /proj/​naiss2023-22-862/completed/username\n\n\n\n\n​Unless you got some kind of error message you should now be finished. To make sure the file was created you can type\n\n\n\n\n\nbash\n\nls /proj/​naiss2023-22-862/nobackup/username\n\n\n\n\n​It should write out the name of the file if the file exists. ​If you get an error message, please contact us."
  },
  {
    "objectID": "home_contents.html#useful-resources",
    "href": "home_contents.html#useful-resources",
    "title": "Contents",
    "section": "Useful resources",
    "text": "Useful resources\n\nSingle cell RNA-seq course at from Hemberg lab \nSingle cell RNA-seq course in Python \nSingle cell RNA-seq course at Broad \nRepository listing many scRNA-seq tools \nSingleCellExperiment objects for many datasets \nConquer datasets - many different datasets based on a salmon pipeline \nThe Human Cell Atlas project \nThe github repository for this course \nBitbucket repository for QC report scripts \nBitbucket repository for the NBIS scRNAseq pipeline"
  },
  {
    "objectID": "home_precourse.html#faq",
    "href": "home_precourse.html#faq",
    "title": "Precourse",
    "section": "7 FAQ",
    "text": "7 FAQ\nPlease refer to the FAQ for troubleshooting common issues."
  },
  {
    "objectID": "other/conda.html",
    "href": "other/conda.html",
    "title": "Conda",
    "section": "",
    "text": "In this workshop you can use conda environments to run the exercises. This is because conda environments allow all users to have the same computing environment, i.e. package versions. This enforces reproducibility for you to run this material without the need to install or change your local versions. See and graphical example below:\nConda environments are a self-contained directory that you can use in order to reproduce all your results.\nBriefly, you need to:\nYou can read more about Conda environments and other important concepts to help you make your research reproducible."
  },
  {
    "objectID": "other/conda.html#download-and-install-conda-and-mamba",
    "href": "other/conda.html#download-and-install-conda-and-mamba",
    "title": "Conda",
    "section": "1 Download and install Conda and Mamba",
    "text": "1 Download and install Conda and Mamba\nStart by installing Conda. We suggest installing Miniconda3 and NOT Anaconda. After installing Conda.\n\n Mac OSX Ubuntu Windows 10 VirtualBox\n\n\nFirst, make sure you have Xcode and CommandLineTools installed and updated to latest version (in AppStore). If you have not already installed CommadLineTools, go to a terminal window and run:\nxcode-select --install\n\n\n\n\n\n\nCaution\n\n\n\nIf you are on an M1 (Silicon) Mac computer you will have to use a Rosetta2 enabled terminal and install the x86_64 miniconda3 version. All R packages are not yet available as conda packages for the arm64 architecture.\n\n\nJust right-click on the icon for the terminal app in a Finder window and click “Get Info”. There you have a selection box: “Open using Rosetta” that you need to tick before opening the application. Then you can install the x86_64 miniconda3 following instructions below.\nFirst download the latest version of Miniconda3 and run it to install.\ncurl -o Miniconda3-latest-MacOSX-x86_64.sh https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh\nsh Miniconda3-latest-MacOSX-x86_64.sh\nFollow the instructions on screen, scrolling down, pressing ENTER and replying yes when necessary. Install it in the default directory. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\nconda init\nconda install -n base -c conda-forge mamba\n\n\nFirst download the latest version of Miniconda3 and run it to install.\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\nsh Miniconda3-latest-Linux-x86_64.sh\nFollow the instructions on screen replying yes when necessary. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\nconda init\nconda install -n base -c conda-forge mamba\n\n\nUnfortunately, not all packages available on conda are compatible with windows machines. The good news is that Windows 10 offers native linux support via the Windows Subsystem for Linux (WSL2). This allows you to run linux/bash commands from within windows without the need of a virtual machine nor a dual-boot setup (i.e. having 2 operating systems). However, WSL does not offer a complete support for graphical interfaces (such as RStudio in our case), so we need additional steps to make that happen.\n\nOn Windows 10, install the WSL if you don’t have it. Follow the instructions here: https://docs.microsoft.com/en-us/windows/wsl/install-win10\nOnce you have that installed, you can download and install MobaXterm (which is the enhanced terminal with graphical capacity): https://mobaxterm.mobatek.net\nIt is recommended that you INSTALL the program and not use the portable version.\nInside MobaXterm, you will probably will see that your WSL is already listed on the left panel as an available connection. Just double-click it and you will be accessing it via MobaXterm. If by any chance you don’t see it there, close MobaXterm and go to the WSL terminal, because probably the WSL is not allowing SSH connections. You can follow this link for the instructions on how to do it. You need to complete until the step Start or restart the SSH service, while the further steps are optional, but might be useful.\nInside MobaXterm, download Conda with the command:\n\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nInside MobaXterm, type the commands below to install Conda. Follow the instructions for the installation there.\n\ncd ~/Downloads\nsh Miniconda3-latest-Linux-x86_64.sh\n\nInside MobaXterm, Follow the instructions on screen replying yes when necessary. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\n\nconda init\nconda install -n base -c conda-forge mamba\n\nInside MobaXterm, type the commands below to install the X-server graphical packages that will be used to launch RStudio. https://docs.anaconda.com/anaconda/install/linux/\n\nsudo apt-get update\nsudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6\n\nClose and open all application and Inside MobaXterm, you will probably will see that your WSL is already listed on the left panel as an available connection. Just double-click it and you will be accessing it via MobaXterm.\n\n\n\nIf by any means you see that the installations are not working as it should on your computer, you can try to create a virtual machine to run UBUNTU and install everything there. But please keep this alternative as the last temporary resourse, as we recommend troubleshooting the installation o the up-mentioned methods.\n\nDownload and install on your machine VIRTUALBOX https://www.virtualbox.org\nDownload the ISO disk of UBUNTU https://ubuntu.com/download/desktop\nOn VIRTUALBOX, click on Settings (yellow engine) &gt; General &gt; Advanced and make sure that both settings Shared Clipboard and Drag’n’Drop are set to Bidirectional.\nCompletely close VIRTUALBOX and start it again to apply changes.\nOn VIRTUALBOX, create a machine called Ubuntu and add the image above\n\n\nset the memory to the maximum allowed in the GREEN bar\nset the hard disk to be dynamic allocated\nall other things can be default\n\n\nProceed with the Ubuntu installation as recommended. You can set to do “Minimal Installation” and deactivate to get updates during installation.\nInside Ubuntu, open TERMINAL and type the commands below to install the X-server graphical packages that will be used to launch RStudio. https://docs.anaconda.com/anaconda/install/linux/\n\nsudo apt-get update\nsudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6\n\nInside UBUNTU, Download conda:\n\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nInside UBUNTU, open the TERMINAL and type the commands below. Follow the instructions for the installation there.\n\ncd ~/Downloads\nsh Miniconda3-latest-Linux-x86_64.sh\n\nClose Terminal to apply the CONDA updates. Then you can create a course folder, download the environment file and create the environment:\n\nmkdir ~/Desktop/course\ncd ~/Desktop/course\nwget https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/other/conda.yml\nconda env create -f conda.yml\n\nYou can then follow the instructions above to activate/deactivate the environment.\n\nconda activate workshop-scrnaseq"
  },
  {
    "objectID": "other/conda.html#create-a-conda-environment-from-file",
    "href": "other/conda.html#create-a-conda-environment-from-file",
    "title": "Conda",
    "section": "2 Create a conda environment from file",
    "text": "2 Create a conda environment from file\nDownload the conda.yml file:\nconda.yml \nSave it anywhere. The location does not matter. Then, type this in the folder with that file:\nmamba env create -n workshop-scrnaseq -f conda.yml\nSeveral messages will show up on your screen and will tell you about the installation process. This may take a few minutes depending on how many packages are to be installed.\n##Collecting package metadata: done\n##Solving environment: done\n##\n##Downloading and Extracting Packages\n##libcblas-3.8.0       | 6 KB      | ############################################################################# | 100%\n##liblapack-3.8.0      | 6 KB      | ############################################################################# | 100%\n##...\n##Preparing transaction: done\n##Verifying transaction: done\n##Executing transaction: done"
  },
  {
    "objectID": "other/conda.html#activate-the-environment",
    "href": "other/conda.html#activate-the-environment",
    "title": "Conda",
    "section": "3 Activate the environment",
    "text": "3 Activate the environment\nOnce the environment is created, we need to activate it in order to use the softwares and packages inside it. To activate an environment type:\nconda activate workshop-scrnaseq\nFrom this point on you can run any of the contents from the workshop."
  },
  {
    "objectID": "other/conda.html#deactivate-the-environment",
    "href": "other/conda.html#deactivate-the-environment",
    "title": "Conda",
    "section": "4 Deactivate the environment",
    "text": "4 Deactivate the environment\nAfter you’ve ran all your analyses, you can deactivate the environment by typing:\nconda deactivate"
  },
  {
    "objectID": "other/conda.html#fa-brands-ubuntu-ubuntu",
    "href": "other/conda.html#fa-brands-ubuntu-ubuntu",
    "title": "Conda",
    "section": "2  Ubuntu",
    "text": "2  Ubuntu\nFirst download the latest version of Miniconda3 and run it to install.\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\nsh Miniconda3-latest-Linux-x86_64.sh\nFollow the instructions on screen replying yes when necessary. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\nconda init\nconda install -n base -c conda-forge mamba"
  },
  {
    "objectID": "other/conda.html#fa-brands-windows-windows-10",
    "href": "other/conda.html#fa-brands-windows-windows-10",
    "title": "Conda",
    "section": "3  Windows 10",
    "text": "3  Windows 10\nUnfortunately, not all packages available on conda are compatible with windows machines. The good news is that Windows 10 offers native linux support via the Windows Subsystem for Linux (WSL2). This allows you to run linux/bash commands from within windows without the need of a virtual machine nor a dual-boot setup (i.e. having 2 operating systems). However, WSL does not offer a complete support for graphical interfaces (such as RStudio in our case), so we need additional steps to make that happen.\n\nOn Windows 10, install the WSL if you don’t have it. Follow the instructions here: https://docs.microsoft.com/en-us/windows/wsl/install-win10\nOnce you have that installed, you can download and install MobaXterm (which is the enhanced terminal with graphical capacity): https://mobaxterm.mobatek.net\nIt is recommended that you INSTALL the program and not use the portable version.\nInside MobaXterm, you will probably will see that your WSL is already listed on the left panel as an available connection. Just double-click it and you will be accessing it via MobaXterm. If by any chance you don’t see it there, close MobaXterm and go to the WSL terminal, because probably the WSL is not allowing SSH connections. You can follow this link for the instructions on how to do it. You need to complete until the step Start or restart the SSH service, while the further steps are optional, but might be useful.\nInside MobaXterm, download Conda with the command:\n\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nInside MobaXterm, type the commands below to install Conda. Follow the instructions for the installation there.\n\ncd ~/Downloads\nsh Miniconda3-latest-Linux-x86_64.sh\n\nInside MobaXterm, Follow the instructions on screen replying yes when necessary. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\n\nconda init\nconda install -n base -c conda-forge mamba\n\nInside MobaXterm, type the commands below to install the X-server graphical packages that will be used to launch RStudio. https://docs.anaconda.com/anaconda/install/linux/\n\nsudo apt-get update\nsudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6\n\nClose and open all application and Inside MobaXterm, you will probably will see that your WSL is already listed on the left panel as an available connection. Just double-click it and you will be accessing it via MobaXterm."
  },
  {
    "objectID": "other/conda.html#fa-solid-box-virtualbox",
    "href": "other/conda.html#fa-solid-box-virtualbox",
    "title": "Conda",
    "section": "4  VirtualBox",
    "text": "4  VirtualBox\nIf by any means you see that the installations are not working as it should on your computer, you can try to create a virtual machine to run UBUNTU and install everything there. But please keep this alternative as the last temporary resourse, as we recommend troubleshooting the installation o the up-mentioned methods.\n\nDownload and install on your machine VIRTUALBOX https://www.virtualbox.org\nDownload the ISO disk of UBUNTU https://ubuntu.com/download/desktop\nOn VIRTUALBOX, click on Settings (yellow engine) &gt; General &gt; Advanced and make sure that both settings Shared Clipboard and Drag’n’Drop are set to Bidirectional.\nCompletely close VIRTUALBOX and start it again to apply changes.\nOn VIRTUALBOX, create a machine called Ubuntu and add the image above\n\n\nset the memory to the maximum allowed in the GREEN bar\nset the hard disk to be dynamic allocated\nall other things can be default\n\n\nProceed with the Ubuntu installation as recommended. You can set to do “Minimal Installation” and deactivate to get updates during installation.\nInside Ubuntu, open TERMINAL and type the commands below to install the X-server graphical packages that will be used to launch RStudio. https://docs.anaconda.com/anaconda/install/linux/\n\nsudo apt-get update\nsudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6\n\nInside UBUNTU, Download conda:\n\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nInside UBUNTU, open the TERMINAL and type the commands below. Follow the instructions for the installation there.\n\ncd ~/Downloads\nsh Miniconda3-latest-Linux-x86_64.sh\n\nClose Terminal to apply the CONDA updates. Then you can create a course folder, download the environment file and create the environment:\n\nmkdir ~/Desktop/course\ncd ~/Desktop/course\nwget https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/other/conda.yml\nconda env create -f conda.yml\n\nYou can then follow the instructions above to activate/deactivate the environment.\n\nconda activate workshop-scrnaseq\nrstudio &"
  },
  {
    "objectID": "other/conda.html#install-conda-and-mamba",
    "href": "other/conda.html#install-conda-and-mamba",
    "title": "Conda",
    "section": "1 Install Conda and Mamba",
    "text": "1 Install Conda and Mamba\nWe suggest installing Miniconda3/Miniforge and NOT Anaconda.\n\n Mac OSX Ubuntu Windows 10 VirtualBox\n\n\nFirst, make sure you have Xcode and CommandLineTools installed and updated to latest version (in AppStore). If you have not already installed CommadLineTools, go to a terminal window and run:\nxcode-select --install\n\n\n\n\n\n\nCaution\n\n\n\nIf you are on an M1 (Silicon) Mac computer you will have to use a Rosetta2 enabled terminal and install the x86_64 miniconda3 version. All R packages are not yet available as conda packages for the arm64 architecture.\n\n\nJust right-click on the icon for the terminal app in a Finder window and click “Get Info”. There you have a selection box: “Open using Rosetta” that you need to tick before opening the application. Then you can install the x86_64 miniconda3 following instructions below.\nFirst download the latest version of Miniconda3 and run it to install.\ncurl -o Miniconda3-latest-MacOSX-x86_64.sh https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh\nsh Miniconda3-latest-MacOSX-x86_64.sh\nFollow the instructions on screen, scrolling down, pressing ENTER and replying yes when necessary. Install it in the default directory. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\nconda init\nconda install -n base -c conda-forge mamba\n\n\nFirst download the latest version of Miniconda3 and run it to install.\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\nsh Miniconda3-latest-Linux-x86_64.sh\nFollow the instructions on screen replying yes when necessary. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\nconda init\nconda install -n base -c conda-forge mamba\n\n\nUnfortunately, not all packages available on conda are compatible with windows machines. The good news is that Windows 10 offers native linux support via the Windows Subsystem for Linux (WSL2). This allows you to run linux/bash commands from within windows without the need of a virtual machine nor a dual-boot setup (i.e. having 2 operating systems). However, WSL does not offer a complete support for graphical interfaces (such as RStudio in our case), so we need additional steps to make that happen.\n\nOn Windows 10, install the WSL if you don’t have it. Follow the instructions here: https://docs.microsoft.com/en-us/windows/wsl/install-win10\nOnce you have that installed, you can download and install MobaXterm (which is the enhanced terminal with graphical capacity): https://mobaxterm.mobatek.net\nIt is recommended that you INSTALL the program and not use the portable version.\nInside MobaXterm, you will probably will see that your WSL is already listed on the left panel as an available connection. Just double-click it and you will be accessing it via MobaXterm. If by any chance you don’t see it there, close MobaXterm and go to the WSL terminal, because probably the WSL is not allowing SSH connections. You can follow this link for the instructions on how to do it. You need to complete until the step Start or restart the SSH service, while the further steps are optional, but might be useful.\nInside MobaXterm, download Conda with the command:\n\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nInside MobaXterm, type the commands below to install Conda. Follow the instructions for the installation there.\n\ncd ~/Downloads\nsh Miniconda3-latest-Linux-x86_64.sh\n\nInside MobaXterm, Follow the instructions on screen replying yes when necessary. Restart your terminal window to apply modifications. After restarting, you can type the command below to install Mamba:\n\nconda init\nconda install -n base -c conda-forge mamba\n\nInside MobaXterm, type the commands below to install the X-server graphical packages that will be used to launch RStudio. https://docs.anaconda.com/anaconda/install/linux/\n\nsudo apt-get update\nsudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6\n\nClose and open all application and Inside MobaXterm, you will probably will see that your WSL is already listed on the left panel as an available connection. Just double-click it and you will be accessing it via MobaXterm.\n\n\n\nIf by any means you see that the installations are not working as it should on your computer, you can try to create a virtual machine to run UBUNTU and install everything there. But please keep this alternative as the last temporary resourse, as we recommend troubleshooting the installation o the up-mentioned methods.\n\nDownload and install on your machine VIRTUALBOX https://www.virtualbox.org\nDownload the ISO disk of UBUNTU https://ubuntu.com/download/desktop\nOn VIRTUALBOX, click on Settings (yellow engine) &gt; General &gt; Advanced and make sure that both settings Shared Clipboard and Drag’n’Drop are set to Bidirectional.\nCompletely close VIRTUALBOX and start it again to apply changes.\nOn VIRTUALBOX, create a machine called Ubuntu and add the image above\n\n\nset the memory to the maximum allowed in the GREEN bar\nset the hard disk to be dynamic allocated\nall other things can be default\n\n\nProceed with the Ubuntu installation as recommended. You can set to do “Minimal Installation” and deactivate to get updates during installation.\nInside Ubuntu, open TERMINAL and type the commands below to install the X-server graphical packages that will be used to launch RStudio. https://docs.anaconda.com/anaconda/install/linux/\n\nsudo apt-get update\nsudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6\n\nInside UBUNTU, Download conda:\n\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nInside UBUNTU, open the TERMINAL and type the commands below. Follow the instructions for the installation there.\n\ncd ~/Downloads\nsh Miniconda3-latest-Linux-x86_64.sh\n\nClose Terminal to apply the CONDA updates. Then you can create a course folder, download the environment file and create the environment:\n\nmkdir ~/Desktop/course\ncd ~/Desktop/course\nwget https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/other/conda.yml\nconda env create -f conda.yml\n\nYou can then follow the instructions above to activate/deactivate the environment.\n\nconda activate workshop-scrnaseq"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html",
    "href": "labs/seurat/seurat_01_qc.html",
    "title": " Quality Control",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified."
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_data",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_data",
    "title": " Quality Control",
    "section": "1 Get data",
    "text": "1 Get data\nIn this tutorial, we will run all tutorials with a set of 6 PBMC 10x datasets from 3 covid-19 patients and 3 healthy controls, the samples have been subsampled to 1500 cells per sample. They are part of the github repo and if you have cloned the repo they should be available in folder: labs/data/covid_data_GSE149689. Instructions on how to download them can also be found in the Precourse material.\n\nwebpath &lt;- \"https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/\"\n\nif(!dir.exists(\"./data/raw\")){\n  dir.create(\"./data/raw\", recursive = T)\n  file_list &lt;- c(\n      \"Normal_PBMC_13.h5\", \"Normal_PBMC_14.h5\", \"Normal_PBMC_5.h5\",\n      \"nCoV_PBMC_15.h5\", \"nCoV_PBMC_17.h5\", \"nCoV_PBMC_1.h5\"\n  )\n  for (i in file_list) {\n      download.file(\n          url = paste0(webpath, i),\n          destfile = paste0(\"./data/raw/\", i)\n      )\n  }\n}\n\nWith data in place, now we can start loading libraries we will use in this tutorial.\n\nsuppressMessages(require(Seurat))\nsuppressMessages(require(Matrix))\nif(!\"DoubletFinder\" %in% rownames(installed.packages())){\n   remotes::install_github('chris-mcginnis-ucsf/DoubletFinder',upgrade = FALSE, dependencies=TRUE)\n}\nsuppressMessages(require(DoubletFinder))\n\nWe can first load the data individually by reading directly from HDF5 file format (.h5).\n\ncov.15 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_15.h5\",\n  use.names = T)\ncov.1 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_1.h5\",\n  use.names = T)\ncov.17 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_17.h5\",\n  use.names = T)\n\nctrl.5 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_5.h5\",\n  use.names = T)\nctrl.13 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_13.h5\",\n  use.names = T)\nctrl.14 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_14.h5\",\n  use.names = T)"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_collate",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_collate",
    "title": " Quality Control",
    "section": "2 Collate",
    "text": "2 Collate\nWe can now load the expression matrices and merge them into a single object. Each analysis workflow (Seurat, Scater, Scanpy, etc) has its own way of storing data. We will add dataset labels as cell.ids just in case you have overlapping barcodes between the datasets. After that we add a column Chemistry in the metadata for plotting later on.\n\nsdata.cov15 &lt;- CreateSeuratObject(cov.15,  project = \"covid_15\")\nsdata.cov1 &lt;- CreateSeuratObject(cov.1,  project = \"covid_1\")\nsdata.cov17 &lt;- CreateSeuratObject(cov.17,  project = \"covid_17\")\nsdata.ctrl5 &lt;- CreateSeuratObject(ctrl.5,  project = \"ctrl_5\")\nsdata.ctrl13 &lt;- CreateSeuratObject(ctrl.13,  project = \"ctrl_13\")\nsdata.ctrl14 &lt;- CreateSeuratObject(ctrl.14,  project = \"ctrl_14\")\n\n# add metadata\nsdata.cov1$type = \"Covid\"\nsdata.cov15$type = \"Covid\"\nsdata.cov17$type = \"Covid\"\nsdata.ctrl5$type = \"Ctrl\"\nsdata.ctrl13$type = \"Ctrl\"\nsdata.ctrl14$type = \"Ctrl\"\n\n# Merge datasets into one single seurat object\nalldata &lt;- merge(sdata.cov15, c(sdata.cov1, sdata.cov17, sdata.ctrl5, sdata.ctrl13, sdata.ctrl14), add.cell.ids=c(\"covid_15\",\"covid_1\",\"covid_17\",\"ctrl_5\",\"ctrl_13\", \"ctrl_14\"))\n\nOnce you have created the merged Seurat object, the count matrices and individual count matrices and objects are not needed anymore. It is a good idea to remove them and run garbage collect to free up some memory.\n\n# remove all objects that will not be used.\nrm(cov.15, cov.1, cov.17, ctrl.5, ctrl.13, ctrl.14, sdata.cov15, sdata.cov1, sdata.cov17, sdata.ctrl5, sdata.ctrl13, sdata.ctrl14)\n# run garbage collect to free up memory\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  3320868 177.4    5034282 268.9   5034282 268.9\nVcells 44666817 340.8  111637329 851.8 102353092 780.9\n\n\nHere is how the count matrix and the metadata look like for every cell.\n\nas.data.frame(alldata@assays$RNA@counts[1:10,1:2])\nhead(alldata@meta.data,10)\n\n\n\n\n\n\n\n\n\n\n\ncovid_15_CTCCATGTCAACGTGT-15\ncovid_15_CATAAGCAGGAACGAA-15\n\n\n\n\nMIR1302-2HG\n0\n0\n\n\nFAM138A\n0\n0\n\n\nOR4F5\n0\n0\n\n\nAL627309.1\n0\n0\n\n\nAL627309.3\n0\n0\n\n\nAL627309.2\n0\n0\n\n\nAL627309.4\n0\n0\n\n\nAL732372.1\n0\n0\n\n\nOR4F29\n0\n0\n\n\nAC114498.1\n0\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\norig.ident\nnCount_RNA\nnFeature_RNA\ntype\n\n\n\n\ncovid_15_CTCCATGTCAACGTGT-15\ncovid_15\n14911\n3526\nCovid\n\n\ncovid_15_CATAAGCAGGAACGAA-15\ncovid_15\n338\n203\nCovid\n\n\ncovid_15_TTCACCGTCAGGAAGC-15\ncovid_15\n28486\n4542\nCovid\n\n\ncovid_15_CGTCCATGTCCGGACT-15\ncovid_15\n1318\n539\nCovid\n\n\ncovid_15_GTCCACTAGTCGCCCA-15\ncovid_15\n4805\n1493\nCovid\n\n\ncovid_15_ATCCATTGTTGATGTC-15\ncovid_15\n5386\n1617\nCovid\n\n\ncovid_15_AGAAGCGAGGGCCTCT-15\ncovid_15\n686\n407\nCovid\n\n\ncovid_15_GAGGGTAGTAGGTTTC-15\ncovid_15\n2155\n1116\nCovid\n\n\ncovid_15_CAAGACTTCTGCTTTA-15\ncovid_15\n1216\n128\nCovid\n\n\ncovid_15_GCCAACGAGCTCTATG-15\ncovid_15\n729\n356\nCovid"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_calqc",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_calqc",
    "title": " Quality Control",
    "section": "3 Calculate QC",
    "text": "3 Calculate QC\nHaving the data in a suitable format, we can start calculating some quality metrics. We can for example calculate the percentage of mitochondrial and ribosomal genes per cell and add to the metadata. The proportion hemoglobin genes can give an indication of red blood cell contamination. This will be helpful to visualize them across different metadata parameteres (i.e. datasetID and chemistry version). There are several ways of doing this. The QC metrics are finally added to the metadata table.\nCiting from Simple Single Cell workflows (Lun, McCarthy & Marioni, 2017): High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmic RNA from perforated cells. The reasoning is that mitochondria are larger than individual transcript molecules and less likely to escape through tears in the cell membrane.\n\n# method 1: doing it using Seurat function\nalldata &lt;- PercentageFeatureSet(alldata, \"^MT-\", col.name = \"percent_mito\")\n\n# method 2: doing it manually\ntotal_counts_per_cell &lt;- colSums(alldata@assays$RNA@counts)\nmito_genes &lt;- rownames(alldata)[grep(\"^MT-\",rownames(alldata))]\nalldata$percent_mito &lt;- colSums(alldata@assays$RNA@counts[mito_genes,]) / total_counts_per_cell\nhead(mito_genes,10)\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\" \n\n\n\n# method 1: doing it using Seurat function\nalldata &lt;- PercentageFeatureSet(alldata, \"^RP[SL]\", col.name = \"percent_ribo\")\n# Percentage hemoglobin genes - includes all genes starting with HB except HBP.\nalldata &lt;- PercentageFeatureSet(alldata, \"^HB[^(P)]\", col.name = \"percent_hb\")\nalldata &lt;- PercentageFeatureSet(alldata, \"PECAM1|PF4\", col.name = \"percent_plat\")\n\n# method 2: doing it manually\nribo_genes &lt;- rownames(alldata)[grep(\"^RP[SL]\",rownames(alldata))]\nhead(ribo_genes,10)\nalldata$percent_ribo &lt;- colSums(alldata@assays$RNA@counts[ribo_genes,]) / total_counts_per_cell\n\n [1] \"RPL22\"   \"RPL11\"   \"RPS6KA1\" \"RPS8\"    \"RPL5\"    \"RPS27\"   \"RPS6KC1\"\n [8] \"RPS7\"    \"RPS27A\"  \"RPL31\"  \n\n\nNow you can see that we have additional data in the metadata slot.\n\nhead(alldata[[]])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\norig.ident\nnCount_RNA\nnFeature_RNA\ntype\npercent_mito\npercent_ribo\npercent_hb\npercent_plat\n\n\n\n\ncovid_15_CTCCATGTCAACGTGT-15\ncovid_15\n14911\n3526\nCovid\n0.1097177\n0.1006639\n0.0134129\n0.0469452\n\n\ncovid_15_CATAAGCAGGAACGAA-15\ncovid_15\n338\n203\nCovid\n0.0532544\n0.0325444\n0.0000000\n0.0000000\n\n\ncovid_15_TTCACCGTCAGGAAGC-15\ncovid_15\n28486\n4542\nCovid\n0.0559924\n0.1379976\n0.0070210\n0.0351050\n\n\ncovid_15_CGTCCATGTCCGGACT-15\ncovid_15\n1318\n539\nCovid\n0.1267071\n0.3399090\n0.0000000\n0.0758725\n\n\ncovid_15_GTCCACTAGTCGCCCA-15\ncovid_15\n4805\n1493\nCovid\n0.0713840\n0.3552549\n0.0000000\n0.0000000\n\n\ncovid_15_ATCCATTGTTGATGTC-15\ncovid_15\n5386\n1617\nCovid\n0.0428890\n0.1164129\n0.0000000\n0.0557000"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_plotqc",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_plotqc",
    "title": " Quality Control",
    "section": "4 Plot QC",
    "text": "4 Plot QC\nNow we can plot some of the QC variables as violin plots.\n\nfeats &lt;- c(\"nFeature_RNA\",\"nCount_RNA\",\"percent_mito\",\"percent_ribo\", \"percent_hb\")\nVlnPlot(alldata, group.by= \"orig.ident\", features = feats, pt.size = 0.1,ncol = 3) + NoLegend()\n\n\n\n\n\n\n\n\nAs you can see, there is quite some difference in quality for the 4 datasets, with for instance the covid_15 sample having fewer cells with many detected genes and more mitochondrial content. As the ribosomal proteins are highly expressed they will make up a larger proportion of the transcriptional landscape when fewer of the lowly expressed genes are detected. And we can plot the different QC-measures as scatter plots.\n\nFeatureScatter(alldata, \"nCount_RNA\"  , \"nFeature_RNA\", group.by = \"orig.ident\", pt.size = .5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nPlot additional QC stats that we have calculated as scatter plots. How are the different measures correlated? Can you explain why?"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_filter",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_filter",
    "title": " Quality Control",
    "section": "5 Filtering",
    "text": "5 Filtering\n\n5.1 Detection-based filtering\nA standard approach is to filter cells with low amount of reads as well as genes that are present in at least a certain amount of cells. Here we will only consider cells with at least 200 detected genes and genes need to be expressed in at least 3 cells. Please note that those values are highly dependent on the library preparation method used.\n\nselected_c &lt;- WhichCells(alldata, expression = nFeature_RNA &gt; 200)\nselected_f &lt;- rownames(alldata)[ Matrix::rowSums(alldata) &gt; 3]\n\ndata.filt &lt;- subset(alldata, features=selected_f, cells=selected_c)\ndim(data.filt)\n\n[1] 18147  7973\n\n\nExtremely high number of detected genes could indicate doublets. However, depending on the cell type composition in your sample, you may have cells with higher number of genes (and also higher counts) from one cell type. In this case, we will run doublet prediction further down, so we will skip this step now, but the code below is an example of how it can be run:\n\n# skip for now and run DoubletFinder first!\n\n#high.det.v3 &lt;- WhichCells(data.filt, expression = nFeature_RNA &gt; 4100)\n#high.det.v2 &lt;- WhichCells(data.filt, expression = nFeature_RNA &gt; 2000 & orig.ident == \"v2.1k\")\n\n# remove these cells\n#data.filt &lt;- subset(data.filt, cells=setdiff(WhichCells(data.filt),c(high.det.v2,high.det.v3)))\n\n# check number of cells\nncol(data.filt)\n\n[1] 7973\n\n\nAdditionally, we can also see which genes contribute the most to such reads. We can for instance plot the percentage of counts per gene.\n\n# Compute the relative expression of each gene per cell\n# Use sparse matrix operations, if your dataset is large, doing matrix devisions the regular way will take a very long time.\n# par(mar=c(4,8,2,1))\nC &lt;- data.filt@assays$RNA@counts\nC &lt;-  Matrix::t(Matrix::t(C) / Matrix::colSums(C)) * 100\nmost_expressed &lt;- order(apply(C,1,median),decreasing = T)[20:1]\nboxplot(as.matrix(t(C[most_expressed,])),cex=.1, las=1, xlab=\"% total count per cell\",col=scales::hue_pal()(20)[20:1],horizontal=TRUE)\n\n\n\n\n\n\n\n\nAs you can see, MALAT1 constitutes up to 30% of the UMIs from a single cell and the other top genes are mitochondrial and ribosomal genes. It is quite common that nuclear lincRNAs have correlation with quality and mitochondrial reads, so high detection of MALAT1 may be a technical issue. Let us assemble some information about such genes, which are important for quality control and downstream filtering.\n\n\n5.2 Mito/Ribo filtering\nWe also have quite a lot of cells with high proportion of mitochondrial and low proportion of ribosomal reads. It could be wise to remove those cells, if we have enough cells left after filtering. Another option would be to either remove all mitochondrial reads from the dataset and hope that the remaining genes still have enough biological signal. A third option would be to just regress out the percent_mito variable during scaling. In this case we had as much as 99.7% mitochondrial reads in some of the cells, so it is quite unlikely that there is much cell type signature left in those. Looking at the plots, make reasonable decisions on where to draw the cutoff. In this case, the bulk of the cells are below 20% mitochondrial reads and that will be used as a cutoff. We will also remove cells with less than 5% ribosomal reads.\n\nselected_mito &lt;- WhichCells(data.filt, expression = percent_mito &lt; 0.20)\nselected_ribo &lt;- WhichCells(data.filt, expression = percent_ribo &gt; 0.05)\n\n# and subset the object to only keep those cells\ndata.filt &lt;- subset(data.filt, cells = selected_mito)\ndata.filt &lt;- subset(data.filt, cells = selected_ribo)\ndim(data.filt)\ntable(data.filt$orig.ident)\n\n[1] 18147  5762\n\n covid_1 covid_15 covid_17  ctrl_13  ctrl_14   ctrl_5 \n     878      585     1042     1154     1063     1040 \n\n\nAs you can see, a large proportion of sample covid_15 is filtered out. Also, there is still quite a lot of variation in percent_mito, so it will have to be dealt with in the data analysis step. We can also notice that the percent_ribo are also highly variable, but that is expected since different cell types have different proportions of ribosomal content, according to their function.\n\n\n5.3 Plot filtered QC\nLets plot the same QC-stats another time.\n\nfeats &lt;- c(\"nFeature_RNA\",\"nCount_RNA\",\"percent_mito\",\"percent_ribo\", \"percent_hb\")\nVlnPlot(data.filt, group.by= \"orig.ident\", features = feats, pt.size = 0.1,ncol = 3) + NoLegend()\n\n\n\n\n\n\n\n\n\n\n5.4 Filter genes\nAs the level of expression of mitochondrial and MALAT1 genes are judged as mainly technical, it can be wise to remove them from the dataset before any further analysis.\n\ndim(data.filt)\n\n# Filter MALAT1\ndata.filt &lt;- data.filt[ ! grepl(\"MALAT1\", rownames(data.filt)), ]\n\n# Filter Mitocondrial\ndata.filt &lt;- data.filt[ ! grepl(\"^MT-\", rownames(data.filt)), ]\n\n# Filter Ribossomal gene (optional if that is a problem on your data)\n# data.filt &lt;- data.filt[ ! grepl(\"^RP[SL]\", rownames(data.filt)), ]\n\n# Filter Hemoglobin gene (optional if that is a problem on your data)\ndata.filt &lt;- data.filt[ ! grepl(\"^HB[^(P)]\", rownames(data.filt)), ]\n\ndim(data.filt)\n\n[1] 18147  5762\n[1] 18121  5762"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_sex",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_sex",
    "title": " Quality Control",
    "section": "6 Sample sex",
    "text": "6 Sample sex\nWhen working with human or animal samples, you should ideally constrain you experiments to a single sex to avoid including sex bias in the conclusions. However this may not always be possible. By looking at reads from chromosomeY (males) and XIST (X-inactive specific transcript) expression (mainly female) it is quite easy to determine per sample which sex it is. It can also bee a good way to detect if there has been any sample mixups, if the sample metadata sex does not agree with the computational predictions.\nTo get chromosome information for all genes, you should ideally parse the information from the gtf file that you used in the mapping pipeline as it has the exact same annotation version/gene naming. However, it may not always be available, as in this case where we have downloaded public data. Hence, we will use biomart to fetch chromosome information. As the biomart instances quite often are unresponsive, you can try the code below, but if it fails, we have the file with gene annotations on github here. Make sure you put it at the correct location for the path genes.file to work.\n\ngenes.file = \"data/results/genes.table.csv\"\n\nif (!file.exists(genes.file)){\n  suppressMessages(require(biomaRt))\n\n  # initialize connection to mart, may take some time if the sites are unresponsive.\n  mart &lt;- useMart(\"ENSEMBL_MART_ENSEMBL\", dataset=\"hsapiens_gene_ensembl\")\n\n  # fetch chromosome info plus some other annotations\n  genes.table &lt;- try(biomaRt::getBM(attributes = c(\"ensembl_gene_id\",\n              \"external_gene_name\", \"description\",\"gene_biotype\", \"chromosome_name\",\"start_position\"),\n              mart = mart, useCache = F))\n  \n  if(!dir.exists(\"data/results\")){dir.create(\"data/results\")}\n  if(is.data.frame(genes.table)){write.csv(genes.table, file = genes.file)}\n  \n  if (!file.exists(genes.file)){\n  download.file(\"https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/labs/misc/genes.table.csv\",destfile = \"data/results/genes.table.csv\")\n    genes.table = read.csv(genes.file)\n    }\n\n} else {\n  genes.table = read.csv(genes.file)\n}\n\ngenes.table &lt;- genes.table[genes.table$external_gene_name %in% rownames(data.filt),]\n\nNow that we have the chromosome information, we can calculate per cell the proportion of reads that comes from chromosome Y.\n\nchrY.gene = genes.table$external_gene_name[genes.table$chromosome_name == \"Y\"]\ndata.filt$pct_chrY = colSums(data.filt@assays$RNA@counts[chrY.gene,]) / colSums(data.filt@assays$RNA@counts)\n\nThen plot XIST expression vs chrY proportion. As you can see, the samples are clearly on either side, even if some cells do not have detection of either.\n\nFeatureScatter(data.filt, feature1 = \"XIST\", feature2 = \"pct_chrY\")\n\n\n\n\n\n\n\n\nPlot as violins.\n\nVlnPlot(data.filt, features = c(\"XIST\", \"pct_chrY\"))\n\n\n\n\n\n\n\n\nHere, we can see clearly that we have two males and 4 females, can you see which samples they are? Do you think this will cause any problems for downstream analysis? Discuss with your group: what would be the best way to deal with this type of sex bias?"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_cellcycle",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_cellcycle",
    "title": " Quality Control",
    "section": "7 Cell cycle state",
    "text": "7 Cell cycle state\nWe here perform cell cycle scoring. To score a gene list, the algorithm calculates the difference of mean expression of the given list and the mean expression of reference genes. To build the reference, the function randomly chooses a bunch of genes matching the distribution of the expression of the given list. Cell cycle scoring adds three slots in data, a score for S phase, a score for G2M phase and the predicted cell cycle phase.\n\n# Before running CellCycleScoring the data need to be normalized and logtransformed.\ndata.filt = NormalizeData(data.filt)\ndata.filt &lt;- CellCycleScoring(object = data.filt,\n                              g2m.features = cc.genes$g2m.genes,\n                              s.features = cc.genes$s.genes)\n\nWe can now plot a violin plot for the cell cycle scores as well.\n\nVlnPlot(data.filt, features = c(\"S.Score\",\"G2M.Score\"), group.by= \"orig.ident\",ncol = 4, pt.size = .1)\n\n\n\n\n\n\n\n\nIn this case it looks like we only have a few cycling cells in the datasets."
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_doublet",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_doublet",
    "title": " Quality Control",
    "section": "8 Predict doublets",
    "text": "8 Predict doublets\nDoublets/Multiples of cells in the same well/droplet is a common issue in scRNAseq protocols. Especially in droplet-based methods with overloading of cells. In a typical 10x experiment the proportion of doublets is linearly dependent on the amount of loaded cells. As indicated from the Chromium user guide, doublet rates are about as follows:\n\nMost doublet detectors simulates doublets by merging cell counts and predicts doublets as cells that have similar embeddings as the simulated doublets. Most such packages need an assumption about the number/proportion of expected doublets in the dataset. The data you are using is subsampled, but the original datasets contained about 5 000 cells per sample, hence we can assume that they loaded about 9 000 cells and should have a doublet rate at about 4%.\n\n\n\n\n\n\nCaution\n\n\n\nIdeally doublet prediction should be run on each sample separately, especially if your different samples have different proportions of cell types. In this case, the data is subsampled so we have very few cells per sample and all samples are sorted PBMCs so it is okay to run them together.\n\n\nHere, we will use DoubletFinder to predict doublet cells. But before doing doublet detection we need to run scaling, variable gene selection and pca, as well as UMAP for visualization. These steps will be explored in more detail in coming exercises.\n\nsuppressMessages(require(DoubletFinder))\n\ndata.filt = FindVariableFeatures(data.filt, verbose = F)\ndata.filt = ScaleData(data.filt, vars.to.regress = c(\"nFeature_RNA\", \"percent_mito\"), verbose = F)\ndata.filt = RunPCA(data.filt, verbose = F, npcs = 20)\ndata.filt = RunUMAP(data.filt, dims = 1:10, verbose = F)\n\nThen we run doubletFinder, selecting first 10 PCs and a pK value of 0.9. To optimize the parameters, you can run the paramSweep function in the package.\n\n# Can run parameter optimization with paramSweep\n\n#sweep.res &lt;- paramSweep_v3(data.filt)\n#sweep.stats &lt;- summarizeSweep(sweep.res, GT = FALSE)\n#bcmvn &lt;- find.pK(sweep.stats)\n#barplot(bcmvn$BCmetric, names.arg = bcmvn$pK, las=2)\n\n# define the expected number of doublet cellscells.\nnExp &lt;- round(ncol(data.filt)* 0.04) # expect 4% doublets\ndata.filt &lt;- doubletFinder_v3(data.filt, pN=0.25, pK = 0.09, nExp = nExp, PCs = 1:10)\n\n[1] \"Creating 1921 artificial doublets...\"\n[1] \"Creating Seurat object...\"\n[1] \"Normalizing Seurat object...\"\n[1] \"Finding variable genes...\"\n[1] \"Scaling data...\"\n[1] \"Running PCA...\"\n[1] \"Calculating PC distance matrix...\"\n[1] \"Computing pANN...\"\n[1] \"Classifying doublets..\"\n\n\n\n# name of the DF prediction can change, so extract the correct column name.\nDF.name = colnames(data.filt@meta.data)[grepl(\"DF.classification\", colnames(data.filt@meta.data))]\n\ncowplot::plot_grid( ncol = 2,\nDimPlot(data.filt, group.by = \"orig.ident\") + NoAxes(),\nDimPlot(data.filt, group.by = DF.name) + NoAxes()\n)\n\n\n\n\n\n\n\n\nWe should expect that two cells have more detected genes than a single cell, lets check if our predicted doublets also have more detected genes in general.\n\nVlnPlot(data.filt, features = \"nFeature_RNA\", group.by = DF.name, pt.size = .1)\n\n\n\n\n\n\n\n\nNow, lets remove all predicted doublets from our data.\n\ndata.filt = data.filt[,data.filt@meta.data[,DF.name] == \"Singlet\"]\ndim(data.filt)\n\n[1] 18121  5532"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-qc_save",
    "href": "labs/seurat/seurat_01_qc.html#meta-qc_save",
    "title": " Quality Control",
    "section": "9 Save data",
    "text": "9 Save data\nFinally, lets save the QC-filtered data for further analysis. Create output directory results and save data to that folder. This will be used in downstream labs.\n\nif (!dir.exists(\"data/results\")) dir.create(\"data/results\", showWarnings = F)\nif (!file.exists(\"data/results/seurat_covid_qc.rds\")) saveRDS(data.filt, \"data/results/seurat_covid_qc.rds\")"
  },
  {
    "objectID": "labs/seurat/seurat_01_qc.html#meta-session",
    "href": "labs/seurat/seurat_01_qc.html#meta-session",
    "title": " Quality Control",
    "section": "10 Session info",
    "text": "10 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] KernSmooth_2.23-20  fields_14.1         viridis_0.6.3      \n[4] viridisLite_0.4.2   spam_2.9-1          DoubletFinder_2.0.3\n[7] Matrix_1.6-0        SeuratObject_4.1.3  Seurat_4.3.0.1     \n\nloaded via a namespace (and not attached):\n  [1] ggbeeswarm_0.7.2       Rtsne_0.16             colorspace_2.1-0      \n  [4] deldir_1.0-9           ellipsis_0.3.2         ggridges_0.5.4        \n  [7] rstudioapi_0.14        spatstat.data_3.0-1    farver_2.1.1          \n [10] leiden_0.4.3           listenv_0.9.0          bit64_4.0.5           \n [13] ggrepel_0.9.3          fansi_1.0.4            codetools_0.2-19      \n [16] splines_4.2.3          knitr_1.43             polyclip_1.10-4       \n [19] jsonlite_1.8.7         ica_1.0-3              cluster_2.1.4         \n [22] png_0.1-8              uwot_0.1.16            shiny_1.7.4           \n [25] sctransform_0.3.5      spatstat.sparse_3.0-2  compiler_4.2.3        \n [28] httr_1.4.6             fastmap_1.1.1          lazyeval_0.2.2        \n [31] cli_3.6.1              later_1.3.1            htmltools_0.5.5       \n [34] tools_4.2.3            dotCall64_1.0-2        igraph_1.5.0          \n [37] gtable_0.3.3           glue_1.6.2             RANN_2.6.1            \n [40] reshape2_1.4.4         dplyr_1.1.1            maps_3.4.1            \n [43] Rcpp_1.0.10            scattermore_1.2        vctrs_0.6.3           \n [46] spatstat.explore_3.2-1 nlme_3.1-162           progressr_0.13.0      \n [49] lmtest_0.9-40          spatstat.random_3.1-5  xfun_0.39             \n [52] stringr_1.5.0          globals_0.16.2         mime_0.12             \n [55] miniUI_0.1.1.1         lifecycle_1.0.3        irlba_2.3.5.1         \n [58] goftest_1.2-3          future_1.33.0          MASS_7.3-58.2         \n [61] zoo_1.8-12             scales_1.2.1           promises_1.2.0.1      \n [64] spatstat.utils_3.0-3   parallel_4.2.3         RColorBrewer_1.1-3    \n [67] yaml_2.3.7             reticulate_1.30        pbapply_1.7-2         \n [70] gridExtra_2.3          ggrastr_1.0.2          ggplot2_3.4.2         \n [73] stringi_1.7.12         rlang_1.1.1            pkgconfig_2.0.3       \n [76] matrixStats_1.0.0      evaluate_0.21          lattice_0.20-45       \n [79] ROCR_1.0-11            purrr_1.0.1            tensor_1.5            \n [82] labeling_0.4.2         patchwork_1.1.2        htmlwidgets_1.6.2     \n [85] bit_4.0.5              cowplot_1.1.1          tidyselect_1.2.0      \n [88] parallelly_1.36.0      RcppAnnoy_0.0.21       plyr_1.8.8            \n [91] magrittr_2.0.3         R6_2.5.1               generics_0.1.3        \n [94] withr_2.5.0            pillar_1.9.0           fitdistrplus_1.1-11   \n [97] survival_3.5-3         abind_1.4-5            sp_2.0-0              \n[100] tibble_3.2.1           future.apply_1.11.0    hdf5r_1.3.8           \n[103] utf8_1.2.3             spatstat.geom_3.2-1    plotly_4.10.2         \n[106] rmarkdown_2.21         grid_4.2.3             data.table_1.14.8     \n[109] digest_0.6.33          xtable_1.8-4           tidyr_1.3.0           \n[112] httpuv_1.6.11          munsell_0.5.0          beeswarm_0.4.0        \n[115] vipor_0.4.5"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html",
    "href": "labs/seurat/seurat_02_dimred.html",
    "title": " Dimensionality Reduction",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified."
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_prep",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_prep",
    "title": " Dimensionality Reduction",
    "section": "1 Data preparation",
    "text": "1 Data preparation\nFirst, let’s load all necessary libraries and the QC-filtered dataset from the previous step.\n\nsuppressPackageStartupMessages({\n  library(Seurat)\n  library(cowplot)\n  library(ggplot2)\n  library(scran)\n})\n\nalldata &lt;- readRDS(\"data/results/seurat_covid_qc.rds\")"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_fs",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_fs",
    "title": " Dimensionality Reduction",
    "section": "2 Feature selection",
    "text": "2 Feature selection\nNext, we first need to define which features/genes are important in our dataset to distinguish cell types. For this purpose, we need to find genes that are highly variable across cells, which in turn will also provide a good separation of the cell clusters.\n\nsuppressWarnings(suppressMessages(alldata &lt;- FindVariableFeatures(alldata, selection.method = \"vst\", nfeatures = 2000 ,verbose = FALSE,assay = \"RNA\")))\ntop20 &lt;- head(VariableFeatures(alldata), 20)\n\nLabelPoints(plot = VariableFeaturePlot(alldata), points = top20, repel = TRUE)"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_zs",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_zs",
    "title": " Dimensionality Reduction",
    "section": "3 Z-score transformation",
    "text": "3 Z-score transformation\nNow that the data is prepared, we now proceed with PCA. Since each gene has a different expression level, it means that genes with higher expression values will naturally have higher variation that will be captured by PCA. This means that we need to somehow give each gene a similar weight when performing PCA (see below). The common practice is to center and scale each gene before performing PCA. This exact scaling is called Z-score normalization it is very useful for PCA, clustering and plotting heatmaps. Additionally, we can use regression to remove any unwanted sources of variation from the dataset, such as cell cycle, sequencing depth, percent mitochondria. This is achieved by doing a generalized linear regression using these parameters as co-variates in the model. Then the residuals of the model are taken as the regressed data. Although perhaps not in the best way, batch effect regression can also be done here. By default variables are scaled in the PCA step and is not done separately. But it could be achieved by running the commands below:\n\nalldata &lt;- ScaleData(alldata, vars.to.regress = c(\"percent_mito\", \"nFeature_RNA\"), assay = \"RNA\")"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_pca",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_pca",
    "title": " Dimensionality Reduction",
    "section": "4 PCA",
    "text": "4 PCA\nPerforming PCA has many useful applications and interpretations, which much depends on the data used. In the case of life sciences, we want to segregate samples based on gene expression patterns in the data.\nTo run PCA you can use the function RunPCA().\n\nalldata &lt;- RunPCA(alldata, npcs = 50, verbose = F)\n\nWe then plot the first principal components.\n\nplot_grid(ncol = 3,\n  DimPlot(alldata, reduction = \"pca\", group.by = \"orig.ident\",dims = 1:2),\n  DimPlot(alldata, reduction = \"pca\", group.by = \"orig.ident\",dims = 3:4),\n  DimPlot(alldata, reduction = \"pca\", group.by = \"orig.ident\",dims = 5:6)\n)\n\n\n\n\n\n\n\n\nTo identify which genes (Seurat) or metadata parameters (Scater/Scran) contribute the most to each PC, one can retrieve the loading matrix information. Unfortunately, this is not implemented in Scater/Scran, so you will need to compute PCA using logcounts.\n\nVizDimLoadings(alldata, dims = 1:5, reduction = \"pca\",ncol = 5,balanced = T)\n\n\n\n\n\n\n\n\nWe can also plot the amount of variance explained by each PC.\n\nElbowPlot(alldata, reduction = \"pca\",ndims = 50)\n\n\n\n\n\n\n\n\nBased on this plot, we can see that the top 8 PCs retain a lot of information, while other PCs contain progressively less. However, it is still advisable to use more PCs since they might contain information about rare cell types (such as platelets and DCs in this dataset)"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_tsne",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_tsne",
    "title": " Dimensionality Reduction",
    "section": "5 tSNE",
    "text": "5 tSNE\nWe can now run BH-tSNE.\n\nalldata &lt;- RunTSNE(alldata, reduction = \"pca\", dims = 1:30, \n                   perplexity=30,\n                   max_iter=1000,\n                   theta=0.5,\n                   eta=200,\n                   num_threads=0 )\n#see ?Rtsne and ?RunTSNE for more info\n\nWe can now plot the tSNE colored per dataset. We can clearly see the effect of batches present in the dataset.\n\nDimPlot(alldata, reduction = \"tsne\", group.by = \"orig.ident\")"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_umap",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_umap",
    "title": " Dimensionality Reduction",
    "section": "6 UMAP",
    "text": "6 UMAP\nWe can now run UMAP for cell embeddings.\n\nalldata &lt;- RunUMAP(alldata, reduction = \"pca\", dims = 1:30,\n                   n.components=2,\n                   n.neighbors=30,\n                   n.epochs=200,\n                   min.dist=0.3,\n                   learning.rate=1,\n                   spread=1 )\n#see ?RunUMAP for more info\n\nAnother usefullness of UMAP is that it is not limitted by the number of dimensions the data cen be reduced into (unlike tSNE). We can simply reduce the dimentions altering the n.components parameter.\n\n# we can add in additional reductions, by defulat they are named \"pca\", \"umap\", \"tsne\" etc. But we can specify alternative names with reduction.name\n\nalldata &lt;- RunUMAP(alldata, reduction.name = \"UMAP10_on_PCA\",\n                   reduction = \"pca\", \n                   dims = 1:30,\n                   n.components=10,\n                   n.neighbors=30,\n                   n.epochs=200,\n                   min.dist=0.3,\n                   learning.rate=1,\n                   spread=1 )\n#see ?RunUMAP for more info\n\nUMAP is plotted colored per dataset. Although less distinct as in the tSNE, we still see quite an effect of the different batches in the data. UMAP is not limited by the number of dimensions the data can be reduced into (unlike tSNE). We can simply reduce the dimensions altering the n.components parameter.\n\nplot_grid(ncol = 3,\n  DimPlot(alldata, reduction = \"umap\", group.by = \"orig.ident\")+ ggplot2::ggtitle(label =\"UMAP_on_PCA\"),\n  DimPlot(alldata, reduction = \"UMAP10_on_PCA\", group.by = \"orig.ident\",dims = 1:2)+ ggplot2::ggtitle(label =\"UMAP10_on_PCA\"),\n  DimPlot(alldata, reduction = \"UMAP10_on_PCA\", group.by = \"orig.ident\",dims = 3:4)+ ggplot2::ggtitle(label =\"UMAP10_on_PCA\")\n)\n\n\n\n\n\n\n\n\nWe can now plot PCA, UMAP and tSNE side by side for comparison. Here, we can conclude that our dataset contains a batch effect that needs to be corrected before proceeding to clustering and differential gene expression analysis.\n\nplot_grid(ncol = 3,\n  DimPlot(alldata, reduction = \"pca\", group.by = \"orig.ident\"),\n  DimPlot(alldata, reduction = \"tsne\", group.by = \"orig.ident\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"orig.ident\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nWe have now done Variable gene selection, PCA and UMAP with the settings we chose. Test a few different ways of selecting variable genes, number of PCs for UMAP and check how it influences your embedding."
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_zsg",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_zsg",
    "title": " Dimensionality Reduction",
    "section": "7 Z-scores & DR graphs",
    "text": "7 Z-scores & DR graphs\nAlthough running a second dimensionality reduction (i.e tSNE or UMAP) on PCA would be a standard approach (because it allows higher computation efficiency), the options are actually limitless. Below we will show a couple of other common options such as running directly on the scaled data (z-scores) (which was used for PCA) or on a graph built from scaled data. We will show from now on only UMAP, but the same applies for tSNE.\n\n7.1 UMAP from z-scores\nTo run tSNE or UMAP on the scaled data, one first needs to select the number of variables to use. This is because including dimensions that do contribute to the separation of your cell types will in the end mask those differences. Another reason for it is because running with all genes/features also will take longer or might be computationally unfeasible. Therefore we will use the scaled data of the highly variable genes.\n\nalldata &lt;- RunUMAP(alldata, reduction.name = \"UMAP_on_ScaleData\",\n                   features = alldata@assays$RNA@var.features,\n                   assay = \"RNA\",\n                   n.components=2,\n                   n.neighbors=30,\n                   n.epochs=200,\n                   min.dist=0.3,\n                   learning.rate=1,\n                   spread=1 )\n\n\n\n7.2 UMAP from graph\nTo run tSNE or UMAP on the a graph, we first need to build a graph from the data. In fact, both tSNE and UMAP first build a graph from the data using a specified distance matrix and then optimize the embedding. Since a graph is just a matrix containing distances from cell to cell and as such, you can run either UMAP or tSNE using any other distance metric desired. Euclidean and Correlation are usually the most commonly used.\n\n#Build Graph\nalldata &lt;- FindNeighbors(alldata,\n                         reduction = \"pca\",\n                         assay = \"RNA\",\n                         k.param = 20,\n                         features = alldata@assays$RNA@var.features)\n\n#Run UMAP on a graph\nlibrary(reticulate)\nreticulate::use_condaenv(\"sspy\")\nalldata &lt;- RunUMAP(alldata, reduction.name = \"UMAP_on_Graph\", umap.method = \"umap-learn\", graph = \"RNA_snn\", assay = \"RNA\" )\n\nWe can now plot the UMAP comparing both on PCA vs ScaledSata vs Graph.\n\np1 &lt;- DimPlot(alldata, reduction = \"umap\", group.by = \"orig.ident\")+ ggplot2::ggtitle(label =\"UMAP_on_PCA\")\np2 &lt;- DimPlot(alldata, reduction = \"UMAP_on_ScaleData\", group.by = \"orig.ident\")+ ggplot2::ggtitle(label =\"UMAP_on_ScaleData\")\np3 &lt;- DimPlot(alldata, reduction = \"UMAP_on_Graph\", group.by = \"orig.ident\")+ ggplot2::ggtitle(label =\"UMAP_on_Graph\")\nleg &lt;- get_legend(p1)\n\ngridExtra::grid.arrange(\n  gridExtra::arrangeGrob(\n    p1 + NoLegend() + NoAxes(),\n    p2 + NoLegend() + NoAxes(),\n    p3 + NoLegend() + NoAxes(), \n    leg,nrow=2),\n  ncol=1,widths=c(1)\n)"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_plotgenes",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_plotgenes",
    "title": " Dimensionality Reduction",
    "section": "8 Genes of interest",
    "text": "8 Genes of interest\nLet’s plot some marker genes for different cell types onto the embedding.\n\n\n\nMarkers\nCell Type\n\n\n\n\nCD3E\nT cells\n\n\nCD3E CD4\nCD4+ T cells\n\n\nCD3E CD8A\nCD8+ T cells\n\n\nGNLY, NKG7\nNK cells\n\n\nMS4A1\nB cells\n\n\nCD14, LYZ, CST3, MS4A7\nCD14+ Monocytes\n\n\nFCGR3A, LYZ, CST3, MS4A7\nFCGR3A+ Monocytes\n\n\nFCER1A, CST3\nDCs\n\n\n\n\nmyfeatures &lt;- c(\"CD3E\",\"CD4\",\"CD8A\",\"NKG7\",\"GNLY\",\"MS4A1\",\"CD14\",\"LYZ\",\"MS4A7\",\"FCGR3A\",\"CST3\",\"FCER1A\")\nplot_list &lt;- list()\nfor(i in myfeatures){\n  plot_list[[i]] &lt;- FeaturePlot(alldata, reduction = \"umap\",dims = 1:2,\n            features = i,ncol = 3,order = T) + NoLegend() + NoAxes() + NoGrid() }\nplot_grid(ncol=3, plotlist = plot_list)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nSelect some of your dimensionality reductions and plot some of the QC stats that were calculated in the previous lab. Can you see if some of the separation in your data is driven by quality of the cells?"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-dimred_save",
    "href": "labs/seurat/seurat_02_dimred.html#meta-dimred_save",
    "title": " Dimensionality Reduction",
    "section": "9 Save data",
    "text": "9 Save data\nWe can finally save the object for use in future steps.\n\npath &lt;- \"data/results/covid_qc_dr.rds\"\nif(!file.exists(path)) saveRDS(alldata,path)"
  },
  {
    "objectID": "labs/seurat/seurat_02_dimred.html#meta-session",
    "href": "labs/seurat/seurat_02_dimred.html#meta-session",
    "title": " Dimensionality Reduction",
    "section": "10 Session info",
    "text": "10 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] reticulate_1.30             scran_1.26.2               \n [3] scuttle_1.8.4               SingleCellExperiment_1.20.1\n [5] SummarizedExperiment_1.28.0 Biobase_2.58.0             \n [7] GenomicRanges_1.50.2        GenomeInfoDb_1.34.9        \n [9] IRanges_2.32.0              S4Vectors_0.36.2           \n[11] BiocGenerics_0.44.0         MatrixGenerics_1.10.0      \n[13] matrixStats_1.0.0           ggplot2_3.4.2              \n[15] cowplot_1.1.1               SeuratObject_4.1.3         \n[17] Seurat_4.3.0.1             \n\nloaded via a namespace (and not attached):\n  [1] plyr_1.8.8                igraph_1.5.0             \n  [3] lazyeval_0.2.2            sp_2.0-0                 \n  [5] splines_4.2.3             BiocParallel_1.32.6      \n  [7] listenv_0.9.0             scattermore_1.2          \n  [9] digest_0.6.33             htmltools_0.5.5          \n [11] fansi_1.0.4               magrittr_2.0.3           \n [13] ScaledMatrix_1.6.0        tensor_1.5               \n [15] cluster_2.1.4             ROCR_1.0-11              \n [17] limma_3.54.2              globals_0.16.2           \n [19] spatstat.sparse_3.0-2     colorspace_2.1-0         \n [21] rappdirs_0.3.3            ggrepel_0.9.3            \n [23] xfun_0.39                 dplyr_1.1.1              \n [25] RCurl_1.98-1.12           jsonlite_1.8.7           \n [27] progressr_0.13.0          spatstat.data_3.0-1      \n [29] survival_3.5-3            zoo_1.8-12               \n [31] glue_1.6.2                polyclip_1.10-4          \n [33] gtable_0.3.3              zlibbioc_1.44.0          \n [35] XVector_0.38.0            leiden_0.4.3             \n [37] DelayedArray_0.24.0       BiocSingular_1.14.0      \n [39] future.apply_1.11.0       abind_1.4-5              \n [41] scales_1.2.1              edgeR_3.40.2             \n [43] spatstat.random_3.1-5     miniUI_0.1.1.1           \n [45] Rcpp_1.0.10               viridisLite_0.4.2        \n [47] xtable_1.8-4              dqrng_0.3.0              \n [49] rsvd_1.0.5                metapod_1.6.0            \n [51] htmlwidgets_1.6.2         httr_1.4.6               \n [53] RColorBrewer_1.1-3        ellipsis_0.3.2           \n [55] ica_1.0-3                 farver_2.1.1             \n [57] pkgconfig_2.0.3           uwot_0.1.16              \n [59] deldir_1.0-9              here_1.0.1               \n [61] locfit_1.5-9.8            utf8_1.2.3               \n [63] labeling_0.4.2            tidyselect_1.2.0         \n [65] rlang_1.1.1               reshape2_1.4.4           \n [67] later_1.3.1               munsell_0.5.0            \n [69] tools_4.2.3               cli_3.6.1                \n [71] generics_0.1.3            ggridges_0.5.4           \n [73] evaluate_0.21             stringr_1.5.0            \n [75] fastmap_1.1.1             yaml_2.3.7               \n [77] goftest_1.2-3             knitr_1.43               \n [79] fitdistrplus_1.1-11       purrr_1.0.1              \n [81] RANN_2.6.1                pbapply_1.7-2            \n [83] future_1.33.0             nlme_3.1-162             \n [85] sparseMatrixStats_1.10.0  mime_0.12                \n [87] compiler_4.2.3            rstudioapi_0.14          \n [89] plotly_4.10.2             png_0.1-8                \n [91] spatstat.utils_3.0-3      statmod_1.5.0            \n [93] tibble_3.2.1              stringi_1.7.12           \n [95] lattice_0.20-45           bluster_1.8.0            \n [97] Matrix_1.6-0              vctrs_0.6.3              \n [99] pillar_1.9.0              lifecycle_1.0.3          \n[101] spatstat.geom_3.2-1       lmtest_0.9-40            \n[103] RcppAnnoy_0.0.21          BiocNeighbors_1.16.0     \n[105] data.table_1.14.8         bitops_1.0-7             \n[107] irlba_2.3.5.1             httpuv_1.6.11            \n[109] patchwork_1.1.2           R6_2.5.1                 \n[111] promises_1.2.0.1          KernSmooth_2.23-20       \n[113] gridExtra_2.3             parallelly_1.36.0        \n[115] codetools_0.2-19          MASS_7.3-58.2            \n[117] rprojroot_2.0.3           withr_2.5.0              \n[119] sctransform_0.3.5         GenomeInfoDbData_1.2.9   \n[121] parallel_4.2.3            grid_4.2.3               \n[123] beachmat_2.14.2           tidyr_1.3.0              \n[125] rmarkdown_2.21            DelayedMatrixStats_1.20.0\n[127] Rtsne_0.16                spatstat.explore_3.2-1   \n[129] shiny_1.7.4"
  },
  {
    "objectID": "labs/seurat/seurat_03_integration.html",
    "href": "labs/seurat/seurat_03_integration.html",
    "title": " Data Integration",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nIn this tutorial we will look at different ways of integrating multiple single cell RNA-seq datasets. We will explore two different methods to correct for batch effects across datasets. We will also look at a quantitative measure to assess the quality of the integrated data. Seurat uses the data integration method presented in Comprehensive Integration of Single Cell Data, while Scran and Scanpy use a mutual Nearest neighbour method (MNN). Below you can find a list of the most recent methods for single data integration:"
  },
  {
    "objectID": "labs/seurat/seurat_03_integration.html#meta-int_prep",
    "href": "labs/seurat/seurat_03_integration.html#meta-int_prep",
    "title": " Data Integration",
    "section": "1 Data preparation",
    "text": "1 Data preparation\nLet’s first load necessary libraries and the data saved in the previous lab.\n\nsuppressPackageStartupMessages({\n  library(Seurat)\n  library(cowplot)\n  library(ggplot2)\n})\n\nalldata &lt;- readRDS(\"data/results/covid_qc_dr.rds\")\nprint(names(alldata@reductions))\n\n[1] \"pca\"               \"umap\"              \"tsne\"             \n[4] \"UMAP10_on_PCA\"     \"UMAP_on_ScaleData\" \"UMAP_on_Graph\"    \n\n\nWe split the combined object into a list, with each dataset as an element. We perform standard preprocessing (log-normalization), and identify variable features individually for each dataset based on a variance stabilizing transformation (vst).\n\nalldata.list &lt;- SplitObject(alldata, split.by = \"orig.ident\")\n\nfor (i in 1:length(alldata.list)) {\n    alldata.list[[i]] &lt;- NormalizeData(alldata.list[[i]], verbose = FALSE)\n    alldata.list[[i]] &lt;- FindVariableFeatures(alldata.list[[i]], selection.method = \"vst\", nfeatures = 2000,verbose = FALSE)\n}\n\nhvgs_per_dataset &lt;- lapply(alldata.list, function(x) { x@assays$RNA@var.features })\n# venn::venn(hvgs_per_dataset,opacity = .4,zcolor = scales::hue_pal()(3),cexsn = 1,cexil = 1,lwd=1,col=\"white\",frame=F,borders = NA)\n\ntemp &lt;- unique(unlist(hvgs_per_dataset))\noverlap &lt;- sapply( hvgs_per_dataset , function(x) { temp %in% x } )\npheatmap::pheatmap(t(overlap*1),cluster_rows = F ,\n                   color = c(\"grey90\",\"grey20\"))"
  },
  {
    "objectID": "labs/seurat/seurat_03_integration.html#cca",
    "href": "labs/seurat/seurat_03_integration.html#cca",
    "title": " Data Integration",
    "section": "2 CCA",
    "text": "2 CCA\nWe identify anchors using the FindIntegrationAnchors function, which takes a list of Seurat objects as input.\n\nalldata.anchors &lt;- FindIntegrationAnchors(object.list = alldata.list, dims = 1:30,reduction = \"cca\")\n\nWe then pass these anchors to the IntegrateData function, which returns a Seurat object.\n\nalldata.int &lt;- IntegrateData(anchorset = alldata.anchors, dims = 1:30, new.assay.name = \"CCA\")\n\nWe can observe that a new assay slot is now created under the name CCA.\n\nnames(alldata.int@assays)\n\n# by default, Seurat now sets the integrated assay as the default assay, so any operation you now perform will be on the ingegrated data.\nalldata.int@active.assay\n\n[1] \"RNA\" \"CCA\"\n[1] \"CCA\"\n\n\nAfter running IntegrateData, the Seurat object will contain a new Assay with the integrated (or batch-corrected) expression matrix. Note that the original (uncorrected values) are still stored in the object in the “RNA” assay, so you can switch back and forth. We can then use this new integrated matrix for downstream analysis and visualization. Here we scale the integrated data, run PCA, and visualize the results with UMAP and TSNE. The integrated datasets cluster by cell type, instead of by technology.\n\n#Run Dimensionality reduction on integrated space\nalldata.int &lt;- ScaleData(alldata.int, verbose = FALSE)\nalldata.int &lt;- RunPCA(alldata.int, npcs = 30, verbose = FALSE)\nalldata.int &lt;- RunUMAP(alldata.int, dims = 1:30)\nalldata.int &lt;- RunTSNE(alldata.int, dims = 1:30)\n\nWe can now plot the unintegrated and the integrated space reduced dimensions.\n\nplot_grid(ncol = 3,\n  DimPlot(alldata, reduction = \"pca\", group.by = \"orig.ident\")+NoAxes()+ggtitle(\"PCA raw_data\"),\n  DimPlot(alldata, reduction = \"tsne\", group.by = \"orig.ident\")+NoAxes()+ggtitle(\"tSNE raw_data\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"orig.ident\")+NoAxes()+ggtitle(\"UMAP raw_data\"),\n  \n  DimPlot(alldata.int, reduction = \"pca\", group.by = \"orig.ident\")+NoAxes()+ggtitle(\"PCA integrated\"),\n  DimPlot(alldata.int, reduction = \"tsne\", group.by = \"orig.ident\")+NoAxes()+ggtitle(\"tSNE integrated\"),\n  DimPlot(alldata.int, reduction = \"umap\", group.by = \"orig.ident\")+NoAxes()+ggtitle(\"UMAP integrated\")\n)\n\n\n\n\n\n\n\n\nLet’s plot some marker genes for different cell types onto the embedding.\n\n\n\nMarkers\nCell Type\n\n\n\n\nCD3E\nT cells\n\n\nCD3E CD4\nCD4+ T cells\n\n\nCD3E CD8A\nCD8+ T cells\n\n\nGNLY, NKG7\nNK cells\n\n\nMS4A1\nB cells\n\n\nCD14, LYZ, CST3, MS4A7\nCD14+ Monocytes\n\n\nFCGR3A, LYZ, CST3, MS4A7\nFCGR3A+ Monocytes\n\n\nFCER1A, CST3\nDCs\n\n\n\n\nmyfeatures &lt;- c(\"CD3E\",\"CD4\",\"CD8A\",\"NKG7\",\"GNLY\",\"MS4A1\",\"CD14\",\"LYZ\",\"MS4A7\",\"FCGR3A\",\"CST3\",\"FCER1A\")\nplot_list &lt;- list()\nfor(i in myfeatures){\n  plot_list[[i]] &lt;- FeaturePlot(alldata, reduction = \"umap\",dims = 1:2,\n            features = i,ncol = 3,order = T) + NoLegend() + NoAxes() + NoGrid() }\nplot_grid(ncol=3, plotlist = plot_list)\n\n\n\n\n\n\n\n\n\nlibrary(harmony)\n\nalldata.harmony &lt;- RunHarmony(\n  alldata,\n  group.by.vars = \"orig.ident\",\n  reduction = \"pca\",\n  dims.use = 1:50,\n  assay.use = \"RNA\")\n\n#Here we use all PCs computed from Harmony for UMAP calculation\nalldata.int[[\"harmony\"]] &lt;- alldata.harmony[[\"harmony\"]]\nalldata.int &lt;- RunUMAP(alldata.int, dims = 1:50, reduction = \"harmony\", reduction.name = \"umap_harmony\")\n\n\nhvgs &lt;- unique(unlist(hvgs_per_dataset))\n\nassaylist &lt;- list()\ngenelist &lt;- list()\nfor(i in 1:length(alldata.list)) {\n  assaylist[[i]] &lt;- t(as.matrix(GetAssayData(alldata.list[[i]], \"data\")[hvgs,]))\n  genelist[[i]] &lt;- hvgs\n}\n\nlapply(assaylist,dim)\n\n[[1]]\n[1]  535 5203\n\n[[2]]\n[1]  851 5203\n\n[[3]]\n[1]  946 5203\n\n[[4]]\n[1] 1026 5203\n\n[[5]]\n[1] 1139 5203\n\n[[6]]\n[1] 1035 5203\n\n\n\nlibrary(reticulate)\nreticulate::use_condaenv(\"sspy\")\nscanorama &lt;- import(\"scanorama\")\n\nintegrated.data &lt;- scanorama$integrate(datasets_full = assaylist,\n                                       genes_list = genelist )\n\nintdimred &lt;- do.call(rbind, integrated.data[[1]])\ncolnames(intdimred) &lt;- paste0(\"PC_\", 1:100)\nrownames(intdimred) &lt;- colnames(alldata.int)\n\n# Add standard deviations in order to draw Elbow Plots in Seurat\nstdevs &lt;- apply(intdimred, MARGIN = 2, FUN = sd)\n\nalldata.int[[\"scanorama\"]] &lt;- CreateDimReducObject(\n  embeddings = intdimred,\n  stdev      = stdevs,\n  key        = \"PC_\",\n  assay      = \"RNA\")\n\n#Here we use all PCs computed from Scanorama for UMAP calculation\nalldata.int &lt;- RunUMAP(alldata.int, dims = 1:100, reduction = \"scanorama\",reduction.name = \"umap_scanorama\")\n\n\np1 &lt;- DimPlot(alldata, reduction = \"umap\", group.by = \"orig.ident\")+ggtitle(\"UMAP raw_data\")\np2 &lt;- DimPlot(alldata.int, reduction = \"umap\", group.by = \"orig.ident\")+ggtitle(\"UMAP CCA\")\np3 &lt;- DimPlot(alldata.int, reduction = \"umap_harmony\", group.by = \"orig.ident\")+ggtitle(\"UMAP Harmony\")\np4 &lt;- DimPlot(alldata.int, reduction = \"umap_scanorama\", group.by = \"orig.ident\")+ggtitle(\"UMAP Scanorama\")\nleg &lt;- get_legend(p1)\n\ngridExtra::grid.arrange(\n  gridExtra::arrangeGrob(\n    p1 + NoLegend() + NoAxes(),\n    p2 + NoLegend() + NoAxes(),\n    p3 + NoLegend() + NoAxes(),\n    p4 + NoLegend() + NoAxes(), nrow=2),\n  leg, ncol=2,widths=c(8,2)\n)\n\n\n\n\n\n\n\n\nLet’s save the integrated data for further analysis.\n\nsaveRDS(alldata.int,\"data/results/covid_qc_dr_int.rds\")"
  },
  {
    "objectID": "labs/seurat/seurat_03_integration.html#meta-session",
    "href": "labs/seurat/seurat_03_integration.html#meta-session",
    "title": " Data Integration",
    "section": "3 Session info",
    "text": "3 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] reticulate_1.30    harmony_0.1.1      Rcpp_1.0.10        ggplot2_3.4.2     \n[5] cowplot_1.1.1      SeuratObject_4.1.3 Seurat_4.3.0.1    \n\nloaded via a namespace (and not attached):\n  [1] Rtsne_0.16             colorspace_2.1-0       deldir_1.0-9          \n  [4] ellipsis_0.3.2         ggridges_0.5.4         rprojroot_2.0.3       \n  [7] rstudioapi_0.14        spatstat.data_3.0-1    farver_2.1.1          \n [10] leiden_0.4.3           listenv_0.9.0          ggrepel_0.9.3         \n [13] fansi_1.0.4            codetools_0.2-19       splines_4.2.3         \n [16] knitr_1.43             polyclip_1.10-4        jsonlite_1.8.7        \n [19] ica_1.0-3              cluster_2.1.4          png_0.1-8             \n [22] pheatmap_1.0.12        uwot_0.1.16            shiny_1.7.4           \n [25] sctransform_0.3.5      spatstat.sparse_3.0-2  compiler_4.2.3        \n [28] httr_1.4.6             Matrix_1.6-0           fastmap_1.1.1         \n [31] lazyeval_0.2.2         cli_3.6.1              later_1.3.1           \n [34] htmltools_0.5.5        tools_4.2.3            igraph_1.5.0          \n [37] gtable_0.3.3           glue_1.6.2             RANN_2.6.1            \n [40] reshape2_1.4.4         dplyr_1.1.1            rappdirs_0.3.3        \n [43] scattermore_1.2        vctrs_0.6.3            spatstat.explore_3.2-1\n [46] nlme_3.1-162           progressr_0.13.0       lmtest_0.9-40         \n [49] spatstat.random_3.1-5  xfun_0.39              stringr_1.5.0         \n [52] globals_0.16.2         mime_0.12              miniUI_0.1.1.1        \n [55] lifecycle_1.0.3        irlba_2.3.5.1          goftest_1.2-3         \n [58] future_1.33.0          MASS_7.3-58.2          zoo_1.8-12            \n [61] scales_1.2.1           promises_1.2.0.1       spatstat.utils_3.0-3  \n [64] parallel_4.2.3         RColorBrewer_1.1-3     yaml_2.3.7            \n [67] pbapply_1.7-2          gridExtra_2.3          stringi_1.7.12        \n [70] rlang_1.1.1            pkgconfig_2.0.3        matrixStats_1.0.0     \n [73] evaluate_0.21          lattice_0.20-45        ROCR_1.0-11           \n [76] purrr_1.0.1            tensor_1.5             labeling_0.4.2        \n [79] patchwork_1.1.2        htmlwidgets_1.6.2      tidyselect_1.2.0      \n [82] here_1.0.1             parallelly_1.36.0      RcppAnnoy_0.0.21      \n [85] plyr_1.8.8             magrittr_2.0.3         R6_2.5.1              \n [88] generics_0.1.3         pillar_1.9.0           withr_2.5.0           \n [91] fitdistrplus_1.1-11    survival_3.5-3         abind_1.4-5           \n [94] sp_2.0-0               tibble_3.2.1           future.apply_1.11.0   \n [97] KernSmooth_2.23-20     utf8_1.2.3             spatstat.geom_3.2-1   \n[100] plotly_4.10.2          rmarkdown_2.21         grid_4.2.3            \n[103] data.table_1.14.8      digest_0.6.33          xtable_1.8-4          \n[106] tidyr_1.3.0            httpuv_1.6.11          munsell_0.5.0         \n[109] viridisLite_0.4.2"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html",
    "href": "labs/bioc/bioc_01_qc.html",
    "title": " Quality Control",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified."
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_data",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_data",
    "title": " Quality Control",
    "section": "1 Get data",
    "text": "1 Get data\nIn this tutorial, we will run all tutorials with a set of 6 PBMC 10x datasets from 3 covid-19 patients and 3 healthy controls, the samples have been subsampled to 1500 cells per sample. They are part of the github repo and if you have cloned the repo they should be available in folder: labs/data/covid_data_GSE149689. Instructions on how to download them can also be found in the Precourse material.\n\nwebpath &lt;- \"https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/\"\n\nif(!dir.exists(\"./data/raw\")){\n  dir.create(\"./data/raw\", recursive = T)\n  file_list &lt;- c(\n    \"Normal_PBMC_13.h5\", \"Normal_PBMC_14.h5\", \"Normal_PBMC_5.h5\",\n    \"nCoV_PBMC_15.h5\", \"nCoV_PBMC_17.h5\", \"nCoV_PBMC_1.h5\"\n  )\n  for (i in file_list) {\n    download.file(\n      url = paste0(webpath, i),\n      destfile = paste0(\"./data/raw/\", i)\n    )\n  }\n}\n\nWith data in place, now we can start loading libraries we will use in this tutorial.\n\nsuppressMessages(require(scater))\nsuppressMessages(require(scran))\nsuppressMessages(require(cowplot))\nsuppressMessages(require(org.Hs.eg.db))\n\nif(!require(DoubletFinder)){\n   remotes::install_github('chris-mcginnis-ucsf/DoubletFinder',upgrade = F, dependencies=F)\n}\nsuppressMessages(require(DoubletFinder))\n\nWe can first load the data individually by reading directly from HDF5 file format (.h5).\n\ncov.15 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_15.h5\",\n  use.names = T)\ncov.1 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_1.h5\",\n  use.names = T)\ncov.17 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/nCoV_PBMC_17.h5\",\n  use.names = T)\n\nctrl.5 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_5.h5\",\n  use.names = T)\nctrl.13 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_13.h5\",\n  use.names = T)\nctrl.14 &lt;- Seurat::Read10X_h5(\n  filename = \"data/raw/Normal_PBMC_14.h5\",\n  use.names = T)"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_collate",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_collate",
    "title": " Quality Control",
    "section": "2 Collate",
    "text": "2 Collate\nWe can now load the expression matrices and merge them into a single object. Each analysis workflow (Seurat, Scater, Scanpy, etc) has its own way of storing data. We will add dataset labels as cell.ids just in case you have overlapping barcodes between the datasets. After that we add a column Chemistry in the metadata for plotting later on.\n\nsce &lt;- SingleCellExperiment( assays = list(counts = cbind(cov.1,cov.15, cov.17, ctrl.5, ctrl.13, ctrl.14)) )\ndim(sce)\n#Adding metadata\nsce@colData$sample &lt;- unlist(sapply(c(\"cov.1\",\"cov.15\",\"cov.17\", \"ctrl.5\",\"ctrl.13\",\"ctrl.14\"),function(x) rep(x,ncol(get(x)))))\nsce@colData$type &lt;- ifelse(grepl(\"cov\",sce@colData$sample), \"Covid\",\"Control\")\n\n[1] 33538  9000\n\n\nOnce you have created the merged Seurat object, the count matrices and individual count matrices and objects are not needed anymore. It is a good idea to remove them and run garbage collect to free up some memory.\n\n# remove all objects that will not be used.\nrm(cov.15, cov.1, cov.17, ctrl.5, ctrl.13, ctrl.14)\n# run garbage collect to free up memory\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  9211256 492.0   17752631 948.1 11473912 612.8\nVcells 35428778 270.4   97806016 746.3 73067177 557.5\n\n\nHere is how the count matrix and the metadata look like for every cell.\n\nhead(counts(sce)[,1:10])\nhead(sce@colData,10)\n\n6 x 10 sparse Matrix of class \"dgCMatrix\"\n                               \nMIR1302-2HG . . . . . . . . . .\nFAM138A     . . . . . . . . . .\nOR4F5       . . . . . . . . . .\nAL627309.1  . . . . . . . . . .\nAL627309.3  . . . . . . . . . .\nAL627309.2  . . . . . . . . . .\nDataFrame with 10 rows and 2 columns\n                        sample        type\n                   &lt;character&gt; &lt;character&gt;\nAGGGTCCCATGACCCG-1       cov.1       Covid\nTACCCACAGCGGGTTA-1       cov.1       Covid\nCCCAACTTCATATGGC-1       cov.1       Covid\nTCAAGTGTCCGAACGC-1       cov.1       Covid\nATTCCTAGTGACTGTT-1       cov.1       Covid\nGTGTTCCGTGGGCTCT-1       cov.1       Covid\nCCTAAGACAGATTAAG-1       cov.1       Covid\nAATAGAGAGGGTTAGC-1       cov.1       Covid\nGGGTCACTCACCTACC-1       cov.1       Covid\nTCCTCTTGTACAGTCT-1       cov.1       Covid"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_calqc",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_calqc",
    "title": " Quality Control",
    "section": "3 Calculate QC",
    "text": "3 Calculate QC\nHaving the data in a suitable format, we can start calculating some quality metrics. We can for example calculate the percentage of mitochondrial and ribosomal genes per cell and add to the metadata. The proportion hemoglobin genes can give an indication of red blood cell contamination. This will be helpful to visualize them across different metadata parameteres (i.e. datasetID and chemistry version). There are several ways of doing this. The QC metrics are finally added to the metadata table.\nCiting from Simple Single Cell workflows (Lun, McCarthy & Marioni, 2017): High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmic RNA from perforated cells. The reasoning is that mitochondria are larger than individual transcript molecules and less likely to escape through tears in the cell membrane.\n\n# Mitochondrial genes\nmito_genes &lt;- rownames(sce)[grep(\"^MT-\",rownames(sce))]\n# Ribosomal genes\nribo_genes &lt;- rownames(sce)[grep(\"^RP[SL]\",rownames(sce))]\n# Hemoglobin genes - includes all genes starting with HB except HBP.\nhb_genes &lt;- rownames(sce)[grep(\"^HB[^(P)]\",rownames(sce))]\n\nFirst, let Scran calculate some general qc-stats for genes and cells with the function perCellQCMetrics. It can also calculate proportion of counts for specific gene subsets, so first we need to define which genes are mitochondrial, ribosomal and hemoglobin.\n\nsce &lt;- addPerCellQC(sce, flatten = T, subsets = list(mt=mito_genes, hb=hb_genes, ribo=ribo_genes))\n\n# Way2: Doing it manually\nsce@colData$percent_mito &lt;- Matrix::colSums(counts(sce)[mito_genes, ]) / sce@colData$total\n\nNow you can see that we have additional data in the metadata slot.\n\nhead(colData(sce))\n\nDataFrame with 6 rows and 15 columns\n                        sample        type       sum  detected subsets_mt_sum\n                   &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;integer&gt;      &lt;numeric&gt;\nAGGGTCCCATGACCCG-1       cov.1       Covid      7698      2140            525\nTACCCACAGCGGGTTA-1       cov.1       Covid     13416      3391            952\nCCCAACTTCATATGGC-1       cov.1       Covid     16498      3654           1253\nTCAAGTGTCCGAACGC-1       cov.1       Covid      1425       608            141\nATTCCTAGTGACTGTT-1       cov.1       Covid      7535      1808            470\nGTGTTCCGTGGGCTCT-1       cov.1       Covid      4378      1345            352\n                   subsets_mt_detected subsets_mt_percent subsets_hb_sum\n                             &lt;integer&gt;          &lt;numeric&gt;      &lt;numeric&gt;\nAGGGTCCCATGACCCG-1                  11            6.81995              2\nTACCCACAGCGGGTTA-1                  11            7.09600              6\nCCCAACTTCATATGGC-1                  12            7.59486              1\nTCAAGTGTCCGAACGC-1                  10            9.89474              1\nATTCCTAGTGACTGTT-1                  11            6.23756              4\nGTGTTCCGTGGGCTCT-1                  10            8.04020              1\n                   subsets_hb_detected subsets_hb_percent subsets_ribo_sum\n                             &lt;integer&gt;          &lt;numeric&gt;        &lt;numeric&gt;\nAGGGTCCCATGACCCG-1                   1         0.02598077             2564\nTACCCACAGCGGGTTA-1                   2         0.04472272             2264\nCCCAACTTCATATGGC-1                   1         0.00606134             2723\nTCAAGTGTCCGAACGC-1                   1         0.07017544              444\nATTCCTAGTGACTGTT-1                   3         0.05308560             3397\nGTGTTCCGTGGGCTCT-1                   1         0.02284148             1588\n                   subsets_ribo_detected subsets_ribo_percent     total\n                               &lt;integer&gt;            &lt;numeric&gt; &lt;numeric&gt;\nAGGGTCCCATGACCCG-1                    82              33.3074      7698\nTACCCACAGCGGGTTA-1                    85              16.8754     13416\nCCCAACTTCATATGGC-1                    87              16.5050     16498\nTCAAGTGTCCGAACGC-1                    68              31.1579      1425\nATTCCTAGTGACTGTT-1                    81              45.0829      7535\nGTGTTCCGTGGGCTCT-1                    79              36.2723      4378\n                   percent_mito\n                      &lt;numeric&gt;\nAGGGTCCCATGACCCG-1    0.0681995\nTACCCACAGCGGGTTA-1    0.0709600\nCCCAACTTCATATGGC-1    0.0759486\nTCAAGTGTCCGAACGC-1    0.0989474\nATTCCTAGTGACTGTT-1    0.0623756\nGTGTTCCGTGGGCTCT-1    0.0804020"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_plotqc",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_plotqc",
    "title": " Quality Control",
    "section": "4 Plot QC",
    "text": "4 Plot QC\nNow we can plot some of the QC variables as violin plots.\n\n# total is total UMIs per cell\n# detected is number of detected genes.\n# the different gene subset percentages are listed as subsets_mt_percent etc.\n\nplot_grid(plotColData(sce,y = \"detected\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"total\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_mt_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_ribo_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_hb_percent\",x = \"sample\",colour_by = \"sample\"),ncol = 3)\n\n\n\n\n\n\n\n\nAs you can see, there is quite some difference in quality for the 4 datasets, with for instance the covid_15 sample having fewer cells with many detected genes and more mitochondrial content. As the ribosomal proteins are highly expressed they will make up a larger proportion of the transcriptional landscape when fewer of the lowly expressed genes are detected. And we can plot the different QC-measures as scatter plots.\n\nplotColData(sce,x = \"total\", y = \"detected\",colour_by = \"sample\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nPlot additional QC stats that we have calculated as scatter plots. How are the different measures correlated? Can you explain why?"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_filter",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_filter",
    "title": " Quality Control",
    "section": "5 Filtering",
    "text": "5 Filtering\n\n5.1 Detection-based filtering\nA standard approach is to filter cells with low amount of reads as well as genes that are present in at least a certain amount of cells. Here we will only consider cells with at least 200 detected genes and genes need to be expressed in at least 3 cells. Please note that those values are highly dependent on the library preparation method used.\nIn Scran, we can use the function quickPerCellQC to filter out outliers from distributions of qc stats, such as detected genes, gene subsets etc. But in this case, we will take one setting at a time and run through the steps of filtering cells.\n\ndim(sce)\n\nselected_c &lt;-  colnames(sce)[sce$detected &gt; 200]\nselected_f &lt;- rownames(sce)[ Matrix::rowSums(counts(sce)) &gt; 3]\n\nsce.filt &lt;- sce[selected_f , selected_c]\ndim(sce.filt)\n\n[1] 33538  9000\n[1] 18147  7973\n\n\nExtremely high number of detected genes could indicate doublets. However, depending on the cell type composition in your sample, you may have cells with higher number of genes (and also higher counts) from one cell type. In this case, we will run doublet prediction further down, so we will skip this step now, but the code below is an example of how it can be run:\n\n# skip for now and run doublet detection instead...\n\n#high.det.v3 &lt;- sce.filt$nFeatures &gt; 4100\n#high.det.v2 &lt;- (sce.filt$nFeatures &gt; 2000) & (sce.filt$sample_id == \"v2.1k\")\n\n# remove these cells\n#sce.filt &lt;- sce.filt[ , (!high.det.v3) & (!high.det.v2)]\n\n# check number of cells\n#ncol(sce.filt)\n\nAdditionally, we can also see which genes contribute the most to such reads. We can for instance plot the percentage of counts per gene.\nIn Scater, you can also use the function plotHighestExprs() to plot the gene contribution, but the function is quite slow.\n\n#Compute the relative expression of each gene per cell\n#Use sparse matrix operations, if your dataset is large, doing matrix devisions the regular way will take a very long time.\nC = counts(sce)\nC@x = C@x / rep.int(colSums(C), diff(C@p))\nmost_expressed &lt;- order(Matrix::rowSums( C ),decreasing = T)[20:1]\nboxplot( as.matrix(t(C[most_expressed,])),cex=.1, las=1, xlab=\"% total count per cell\",col=scales::hue_pal()(20)[20:1],horizontal=TRUE)\n\n\n\n\n\n\n\nrm(C)\n\n# also, there is the option of running the function \"plotHighestExprs\" in the scater package, however, this function takes very long to execute.\n\nAs you can see, MALAT1 constitutes up to 30% of the UMIs from a single cell and the other top genes are mitochondrial and ribosomal genes. It is quite common that nuclear lincRNAs have correlation with quality and mitochondrial reads, so high detection of MALAT1 may be a technical issue. Let us assemble some information about such genes, which are important for quality control and downstream filtering.\n\n\n5.2 Mito/Ribo filtering\nWe also have quite a lot of cells with high proportion of mitochondrial and low proportion of ribosomal reads. It could be wise to remove those cells, if we have enough cells left after filtering. Another option would be to either remove all mitochondrial reads from the dataset and hope that the remaining genes still have enough biological signal. A third option would be to just regress out the percent_mito variable during scaling. In this case we had as much as 99.7% mitochondrial reads in some of the cells, so it is quite unlikely that there is much cell type signature left in those. Looking at the plots, make reasonable decisions on where to draw the cutoff. In this case, the bulk of the cells are below 20% mitochondrial reads and that will be used as a cutoff. We will also remove cells with less than 5% ribosomal reads.\n\nselected_mito &lt;- sce.filt$subsets_mt_percent &lt; 30\nselected_ribo &lt;- sce.filt$subsets_ribo_percent &gt; 5\n\n# and subset the object to only keep those cells\nsce.filt &lt;- sce.filt[, selected_mito & selected_ribo ]\ndim(sce.filt)\n\n[1] 18147  5896\n\n\nAs you can see, a large proportion of sample covid_15 is filtered out. Also, there is still quite a lot of variation in percent_mito, so it will have to be dealt with in the data analysis step. We can also notice that the percent_ribo are also highly variable, but that is expected since different cell types have different proportions of ribosomal content, according to their function.\n\n\n5.3 Plot filtered QC\nLets plot the same QC-stats another time.\n\nplot_grid(plotColData(sce,y = \"detected\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"total\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_mt_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_ribo_percent\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce,y = \"subsets_hb_percent\",x = \"sample\",colour_by = \"sample\"),ncol = 3)\n\n\n\n\n\n\n\n\n\n\n5.4 Filter genes\nAs the level of expression of mitochondrial and MALAT1 genes are judged as mainly technical, it can be wise to remove them from the dataset before any further analysis.\n\ndim(sce.filt)\n\n# Filter MALAT1\nsce.filt &lt;- sce.filt[ ! grepl(\"MALAT1\", rownames(sce.filt)), ]\n\n# Filter Mitocondrial\nsce.filt &lt;- sce.filt[ ! grepl(\"^MT-\", rownames(sce.filt)), ]\n\n# Filter Ribossomal gene (optional if that is a problem on your data)\n# sce.filt &lt;- sce.filt[ ! grepl(\"^RP[SL]\", rownames(sce.filt)), ]\n\n# Filter Hemoglobin gene\nsce.filt &lt;- sce.filt[ ! grepl(\"^HB[^(P)]\", rownames(sce.filt)), ]\n\ndim(sce.filt)\n\n[1] 18147  5896\n[1] 18121  5896"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_sex",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_sex",
    "title": " Quality Control",
    "section": "6 Sample sex",
    "text": "6 Sample sex\nWhen working with human or animal samples, you should ideally constrain you experiments to a single sex to avoid including sex bias in the conclusions. However this may not always be possible. By looking at reads from chromosomeY (males) and XIST (X-inactive specific transcript) expression (mainly female) it is quite easy to determine per sample which sex it is. It can also bee a good way to detect if there has been any sample mixups, if the sample metadata sex does not agree with the computational predictions.\nTo get chromosome information for all genes, you should ideally parse the information from the gtf file that you used in the mapping pipeline as it has the exact same annotation version/gene naming. However, it may not always be available, as in this case where we have downloaded public data. Hence, we will use biomart to fetch chromosome information. As the biomart instances quite often are unresponsive, you can try the code below, but if it fails, we have the file with gene annotations on github here. Make sure you put it at the correct location for the path genes.file to work.\n\ngenes.file = \"data/results/genes.table.csv\"\n\nif (!file.exists(genes.file)){\n  suppressMessages(require(biomaRt))\n\n  # initialize connection to mart, may take some time if the sites are unresponsive.\n  mart &lt;- useMart(\"ENSEMBL_MART_ENSEMBL\", dataset=\"hsapiens_gene_ensembl\")\n\n  # fetch chromosome info plus some other annotations\n  genes.table &lt;- try(biomaRt::getBM(attributes = c(\"ensembl_gene_id\",\n              \"external_gene_name\", \"description\",\"gene_biotype\", \"chromosome_name\",\"start_position\"),\n              mart = mart, useCache = F))\n\n  if(!dir.exists(\"data/results\")){dir.create(\"data/results\")}\n  if(is.data.frame(genes.table)){write.csv(genes.table, file = genes.file)}\n\n  if (!file.exists(genes.file)){\n  download.file(\"https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/labs/misc/genes.table.csv\",destfile = \"data/results/genes.table.csv\")\n    genes.table = read.csv(genes.file)\n    }\n}else{\n  genes.table = read.csv(genes.file)\n}\n\ngenes.table &lt;- genes.table[genes.table$external_gene_name %in% rownames(sce.filt),]\n\nNow that we have the chromosome information, we can calculate per cell the proportion of reads that comes from chromosome Y.\n\nchrY.gene = genes.table$external_gene_name[genes.table$chromosome_name == \"Y\"]\nsce.filt@colData$pct_chrY  = Matrix::colSums(counts(sce.filt)[chrY.gene,]) / colSums(counts(sce.filt))\n\nThen plot XIST expression vs chrY proportion. As you can see, the samples are clearly on either side, even if some cells do not have detection of either.\n\n# as plotColData cannot take an expression vs metadata, we need to add in XIST expression to colData\nsce.filt@colData$XIST = counts(sce.filt)[\"XIST\",] /  colSums(counts(sce.filt)) * 10000\nplotColData(sce.filt,  \"XIST\",  \"pct_chrY\")\n\n\n\n\n\n\n\n\nPlot as violins.\n\nplot_grid(plotColData(sce.filt, y = \"XIST\", x = \"sample\", colour_by = \"sample\"),\n          plotColData(sce.filt, y = \"pct_chrY\", x = \"sample\", colour_by = \"sample\"),  ncol = 2)\n\n\n\n\n\n\n\n\nHere, we can see clearly that we have two males and 4 females, can you see which samples they are? Do you think this will cause any problems for downstream analysis? Discuss with your group: what would be the best way to deal with this type of sex bias?"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_cellcycle",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_cellcycle",
    "title": " Quality Control",
    "section": "7 Cell cycle state",
    "text": "7 Cell cycle state\nWe here perform cell cycle scoring. To score a gene list, the algorithm calculates the difference of mean expression of the given list and the mean expression of reference genes. To build the reference, the function randomly chooses a bunch of genes matching the distribution of the expression of the given list. Cell cycle scoring adds three slots in data, a score for S phase, a score for G2M phase and the predicted cell cycle phase.\n\nhs.pairs &lt;- readRDS(system.file(\"exdata\", \"human_cycle_markers.rds\", package=\"scran\"))\nanno &lt;- select(org.Hs.eg.db, keys=rownames(sce.filt), keytype=\"SYMBOL\", column=\"ENSEMBL\")\nensembl &lt;- anno$ENSEMBL[match(rownames(sce.filt), anno$SYMBOL)]\n\n#Use only genes related to biological process cell cycle to speed up\n#https://www.ebi.ac.uk/QuickGO/term/GO:0007049 = cell cycle (BP,Biological Process)\nGOs &lt;- na.omit(select(org.Hs.eg.db, keys=na.omit(ensembl), keytype=\"ENSEMBL\", column=\"GO\"))\nGOs &lt;- GOs[GOs$GO == \"GO:0007049\",\"ENSEMBL\"]\nhs.pairs &lt;- lapply(hs.pairs,function(x){ x[rowSums( apply(x, 2, function(i) i %in% GOs)) &gt;= 1,]})\nstr(hs.pairs)\ncc.ensembl &lt;- ensembl[ensembl %in% GOs] #This is the fastest (less genes), but less accurate too\n#cc.ensembl &lt;- ensembl[ ensembl %in% unique(unlist(hs.pairs))]\n\nassignments &lt;- cyclone(sce.filt[ensembl %in% cc.ensembl,], hs.pairs, gene.names= ensembl[ ensembl %in% cc.ensembl])\nsce.filt$G1.score &lt;- assignments$scores$G1\nsce.filt$G2M.score &lt;- assignments$scores$G2M\nsce.filt$S.score &lt;- assignments$scores$S\n\nList of 3\n $ G1 :'data.frame':    6860 obs. of  2 variables:\n  ..$ first : chr [1:6860] \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" ...\n  ..$ second: chr [1:6860] \"ENSG00000065135\" \"ENSG00000080345\" \"ENSG00000101266\" \"ENSG00000124486\" ...\n $ S  :'data.frame':    8794 obs. of  2 variables:\n  ..$ first : chr [1:8794] \"ENSG00000255302\" \"ENSG00000119969\" \"ENSG00000179051\" \"ENSG00000127586\" ...\n  ..$ second: chr [1:8794] \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000100519\" \"ENSG00000136856\" ...\n $ G2M:'data.frame':    6796 obs. of  2 variables:\n  ..$ first : chr [1:6796] \"ENSG00000100519\" \"ENSG00000136856\" \"ENSG00000136856\" \"ENSG00000136856\" ...\n  ..$ second: chr [1:6796] \"ENSG00000146457\" \"ENSG00000007968\" \"ENSG00000227268\" \"ENSG00000101265\" ...\n\n\nWe can now plot a violin plot for the cell cycle scores as well.\n\nplot_grid(plotColData(sce.filt,y = \"G2M.score\",x = \"G1.score\",colour_by = \"sample\"),\n          plotColData(sce.filt,y = \"G2M.score\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce.filt,y = \"G1.score\",x = \"sample\",colour_by = \"sample\"),\n          plotColData(sce.filt,y = \"S.score\",x = \"sample\",colour_by = \"sample\"),ncol = 4)\n\n\n\n\n\n\n\n\nCyclone predicts most cells as G1, but also quite a lot of cells with high S-Phase scores. Compare to results with Seurat and Scanpy and see how different predictors will give clearly different results."
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_doublet",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_doublet",
    "title": " Quality Control",
    "section": "8 Predict doublets",
    "text": "8 Predict doublets\nDoublets/Multiples of cells in the same well/droplet is a common issue in scRNAseq protocols. Especially in droplet-based methods with overloading of cells. In a typical 10x experiment the proportion of doublets is linearly dependent on the amount of loaded cells. As indicated from the Chromium user guide, doublet rates are about as follows:\n\nMost doublet detectors simulates doublets by merging cell counts and predicts doublets as cells that have similar embeddings as the simulated doublets. Most such packages need an assumption about the number/proportion of expected doublets in the dataset. The data you are using is subsampled, but the original datasets contained about 5 000 cells per sample, hence we can assume that they loaded about 9 000 cells and should have a doublet rate at about 4%.\n\n\n\n\n\n\nCaution\n\n\n\nIdeally doublet prediction should be run on each sample separately, especially if your different samples have different proportions of cell types. In this case, the data is subsampled so we have very few cells per sample and all samples are sorted PBMCs so it is okay to run them together.\n\n\nThere is a method to predict if a cluster consists of mainly doublets findDoubletClusters(), but we can also predict individual cells based on simulations using the function computeDoubletDensity() which we will do here. Doublet detection will be performed using PCA, so we need to first normalize the data and run variable gene detection, as well as UMAP for visualization. These steps will be explored in more detail in coming exercises.\n\nsce.filt &lt;- logNormCounts(sce.filt)\ndec &lt;- modelGeneVar(sce.filt, block = sce.filt$sample)\nhvgs = getTopHVGs(dec, n=2000)\n\nsce.filt &lt;- runPCA(sce.filt, subset_row=hvgs)\n\nsce.filt &lt;- runUMAP(sce.filt, pca = 10)\n\n\nsuppressPackageStartupMessages(require(scDblFinder))\n\n# run computeDoubletDensity with 10 principal components.\nsce.filt &lt;- scDblFinder(sce.filt, dims = 10)\n\n\nplot_grid(plotUMAP(sce.filt, colour_by=\"scDblFinder.score\"),\n          plotUMAP(sce.filt, colour_by=\"scDblFinder.class\"),\n          plotUMAP(sce.filt, colour_by=\"sample\"), ncol = 3)\n\n\n\n\n\n\n\n\nNow, lets remove all predicted doublets from our data.\n\nsce.filt = sce.filt[,sce.filt$scDblFinder.score &lt; 2]\ndim(sce.filt)\n\n[1] 18121  5896"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-qc_save",
    "href": "labs/bioc/bioc_01_qc.html#meta-qc_save",
    "title": " Quality Control",
    "section": "9 Save data",
    "text": "9 Save data\nFinally, lets save the QC-filtered data for further analysis. Create output directory results and save data to that folder. This will be used in downstream labs.\n\nif (!dir.exists(\"data/results\")) dir.create(\"data/results\", showWarnings = F)\nif (!file.exists(\"data/results/covid_qc.rds\")) saveRDS(sce.filt, \"data/results/covid_qc.rds\")"
  },
  {
    "objectID": "labs/bioc/bioc_01_qc.html#meta-session",
    "href": "labs/bioc/bioc_01_qc.html#meta-session",
    "title": " Quality Control",
    "section": "10 Session info",
    "text": "10 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] scDblFinder_1.12.0          DoubletFinder_2.0.3        \n [3] org.Hs.eg.db_3.16.0         AnnotationDbi_1.60.2       \n [5] cowplot_1.1.1               scran_1.26.2               \n [7] scater_1.26.1               ggplot2_3.4.2              \n [9] scuttle_1.8.4               SingleCellExperiment_1.20.1\n[11] SummarizedExperiment_1.28.0 Biobase_2.58.0             \n[13] GenomicRanges_1.50.2        GenomeInfoDb_1.34.9        \n[15] IRanges_2.32.0              S4Vectors_0.36.2           \n[17] BiocGenerics_0.44.0         MatrixGenerics_1.10.0      \n[19] matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n  [1] utf8_1.2.3                spatstat.explore_3.2-1   \n  [3] reticulate_1.30           tidyselect_1.2.0         \n  [5] RSQLite_2.3.1             htmlwidgets_1.6.2        \n  [7] grid_4.2.3                BiocParallel_1.32.6      \n  [9] Rtsne_0.16                munsell_0.5.0            \n [11] ScaledMatrix_1.6.0        codetools_0.2-19         \n [13] ica_1.0-3                 xgboost_1.7.5.1          \n [15] statmod_1.5.0             future_1.33.0            \n [17] miniUI_0.1.1.1            withr_2.5.0              \n [19] spatstat.random_3.1-5     colorspace_2.1-0         \n [21] progressr_0.13.0          knitr_1.43               \n [23] rstudioapi_0.14           Seurat_4.3.0.1           \n [25] ROCR_1.0-11               tensor_1.5               \n [27] listenv_0.9.0             labeling_0.4.2           \n [29] GenomeInfoDbData_1.2.9    polyclip_1.10-4          \n [31] bit64_4.0.5               farver_2.1.1             \n [33] parallelly_1.36.0         vctrs_0.6.3              \n [35] generics_0.1.3            xfun_0.39                \n [37] R6_2.5.1                  ggbeeswarm_0.7.2         \n [39] rsvd_1.0.5                locfit_1.5-9.8           \n [41] hdf5r_1.3.8               bitops_1.0-7             \n [43] spatstat.utils_3.0-3      cachem_1.0.8             \n [45] DelayedArray_0.24.0       promises_1.2.0.1         \n [47] BiocIO_1.8.0              scales_1.2.1             \n [49] beeswarm_0.4.0            gtable_0.3.3             \n [51] beachmat_2.14.2           globals_0.16.2           \n [53] goftest_1.2-3             rlang_1.1.1              \n [55] splines_4.2.3             rtracklayer_1.58.0       \n [57] lazyeval_0.2.2            spatstat.geom_3.2-1      \n [59] yaml_2.3.7                reshape2_1.4.4           \n [61] abind_1.4-5               httpuv_1.6.11            \n [63] tools_4.2.3               ellipsis_0.3.2           \n [65] RColorBrewer_1.1-3        ggridges_0.5.4           \n [67] Rcpp_1.0.10               plyr_1.8.8               \n [69] sparseMatrixStats_1.10.0  zlibbioc_1.44.0          \n [71] purrr_1.0.1               RCurl_1.98-1.12          \n [73] deldir_1.0-9              pbapply_1.7-2            \n [75] viridis_0.6.3             zoo_1.8-12               \n [77] SeuratObject_4.1.3        ggrepel_0.9.3            \n [79] cluster_2.1.4             magrittr_2.0.3           \n [81] data.table_1.14.8         scattermore_1.2          \n [83] lmtest_0.9-40             RANN_2.6.1               \n [85] fitdistrplus_1.1-11       patchwork_1.1.2          \n [87] mime_0.12                 evaluate_0.21            \n [89] xtable_1.8-4              XML_3.99-0.14            \n [91] gridExtra_2.3             compiler_4.2.3           \n [93] tibble_3.2.1              KernSmooth_2.23-20       \n [95] crayon_1.5.2              htmltools_0.5.5          \n [97] later_1.3.1               tidyr_1.3.0              \n [99] DBI_1.1.3                 MASS_7.3-58.2            \n[101] Matrix_1.6-0              cli_3.6.1                \n[103] parallel_4.2.3            metapod_1.6.0            \n[105] igraph_1.5.0              pkgconfig_2.0.3          \n[107] GenomicAlignments_1.34.1  sp_2.0-0                 \n[109] plotly_4.10.2             spatstat.sparse_3.0-2    \n[111] vipor_0.4.5               dqrng_0.3.0              \n[113] XVector_0.38.0            stringr_1.5.0            \n[115] digest_0.6.33             sctransform_0.3.5        \n[117] RcppAnnoy_0.0.21          spatstat.data_3.0-1      \n[119] Biostrings_2.66.0         rmarkdown_2.21           \n[121] leiden_0.4.3              uwot_0.1.16              \n[123] edgeR_3.40.2              DelayedMatrixStats_1.20.0\n[125] restfulr_0.0.15           shiny_1.7.4              \n[127] Rsamtools_2.14.0          rjson_0.2.21             \n[129] lifecycle_1.0.3           nlme_3.1-162             \n[131] jsonlite_1.8.7            BiocNeighbors_1.16.0     \n[133] viridisLite_0.4.2         limma_3.54.2             \n[135] fansi_1.0.4               pillar_1.9.0             \n[137] lattice_0.20-45           KEGGREST_1.38.0          \n[139] fastmap_1.1.1             httr_1.4.6               \n[141] survival_3.5-3            glue_1.6.2               \n[143] png_0.1-8                 bluster_1.8.0            \n[145] bit_4.0.5                 stringi_1.7.12           \n[147] blob_1.2.4                BiocSingular_1.14.0      \n[149] memoise_2.0.1             dplyr_1.1.1              \n[151] irlba_2.3.5.1             future.apply_1.11.0"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html",
    "href": "labs/scanpy/scanpy_01_qc.html",
    "title": " Quality Control",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run Python commands unless it starts with %%bash, in which case, those chunks run shell commands."
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_data",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_data",
    "title": " Quality Control",
    "section": "1 Get data",
    "text": "1 Get data\nIn this tutorial, we will run all tutorials with a set of 6 PBMC 10x datasets from 3 covid-19 patients and 3 healthy controls, the samples have been subsampled to 1500 cells per sample. They are part of the github repo and if you have cloned the repo they should be available in folder: labs/data/covid_data_GSE149689. Instructions on how to download them can also be found in the Precourse material.\n\n%%bash\n\nif [ ! -d \"data/raw\" ] \nthen\n  # create a data directory.\n  mkdir -p data/raw\n\n  # first check if the files are there\n  count=$(ls -l data/raw/*.h5 | grep -v ^d | wc -l )\n  echo $count\n\n  # if not 4 files, fetch the files from github.\n  if ((\"$count\" &lt;  6)); then\n    cd data/raw\n    curl -O https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/Normal_PBMC_13.h5\n    curl -O https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/Normal_PBMC_14.h5\n    curl -O https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/Normal_PBMC_5.h5\n    curl -O https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/nCoV_PBMC_15.h5\n    curl -O https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/nCoV_PBMC_17.h5\n    curl -O https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/new_dataset/labs/data/covid_data_GSE149689/sub/nCoV_PBMC_1.h5\n    cd ../..\n  fi\nfi\n\nls -lGa data/raw\n\ntotal 22188\ndrwxr-xr-x  8 root         256 Oct  9 15:23 .\ndrwxr-xr-x 11 root         352 Nov  3 11:11 ..\n-rw-r--r--  1 royfr474 3169573 Oct  9 15:23 nCoV_PBMC_15.h5\n-rw-r--r--  1 royfr474 4105636 Oct  9 15:23 nCoV_PBMC_17.h5\n-rw-r--r--  1 royfr474 3426598 Oct  9 15:23 nCoV_PBMC_1.h5\n-rw-r--r--  1 royfr474 4391693 Oct  9 15:23 Normal_PBMC_13.h5\n-rw-r--r--  1 royfr474 3806925 Oct  9 15:23 Normal_PBMC_14.h5\n-rw-r--r--  1 royfr474 3806384 Oct  9 15:23 Normal_PBMC_5.h5\n\n\nWith data in place, now we can start loading libraries we will use in this tutorial.\n\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3\nsc.settings.set_figure_params(dpi=80)\n\nWe can first load the data individually by reading directly from HDF5 file format (.h5).\n\ndata_cov1 = sc.read_10x_h5('./data/raw/nCoV_PBMC_1.h5')\ndata_cov1.var_names_make_unique()\ndata_cov15 = sc.read_10x_h5('./data/raw/nCoV_PBMC_15.h5')\ndata_cov15.var_names_make_unique()\ndata_cov17 = sc.read_10x_h5('./data/raw/nCoV_PBMC_17.h5')\ndata_cov17.var_names_make_unique()\ndata_ctrl5 = sc.read_10x_h5('./data/raw/Normal_PBMC_5.h5')\ndata_ctrl5.var_names_make_unique()\ndata_ctrl13 = sc.read_10x_h5('./data/raw/Normal_PBMC_13.h5')\ndata_ctrl13.var_names_make_unique()\ndata_ctrl14 = sc.read_10x_h5('./data/raw/Normal_PBMC_14.h5')\ndata_ctrl14.var_names_make_unique()"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_collate",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_collate",
    "title": " Quality Control",
    "section": "2 Collate",
    "text": "2 Collate\n\n# add some metadata\ndata_cov1.obs['type']=\"Covid\"\ndata_cov1.obs['sample']=\"covid_1\"\ndata_cov15.obs['type']=\"Covid\"\ndata_cov15.obs['sample']=\"covid_15\"\ndata_cov17.obs['type']=\"Covid\"\ndata_cov17.obs['sample']=\"covid_17\"\ndata_ctrl5.obs['type']=\"Ctrl\"\ndata_ctrl5.obs['sample']=\"ctrl_5\"\ndata_ctrl13.obs['type']=\"Ctrl\"\ndata_ctrl13.obs['sample']=\"ctrl_13\"\ndata_ctrl14.obs['type']=\"Ctrl\"\ndata_ctrl14.obs['sample']=\"ctrl_14\"\n\n# merge into one object.\nadata = data_cov1.concatenate(data_cov15, data_cov17, data_ctrl5, data_ctrl13, data_ctrl14)\n\n# and delete individual datasets to save space\ndel(data_cov1, data_cov15, data_cov17)\ndel(data_ctrl5, data_ctrl13, data_ctrl14)\n\nYou can print a summary of the datasets in the Scanpy object, or a summary of the whole object.\n\nprint(adata.obs['sample'].value_counts())\nadata\n\ncovid_1     1500\ncovid_15    1500\ncovid_17    1500\nctrl_5      1500\nctrl_13     1500\nctrl_14     1500\nName: sample, dtype: int64\n\n\nAnnData object with n_obs × n_vars = 9000 × 33538\n    obs: 'type', 'sample', 'batch'\n    var: 'gene_ids', 'feature_types', 'genome'"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_calqc",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_calqc",
    "title": " Quality Control",
    "section": "3 Calculate QC",
    "text": "3 Calculate QC\nHaving the data in a suitable format, we can start calculating some quality metrics. We can for example calculate the percentage of mitochondrial and ribosomal genes per cell and add to the metadata. The proportion hemoglobin genes can give an indication of red blood cell contamination. This will be helpful to visualize them across different metadata parameteres (i.e. datasetID and chemistry version). There are several ways of doing this. The QC metrics are finally added to the metadata table.\nCiting from Simple Single Cell workflows (Lun, McCarthy & Marioni, 2017): High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmic RNA from perforated cells. The reasoning is that mitochondria are larger than individual transcript molecules and less likely to escape through tears in the cell membrane.\nFirst, let Scanpy calculate some general qc-stats for genes and cells with the function sc.pp.calculate_qc_metrics, similar to calculateQCmetrics() in Scater. It can also calculate proportion of counts for specific gene populations, so first we need to define which genes are mitochondrial, ribosomal and hemoglobin.\n\n# mitochondrial genes\nadata.var['mt'] = adata.var_names.str.startswith('MT-') \n# ribosomal genes\nadata.var['ribo'] = adata.var_names.str.startswith((\"RPS\",\"RPL\"))\n# hemoglobin genes.\nadata.var['hb'] = adata.var_names.str.contains((\"^HB[^(P)]\"))\n\nadata.var\n\n\n\n\n\n\n\n\ngene_ids\nfeature_types\ngenome\nmt\nribo\nhb\n\n\n\n\nMIR1302-2HG\nENSG00000243485\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nFAM138A\nENSG00000237613\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nOR4F5\nENSG00000186092\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nAL627309.1\nENSG00000238009\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nAL627309.3\nENSG00000239945\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\nAC233755.2\nENSG00000277856\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nAC233755.1\nENSG00000275063\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nAC240274.1\nENSG00000271254\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nAC213203.1\nENSG00000277475\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\nFAM231C\nENSG00000268674\nGene Expression\nGRCh38\nFalse\nFalse\nFalse\n\n\n\n\n33538 rows × 6 columns\n\n\n\n\nsc.pp.calculate_qc_metrics(adata, qc_vars=['mt','ribo','hb'], percent_top=None, log1p=False, inplace=True)\n\nNow you can see that we have additional data in the metadata slot.\n\nmito_genes = adata.var_names.str.startswith('MT-')\n# for each cell compute fraction of counts in mito genes vs. all genes\n# the `.A1` is only necessary as X is sparse (to transform to a dense array after summing)\nadata.obs['percent_mt2'] = np.sum(\n    adata[:, mito_genes].X, axis=1).A1 / np.sum(adata.X, axis=1).A1\n# add the total counts per cell as observations-annotation to adata\nadata.obs['n_counts'] = adata.X.sum(axis=1).A1\n\nadata\n\nAnnData object with n_obs × n_vars = 9000 × 33538\n    obs: 'type', 'sample', 'batch', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'percent_mt2', 'n_counts'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts'"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_plotqc",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_plotqc",
    "title": " Quality Control",
    "section": "4 Plot QC",
    "text": "4 Plot QC\nNow we can plot some of the QC variables as violin plots.\n\nsc.pl.violin(adata, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt','pct_counts_ribo', 'pct_counts_hb'], jitter=0.4, groupby = 'sample', rotation= 45)\n\n\n\n\n\n\n\n\nAs you can see, there is quite some difference in quality for the 4 datasets, with for instance the covid_15 sample having fewer cells with many detected genes and more mitochondrial content. As the ribosomal proteins are highly expressed they will make up a larger proportion of the transcriptional landscape when fewer of the lowly expressed genes are detected. And we can plot the different QC-measures as scatter plots.\n\nsc.pl.scatter(adata, x='total_counts', y='pct_counts_mt', color=\"sample\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nPlot additional QC stats that we have calculated as scatter plots. How are the different measures correlated? Can you explain why?"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_filter",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_filter",
    "title": " Quality Control",
    "section": "5 Filtering",
    "text": "5 Filtering\n\n5.1 Detection-based filtering\nA standard approach is to filter cells with low amount of reads as well as genes that are present in at least a certain amount of cells. Here we will only consider cells with at least 200 detected genes and genes need to be expressed in at least 3 cells. Please note that those values are highly dependent on the library preparation method used.\n\nsc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_genes(adata, min_cells=3)\n\nprint(adata.n_obs, adata.n_vars)\n\n7979 18778\n\n\nExtremely high number of detected genes could indicate doublets. However, depending on the cell type composition in your sample, you may have cells with higher number of genes (and also higher counts) from one cell type. In this case, we will run doublet prediction further down, so we will skip this step now, but the code below is an example of how it can be run:\n\n# skip for now as we are doing doublet prediction\n#keep_v2 = (adata.obs['n_genes_by_counts'] &lt; 2000) & (adata.obs['n_genes_by_counts'] &gt; 500) & (adata.obs['lib_prep'] == 'v2')\n#print(sum(keep_v2))\n\n# filter for gene detection for v3\n#keep_v3 = (adata.obs['n_genes_by_counts'] &lt; 4100) & (adata.obs['n_genes_by_counts'] &gt; 1000) & (adata.obs['lib_prep'] != 'v2')\n#print(sum(keep_v3))\n\n# keep both sets of cells\n#keep = (keep_v2) | (keep_v3)\n#print(sum(keep))\n#adata = adata[keep, :]\n\n#print(\"Remaining cells %d\"%adata.n_obs)\n\nAdditionally, we can also see which genes contribute the most to such reads. We can for instance plot the percentage of counts per gene.\n\nsc.pl.highest_expr_genes(adata, n_top=20)\n\n\n\n\n\n\n\n\nAs you can see, MALAT1 constitutes up to 30% of the UMIs from a single cell and the other top genes are mitochondrial and ribosomal genes. It is quite common that nuclear lincRNAs have correlation with quality and mitochondrial reads, so high detection of MALAT1 may be a technical issue. Let us assemble some information about such genes, which are important for quality control and downstream filtering.\n\n\n5.2 Mito/Ribo filtering\nWe also have quite a lot of cells with high proportion of mitochondrial and low proportion of ribosomal reads. It could be wise to remove those cells, if we have enough cells left after filtering. Another option would be to either remove all mitochondrial reads from the dataset and hope that the remaining genes still have enough biological signal. A third option would be to just regress out the percent_mito variable during scaling. In this case we had as much as 99.7% mitochondrial reads in some of the cells, so it is quite unlikely that there is much cell type signature left in those. Looking at the plots, make reasonable decisions on where to draw the cutoff. In this case, the bulk of the cells are below 20% mitochondrial reads and that will be used as a cutoff. We will also remove cells with less than 5% ribosomal reads.\n\n# filter for percent mito\nadata = adata[adata.obs['pct_counts_mt'] &lt; 20, :]\n\n# filter for percent ribo &gt; 0.05\nadata = adata[adata.obs['pct_counts_ribo'] &gt; 5, :]\n\nprint(\"Remaining cells %d\"%adata.n_obs)\n\nRemaining cells 5762\n\n\nAs you can see, a large proportion of sample covid_15 is filtered out. Also, there is still quite a lot of variation in percent_mito, so it will have to be dealt with in the data analysis step. We can also notice that the percent_ribo are also highly variable, but that is expected since different cell types have different proportions of ribosomal content, according to their function.\n\n\n5.3 Plot filtered QC\nLets plot the same QC-stats another time.\n\nsc.pl.violin(adata, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt','pct_counts_ribo', 'pct_counts_hb'], jitter=0.4, groupby = 'sample', rotation = 45)\n\n\n\n\n\n\n\n\n\n\n5.4 Filter genes\nAs the level of expression of mitochondrial and MALAT1 genes are judged as mainly technical, it can be wise to remove them from the dataset before any further analysis.\n\nmalat1 = adata.var_names.str.startswith('MALAT1')\n# we need to redefine the mito_genes since they were first \n# calculated on the full object before removing low expressed genes.\nmito_genes = adata.var_names.str.startswith('MT-')\nhb_genes = adata.var_names.str.contains('^HB[^(P)]')\n\nremove = np.add(mito_genes, malat1)\nremove = np.add(remove, hb_genes)\nkeep = np.invert(remove)\n\nadata = adata[:,keep]\n\nprint(adata.n_obs, adata.n_vars)\n\n5762 18752"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_sex",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_sex",
    "title": " Quality Control",
    "section": "6 Sample sex",
    "text": "6 Sample sex\nWhen working with human or animal samples, you should ideally constrain you experiments to a single sex to avoid including sex bias in the conclusions. However this may not always be possible. By looking at reads from chromosomeY (males) and XIST (X-inactive specific transcript) expression (mainly female) it is quite easy to determine per sample which sex it is. It can also bee a good way to detect if there has been any sample mixups, if the sample metadata sex does not agree with the computational predictions.\nTo get choromosome information for all genes, you should ideally parse the information from the gtf file that you used in the mapping pipeline as it has the exact same annotation version/gene naming. However, it may not always be available, as in this case where we have downloaded public data. Hence, we will use biomart to fetch chromosome information.\n\n# requires pybiomart\nannot = sc.queries.biomart_annotations(\"hsapiens\", [\"ensembl_gene_id\", \"external_gene_name\", \"start_position\", \"end_position\", \"chromosome_name\"], ).set_index(\"external_gene_name\")\n# adata.var[annot.columns] = annot\n\nNow that we have the chromosome information, we can calculate per cell the proportion of reads that comes from chromosome Y.\n\nchrY_genes = adata.var_names.intersection(annot.index[annot.chromosome_name == \"Y\"])\nchrY_genes\n\nadata.obs['percent_chrY'] = np.sum(\n    adata[:, chrY_genes].X, axis=1).A1 / np.sum(adata.X, axis=1).A1 * 100\n\nThen plot XIST expression vs chrY proportion. As you can see, the samples are clearly on either side, even if some cells do not have detection of either.\n\n# color inputs must be from either .obs or .var, so add in XIST expression to obs.\nadata.obs[\"XIST-counts\"] = adata.X[:,adata.var_names.str.match('XIST')].toarray()\n\nsc.pl.scatter(adata, x='XIST-counts', y='percent_chrY', color=\"sample\")\n\n\n\n\n\n\n\n\nPlot as violins.\n\nsc.pl.violin(adata, [\"XIST-counts\", \"percent_chrY\"], jitter=0.4, groupby = 'sample', rotation= 45)\n\n\n\n\n\n\n\n\nHere, we can see clearly that we have two males and 4 females, can you see which samples they are? Do you think this will cause any problems for downstream analysis? Discuss with your group: what would be the best way to deal with this type of sex bias?"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_cellcycle",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_cellcycle",
    "title": " Quality Control",
    "section": "7 Cell cycle state",
    "text": "7 Cell cycle state\nWe here perform cell cycle scoring. To score a gene list, the algorithm calculates the difference of mean expression of the given list and the mean expression of reference genes. To build the reference, the function randomly chooses a bunch of genes matching the distribution of the expression of the given list. Cell cycle scoring adds three slots in data, a score for S phase, a score for G2M phase and the predicted cell cycle phase.\nFirst read the file with cell cycle genes, from Regev lab and split into S and G2M phase genes. Cell cycle genes were retrieved from the scanpy_usage github site via web browser at RegevLab Github repo.\n\n%%bash\nif [ ! -f data/regev_lab_cell_cycle_genes.txt ]; then curl -o data/regev_lab_cell_cycle_genes.txt https://raw.githubusercontent.com/theislab/scanpy_usage/master/180209_cell_cycle/data/regev_lab_cell_cycle_genes.txt; fi\n\n\ncell_cycle_genes = [x.strip() for x in open('./data/regev_lab_cell_cycle_genes.txt')]\nprint(len(cell_cycle_genes))\n\n# Split into 2 lists\ns_genes = cell_cycle_genes[:43]\ng2m_genes = cell_cycle_genes[43:]\n\ncell_cycle_genes = [x for x in cell_cycle_genes if x in adata.var_names]\nprint(len(cell_cycle_genes))\n\n97\n94\n\n\nBefore running cell cycle we have to normalize the data. In the scanpy object, the data slot will be overwritten with the normalized data. So first, save the raw data into the slot raw. Then run normalization, log transformation and scale the data.\n\n# save normalized counts in raw slot.\nadata.raw = adata\n\n# normalize to depth 10 000\nsc.pp.normalize_per_cell(adata, counts_per_cell_after=1e4)\n\n# logaritmize\nsc.pp.log1p(adata)\n\n# scale\nsc.pp.scale(adata)\n\nWe here perform cell cycle scoring. The function is actually a wrapper to sc.tl.score_gene_list, which is launched twice, to score separately S and G2M phases. Both sc.tl.score_gene_list and sc.tl.score_cell_cycle_genes are a port from Seurat and are supposed to work in a very similar way. To score a gene list, the algorithm calculates the difference of mean expression of the given list and the mean expression of reference genes. To build the reference, the function randomly chooses a bunch of genes matching the distribution of the expression of the given list. Cell cycle scoring adds three slots in data, a score for S phase, a score for G2M phase and the predicted cell cycle phase.\n\nsc.tl.score_genes_cell_cycle(adata, s_genes=s_genes, g2m_genes=g2m_genes)\n\nWe can now plot a violin plot for the cell cycle scores as well.\n\nsc.pl.violin(adata, ['S_score', 'G2M_score'], jitter=0.4, groupby = 'sample', rotation=45)\n\n\n\n\n\n\n\n\nIn this case it looks like we only have a few cycling cells in the datasets."
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_doublet",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_doublet",
    "title": " Quality Control",
    "section": "8 Predict doublets",
    "text": "8 Predict doublets\nDoublets/Multiples of cells in the same well/droplet is a common issue in scRNAseq protocols. Especially in droplet-based methods with overloading of cells. In a typical 10x experiment the proportion of doublets is linearly dependent on the amount of loaded cells. As indicated from the Chromium user guide, doublet rates are about as follows:\n\nMost doublet detectors simulates doublets by merging cell counts and predicts doublets as cells that have similar embeddings as the simulated doublets. Most such packages need an assumption about the number/proportion of expected doublets in the dataset. The data you are using is subsampled, but the original datasets contained about 5 000 cells per sample, hence we can assume that they loaded about 9 000 cells and should have a doublet rate at about 4%.\n\n\n\n\n\n\nCaution\n\n\n\nIdeally doublet prediction should be run on each sample separately, especially if your different samples have different proportions of cell types. In this case, the data is subsampled so we have very few cells per sample and all samples are sorted PBMCs so it is okay to run them together.\n\n\nFor doublet detection, we will use the package Scrublet, so first we need to get the raw counts from adata.raw.X and run scrublet with that matrix. Then we add in the doublet prediction info into our anndata object.\nDoublet prediction should be run for each dataset separately, so first we need to split the adata object into 6 separate objects, one per sample and then run scrublet on each of them.\n\nimport scrublet as scr\n\n# split per batch into new objects.\nbatches = adata.obs['sample'].cat.categories.tolist()\nalldata = {}\nfor batch in batches:\n    tmp = adata[adata.obs['sample'] == batch,]\n    print(batch, \":\", tmp.shape[0], \" cells\")\n    scrub = scr.Scrublet(tmp.raw.X)\n    out = scrub.scrub_doublets(verbose=False, n_prin_comps = 20)\n    alldata[batch] = pd.DataFrame({'doublet_score':out[0],'predicted_doublets':out[1]},index = tmp.obs.index)\n    print(alldata[batch].predicted_doublets.sum(), \" predicted_doublets\")\n\ncovid_1 : 878  cells\n34  predicted_doublets\ncovid_15 : 585  cells\n2  predicted_doublets\ncovid_17 : 1042  cells\n24  predicted_doublets\nctrl_5 : 1040  cells\n12  predicted_doublets\nctrl_13 : 1154  cells\n22  predicted_doublets\nctrl_14 : 1063  cells\n22  predicted_doublets\n\n\n\n# add predictions to the adata object.\nscrub_pred = pd.concat(alldata.values())\nadata.obs['doublet_scores'] = scrub_pred['doublet_score'] \nadata.obs['predicted_doublets'] = scrub_pred['predicted_doublets'] \n\nsum(adata.obs['predicted_doublets'])\n\n116\n\n\nWe should expect that two cells have more detected genes than a single cell, lets check if our predicted doublets also have more detected genes in general.\n\n# add in column with singlet/doublet instead of True/Fals\n%matplotlib inline\n\nadata.obs['doublet_info'] = adata.obs[\"predicted_doublets\"].astype(str)\nsc.pl.violin(adata, 'n_genes_by_counts', jitter=0.4, groupby = 'doublet_info', rotation=45)\n\n\n\n\n\n\n\n\nNow, lets run PCA and UMAP and plot doublet scores onto UMAP to check the doublet predictions.\n\nsc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)\nadata = adata[:, adata.var.highly_variable]\nsc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt'])\nsc.pp.scale(adata, max_value=10)\nsc.tl.pca(adata, svd_solver='arpack')\nsc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)\nsc.tl.umap(adata)\nsc.pl.umap(adata, color=['doublet_scores','doublet_info','sample'])\n\n\n\n\n\n\n\n\nNow, lets remove all predicted doublets from our data.\n\n# also revert back to the raw counts as the main matrix in adata\nadata = adata.raw.to_adata() \n\nadata = adata[adata.obs['doublet_info'] == 'False',:]\nprint(adata.shape)\n\n(5646, 18752)"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-qc_save",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-qc_save",
    "title": " Quality Control",
    "section": "9 Save data",
    "text": "9 Save data\nFinally, lets save the QC-filtered data for further analysis. Create output directory results and save data to that folder. This will be used in downstream labs.\n\nimport os\nif not os.path.exists('data/results/'):\n    os.makedirs('data/results/', exist_ok=True)\nif not os.path.exists('data/results/scanpy_qc_filtered_covid.h5ad'):\n    adata.write_h5ad('data/results/scanpy_qc_filtered_covid.h5ad')"
  },
  {
    "objectID": "labs/scanpy/scanpy_01_qc.html#meta-session",
    "href": "labs/scanpy/scanpy_01_qc.html#meta-session",
    "title": " Quality Control",
    "section": "10 Session info",
    "text": "10 Session info\n\nsc.logging.print_versions()\n\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nannoy                       NA\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfqdn                        NA\nfuture                      0.18.3\nget_version                 3.5.4\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nipykernel                   6.25.2\nipywidgets                  8.1.1\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlazy_loader                 NA\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npatsy                       0.5.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\npooch                       v1.7.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npybiomart                   0.2.0\npycparser                   2.21\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npynndescent                 0.5.10\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrequests_cache              0.4.13\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanpy                      1.7.2\nscipy                       1.10.1\nscrublet                    NA\nseaborn                     0.12.2\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nskimage                     0.21.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nstack_data                  0.6.2\nstatsmodels                 0.14.0\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntqdm                        4.65.0\ntraitlets                   5.11.2\ntyping_extensions           NA\numap                        0.5.4\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-10 19:05"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html",
    "href": "labs/bioc/bioc_02_dimred.html",
    "title": " Dimensionality Reduction",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified."
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_prep",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_prep",
    "title": " Dimensionality Reduction",
    "section": "1 Data preparation",
    "text": "1 Data preparation\nFirst, let’s load all necessary libraries and the QC-filtered dataset from the previous step.\n\nsuppressPackageStartupMessages({\n  library(scater)\n  library(scran)\n  library(cowplot)\n  library(ggplot2)\n  library(rafalib)\n  library(umap)\n})\n\nsce &lt;- readRDS(\"data/results/covid_qc.rds\")"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_fs",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_fs",
    "title": " Dimensionality Reduction",
    "section": "2 Feature selection",
    "text": "2 Feature selection\nNext, we first need to define which features/genes are important in our dataset to distinguish cell types. For this purpose, we need to find genes that are highly variable across cells, which in turn will also provide a good separation of the cell clusters.\n\nsce &lt;- computeSumFactors(sce, sizes=c(20, 40, 60, 80))\nsce &lt;- logNormCounts(sce)\nvar.out &lt;- modelGeneVar(sce, method=\"loess\")\nhvgs = getTopHVGs(var.out, n=2000)\n\nmypar(1,2)\n#plot mean over TOTAL variance\n# Visualizing the fit:\nfit.var &lt;- metadata(var.out)\nplot(fit.var$mean, fit.var$var, xlab=\"Mean of log-expression\",\n    ylab=\"Variance of log-expression\")\ncurve(fit.var$trend(x), col=\"dodgerblue\", add=TRUE, lwd=2)\n\n#Select 1000 top variable genes\nhvg.out &lt;- getTopHVGs(var.out, n=1000)\n\n# highligt those cells in the plot\ncutoff &lt;- rownames(var.out) %in% hvg.out\npoints(fit.var$mean[cutoff], fit.var$var[cutoff], col=\"red\", pch=16,cex=.6)\n\n#plot mean over BIOLOGICAL variance\nplot(var.out$mean, var.out$bio, pch=16, cex=0.4, xlab=\"Mean log-expression\", ylab=\"Variance of log-expression\")\nlines(c(min(var.out$mean),max(var.out$mean)), c(0,0), col=\"dodgerblue\", lwd=2)\npoints(var.out$mean[cutoff], var.out$bio[cutoff], col=\"red\", pch=16,cex=.6)"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_zs",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_zs",
    "title": " Dimensionality Reduction",
    "section": "3 Z-score transformation",
    "text": "3 Z-score transformation\nNow that the data is prepared, we now proceed with PCA. Since each gene has a different expression level, it means that genes with higher expression values will naturally have higher variation that will be captured by PCA. This means that we need to somehow give each gene a similar weight when performing PCA (see below). The common practice is to center and scale each gene before performing PCA. This exact scaling is called Z-score normalization it is very useful for PCA, clustering and plotting heatmaps. Additionally, we can use regression to remove any unwanted sources of variation from the dataset, such as cell cycle, sequencing depth, percent mitochondria. This is achieved by doing a generalized linear regression using these parameters as co-variates in the model. Then the residuals of the model are taken as the regressed data. Although perhaps not in the best way, batch effect regression can also be done here. By default variables are scaled in the PCA step and is not done separately. But it could be achieved by running the commands below:\nHowever, unlike the Seurat, this step is implemented inside the PCA function below. Here we will show you how to add the scaledData back to the object.\n\n# sce@assays$data@listData$scaled.data &lt;- apply(exprs(sce)[rownames(hvg.out),,drop=FALSE],2,function(x) scale(x,T,T))\n# rownames(sce@assays$data@listData$scaled.data) &lt;- rownames(hvg.out)"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_pca",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_pca",
    "title": " Dimensionality Reduction",
    "section": "4 PCA",
    "text": "4 PCA\nPerforming PCA has many useful applications and interpretations, which much depends on the data used. In the case of life sciences, we want to segregate samples based on gene expression patterns in the data.\nWe use the logcounts and then set scale_features to TRUE in order to scale each gene.\n\n#runPCA and specify the variable genes to use for dim reduction with subset_row\nsce &lt;- runPCA(sce, exprs_values = \"logcounts\", ncomponents = 50, subset_row = hvg.out, scale = TRUE)\n\nWe then plot the first principal components.\n\nplot_grid(ncol = 3,\n  plotReducedDim(sce,dimred = \"PCA\",colour_by = \"sample\",ncomponents = 1:2,point_size = 0.6),\n  plotReducedDim(sce,dimred = \"PCA\",colour_by = \"sample\",ncomponents = 3:4,point_size = 0.6),\n  plotReducedDim(sce,dimred = \"PCA\",colour_by = \"sample\",ncomponents = 5:6,point_size = 0.6)\n)\n\n\n\n\n\n\n\n\nTo identify which genes (Seurat) or metadata parameters (Scater/Scran) contribute the most to each PC, one can retrieve the loading matrix information. Unfortunately, this is not implemented in Scater/Scran, so you will need to compute PCA using logcounts.\n\nplot_grid(ncol = 2, plotExplanatoryPCs(sce))\n\n\n\n\n\n\n\n\nWe can also plot the amount of variance explained by each PC.\n\nmypar()\nplot(attr(reducedDim(sce,\"PCA\"),\"percentVar\")[1:50]*100,type=\"l\",ylab=\"% variance\",xlab=\"Principal component #\")\npoints(attr(reducedDim(sce,\"PCA\"),\"percentVar\")[1:50]*100,pch=21,bg=\"grey\",cex=.5)\n\n\n\n\n\n\n\n\nBased on this plot, we can see that the top 8 PCs retain a lot of information, while other PCs contain progressively less. However, it is still advisable to use more PCs since they might contain information about rare cell types (such as platelets and DCs in this dataset)"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_tsne",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_tsne",
    "title": " Dimensionality Reduction",
    "section": "5 tSNE",
    "text": "5 tSNE\nWe can now run BH-tSNE.\n\nset.seed(42)\nsce &lt;- runTSNE(sce, dimred = \"PCA\", n_dimred = 30, perplexity = 30,name = \"tSNE_on_PCA\")\n\nWe can now plot the tSNE colored per dataset. We can clearly see the effect of batches present in the dataset.\n\nplot_grid(ncol = 3,plotReducedDim(sce,dimred = \"tSNE_on_PCA\",colour_by = \"sample\"))"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_umap",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_umap",
    "title": " Dimensionality Reduction",
    "section": "6 UMAP",
    "text": "6 UMAP\nWe can now run UMAP for cell embeddings.\n\nsce &lt;- runUMAP(sce,dimred = \"PCA\", n_dimred = 30,   ncomponents = 2,name = \"UMAP_on_PCA\")\n#see ?umap and ?runUMAP for more info\n\nUMAP is plotted colored per dataset. Although less distinct as in the tSNE, we still see quite an effect of the different batches in the data. UMAP is not limited by the number of dimensions the data can be reduced into (unlike tSNE). We can simply reduce the dimensions altering the n.components parameter.\n\nsce &lt;- runUMAP(sce,dimred = \"PCA\", n_dimred = 30,   ncomponents = 10, name = \"UMAP10_on_PCA\")\n#see ?umap and ?runUMAP for more info\n\nWe can now plot PCA, UMAP and tSNE side by side for comparison. Here, we can conclude that our dataset contains a batch effect that needs to be corrected before proceeding to clustering and differential gene expression analysis.\n\nplot_grid(ncol = 3,\n  plotReducedDim(sce,dimred = \"UMAP_on_PCA\",colour_by = \"sample\")+\n    ggplot2::ggtitle(label =\"UMAP_on_PCA\"),\n  plotReducedDim(sce,dimred = \"UMAP10_on_PCA\",colour_by = \"sample\",ncomponents = 1:2)+\n    ggplot2::ggtitle(label =\"UMAP10_on_PCA\"),\n  plotReducedDim(sce,dimred = \"UMAP10_on_PCA\",colour_by = \"sample\",ncomponents = 3:4)+\n    ggplot2::ggtitle(label =\"UMAP10_on_PCA\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nWe have now done Variable gene selection, PCA and UMAP with the settings we chose. Test a few different ways of selecting variable genes, number of PCs for UMAP and check how it influences your embedding."
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_zsg",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_zsg",
    "title": " Dimensionality Reduction",
    "section": "7 Z-scores & DR graphs",
    "text": "7 Z-scores & DR graphs\nAlthough running a second dimensionality reduction (i.e tSNE or UMAP) on PCA would be a standard approach (because it allows higher computation efficiency), the options are actually limitless. Below we will show a couple of other common options such as running directly on the scaled data (z-scores) (which was used for PCA) or on a graph built from scaled data. We will show from now on only UMAP, but the same applies for tSNE.\n\n7.1 UMAP from z-scores\nTo run tSNE or UMAP on the scaled data, one first needs to select the number of variables to use. This is because including dimensions that do contribute to the separation of your cell types will in the end mask those differences. Another reason for it is because running with all genes/features also will take longer or might be computationally unfeasible. Therefore we will use the scaled data of the highly variable genes.\n\nsce &lt;- runUMAP(sce, exprs_values='logcounts',name = \"UMAP_on_ScaleData\")\n\n\n\n7.2 UMAP from graph\nTo run tSNE or UMAP on the a graph, we first need to build a graph from the data. In fact, both tSNE and UMAP first build a graph from the data using a specified distance matrix and then optimize the embedding. Since a graph is just a matrix containing distances from cell to cell and as such, you can run either UMAP or tSNE using any other distance metric desired. Euclidean and Correlation are usually the most commonly used.\n\n#Build Graph\nnn &lt;- RANN::nn2(reducedDim(sce,\"PCA\"),k = 30)\nnames(nn) &lt;- c(\"idx\",\"dist\")\ng &lt;- buildKNNGraph(sce, k=30, use.dimred=\"PCA\")\nreducedDim(sce,\"KNN\") &lt;- igraph::as_adjacency_matrix(g)\n\n#Run UMAP and rename it for comparisson\n# temp &lt;- umap::umap.defaults\ntry(reducedDim(sce,\"UMAP_on_Graph\") &lt;- NULL)\nreducedDim(sce,\"UMAP_on_Graph\") &lt;- uwot::umap(X=NULL, n_components = 2, nn_method=nn)\n\nWe can now plot the UMAP comparing both on PCA vs ScaledSata vs Graph.\n\nplot_grid(ncol = 3,\n  plotReducedDim(sce, dimred = \"UMAP_on_PCA\", colour_by = \"sample\")+\n    ggplot2::ggtitle(label =\"UMAP_on_PCA\"),\n  plotReducedDim(sce, dimred = \"UMAP_on_ScaleData\", colour_by = \"sample\")+\n    ggplot2::ggtitle(label =\"UMAP_on_ScaleData\"),\n  plotReducedDim(sce, dimred = \"UMAP_on_Graph\", colour_by = \"sample\")+\n    ggplot2::ggtitle(label =\"UMAP_on_Graph\")\n)"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_plotgenes",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_plotgenes",
    "title": " Dimensionality Reduction",
    "section": "8 Genes of interest",
    "text": "8 Genes of interest\nLet’s plot some marker genes for different cell types onto the embedding.\n\n\n\nMarkers\nCell Type\n\n\n\n\nCD3E\nT cells\n\n\nCD3E CD4\nCD4+ T cells\n\n\nCD3E CD8A\nCD8+ T cells\n\n\nGNLY, NKG7\nNK cells\n\n\nMS4A1\nB cells\n\n\nCD14, LYZ, CST3, MS4A7\nCD14+ Monocytes\n\n\nFCGR3A, LYZ, CST3, MS4A7\nFCGR3A+ Monocytes\n\n\nFCER1A, CST3\nDCs\n\n\n\n\nplotlist &lt;- list()\nfor(i in c(\"CD3E\",\"CD4\",\"CD8A\",\"NKG7\",\"GNLY\",\"MS4A1\",\"CD14\",\"LYZ\",\"MS4A7\",\"FCGR3A\",\"CST3\",\"FCER1A\")){\n  plotlist[[i]] &lt;- plotReducedDim(sce,dimred = \"UMAP_on_PCA\",colour_by = i,by_exprs_values = \"logcounts\") +\n  scale_fill_gradientn(colours = colorRampPalette(c(\"grey90\",\"orange3\",\"firebrick\",\"firebrick\",\"red\",\"red\" ))(10)) +\n  ggtitle(label = i)+ theme(plot.title = element_text(size=20)) }\nplot_grid(ncol=3, plotlist = plotlist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nSelect some of your dimensionality reductions and plot some of the QC stats that were calculated in the previous lab. Can you see if some of the separation in your data is driven by quality of the cells?"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-dimred_save",
    "href": "labs/bioc/bioc_02_dimred.html#meta-dimred_save",
    "title": " Dimensionality Reduction",
    "section": "9 Save data",
    "text": "9 Save data\nWe can finally save the object for use in future steps.\n\npath &lt;- \"data/results/covid_qc_dm.rds\"\nif(!file.exists(path)) saveRDS(sce,path)"
  },
  {
    "objectID": "labs/bioc/bioc_02_dimred.html#meta-session",
    "href": "labs/bioc/bioc_02_dimred.html#meta-session",
    "title": " Dimensionality Reduction",
    "section": "10 Session info",
    "text": "10 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] umap_0.2.10.0               rafalib_1.0.0              \n [3] cowplot_1.1.1               scran_1.26.2               \n [5] scater_1.26.1               ggplot2_3.4.2              \n [7] scuttle_1.8.4               SingleCellExperiment_1.20.1\n [9] SummarizedExperiment_1.28.0 Biobase_2.58.0             \n[11] GenomicRanges_1.50.2        GenomeInfoDb_1.34.9        \n[13] IRanges_2.32.0              S4Vectors_0.36.2           \n[15] BiocGenerics_0.44.0         MatrixGenerics_1.10.0      \n[17] matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n [1] bitops_1.0-7              RcppAnnoy_0.0.21         \n [3] RColorBrewer_1.1-3        tools_4.2.3              \n [5] utf8_1.2.3                R6_2.5.1                 \n [7] irlba_2.3.5.1             vipor_0.4.5              \n [9] uwot_0.1.16               colorspace_2.1-0         \n[11] withr_2.5.0               tidyselect_1.2.0         \n[13] gridExtra_2.3             compiler_4.2.3           \n[15] cli_3.6.1                 BiocNeighbors_1.16.0     \n[17] DelayedArray_0.24.0       labeling_0.4.2           \n[19] scales_1.2.1              askpass_1.1              \n[21] digest_0.6.33             rmarkdown_2.21           \n[23] XVector_0.38.0            pkgconfig_2.0.3          \n[25] htmltools_0.5.5           sparseMatrixStats_1.10.0 \n[27] fastmap_1.1.1             limma_3.54.2             \n[29] htmlwidgets_1.6.2         rlang_1.1.1              \n[31] rstudioapi_0.14           DelayedMatrixStats_1.20.0\n[33] generics_0.1.3            farver_2.1.1             \n[35] jsonlite_1.8.7            BiocParallel_1.32.6      \n[37] dplyr_1.1.1               RCurl_1.98-1.12          \n[39] magrittr_2.0.3            BiocSingular_1.14.0      \n[41] GenomeInfoDbData_1.2.9    Matrix_1.6-0             \n[43] Rcpp_1.0.10               ggbeeswarm_0.7.2         \n[45] munsell_0.5.0             fansi_1.0.4              \n[47] reticulate_1.30           viridis_0.6.3            \n[49] lifecycle_1.0.3           yaml_2.3.7               \n[51] edgeR_3.40.2              zlibbioc_1.44.0          \n[53] Rtsne_0.16                grid_4.2.3               \n[55] parallel_4.2.3            ggrepel_0.9.3            \n[57] dqrng_0.3.0               lattice_0.20-45          \n[59] beachmat_2.14.2           locfit_1.5-9.8           \n[61] metapod_1.6.0             knitr_1.43               \n[63] pillar_1.9.0              igraph_1.5.0             \n[65] codetools_0.2-19          ScaledMatrix_1.6.0       \n[67] glue_1.6.2                evaluate_0.21            \n[69] vctrs_0.6.3               png_0.1-8                \n[71] RANN_2.6.1                gtable_0.3.3             \n[73] openssl_2.0.6             xfun_0.39                \n[75] rsvd_1.0.5                RSpectra_0.16-1          \n[77] viridisLite_0.4.2         tibble_3.2.1             \n[79] beeswarm_0.4.0            cluster_2.1.4            \n[81] bluster_1.8.0             statmod_1.5.0"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html",
    "href": "labs/scanpy/scanpy_02_dimred.html",
    "title": " Dimensionality Reduction",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run Python commands unless it starts with %%bash, in which case, those chunks run shell commands."
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_prep",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_prep",
    "title": " Dimensionality Reduction",
    "section": "1 Data preparation",
    "text": "1 Data preparation\nFirst, let’s load all necessary libraries and the QC-filtered dataset from the previous step.\n\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3\n#sc.logging.print_versions()\n\nsc.settings.set_figure_params(dpi=80)\nadata = sc.read_h5ad('data/results/scanpy_qc_filtered_covid.h5ad')\nadata\n\nAnnData object with n_obs × n_vars = 5646 × 18752\n    obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'connectivities', 'distances'\n\n\nBefore variable gene selection we need to normalize and log transform the data. Then store the full matrix in the raw slot before doing variable gene selection.\n\n# normalize to depth 10 000\nsc.pp.normalize_per_cell(adata, counts_per_cell_after=1e4)\n\n# log transform\nsc.pp.log1p(adata)\n\n# store normalized counts in the raw slot, \n# we will subset adata.X for variable genes, but want to keep all genes matrix as well.\nadata.raw = adata\n\nadata\n\nAnnData object with n_obs × n_vars = 5646 × 18752\n    obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'connectivities', 'distances'"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_fs",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_fs",
    "title": " Dimensionality Reduction",
    "section": "2 Feature selection",
    "text": "2 Feature selection\nNext, we first need to define which features/genes are important in our dataset to distinguish cell types. For this purpose, we need to find genes that are highly variable across cells, which in turn will also provide a good separation of the cell clusters.\n\n# compute variable genes\nsc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)\nprint(\"Highly variable genes: %d\"%sum(adata.var.highly_variable))\n\n#plot variable genes\nsc.pl.highly_variable_genes(adata)\n\n# subset for variable genes in the dataset\nadata = adata[:, adata.var['highly_variable']]\n\nHighly variable genes: 3090"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_zs",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_zs",
    "title": " Dimensionality Reduction",
    "section": "3 Z-score transformation",
    "text": "3 Z-score transformation\nNow that the data is prepared, we now proceed with PCA. Since each gene has a different expression level, it means that genes with higher expression values will naturally have higher variation that will be captured by PCA. This means that we need to somehow give each gene a similar weight when performing PCA (see below). The common practice is to center and scale each gene before performing PCA. This exact scaling is called Z-score normalization it is very useful for PCA, clustering and plotting heatmaps. Additionally, we can use regression to remove any unwanted sources of variation from the dataset, such as cell cycle, sequencing depth, percent mitochondria. This is achieved by doing a generalized linear regression using these parameters as co-variates in the model. Then the residuals of the model are taken as the regressed data. Although perhaps not in the best way, batch effect regression can also be done here. By default variables are scaled in the PCA step and is not done separately. But it could be achieved by running the commands below:\n\n#run this line if you get the \"AttributeError: swapaxes not found\" \n# adata = adata.copy()\n\n# regress out unwanted variables\nsc.pp.regress_out(adata, ['total_counts', 'pct_counts_mt'])\n\n# scale data, clip values exceeding standard deviation 10.\nsc.pp.scale(adata, max_value=10)"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_pca",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_pca",
    "title": " Dimensionality Reduction",
    "section": "4 PCA",
    "text": "4 PCA\nPerforming PCA has many useful applications and interpretations, which much depends on the data used. In the case of life sciences, we want to segregate samples based on gene expression patterns in the data.\nTo run PCA, you can use the function pca().\n\nsc.tl.pca(adata, svd_solver='arpack')\n\nWe then plot the first principal components.\n\n# plot more PCS\nsc.pl.pca(adata, color='sample', components = ['1,2','3,4','5,6','7,8'], ncols=2)\n\n\n\n\n\n\n\n\nTo identify genes that contribute most to each PC, one can retrieve the loading matrix information.\n\n#Plot loadings\nsc.pl.pca_loadings(adata, components=[1,2,3,4,5,6,7,8])\n\n# OBS! only plots the positive axes genes from each PC!!\n\n\n\n\n\n\n\n\nThe function to plot loading genes only plots genes on the positive axes. Instead plot as a heatmaps, with genes on both positive and negative side, one per pc, and plot their expression amongst cells ordered by their position along the pc.\n\n# adata.obsm[\"X_pca\"] is the embeddings\n# adata.uns[\"pca\"] is pc variance\n# adata.varm['PCs'] is the loadings\n\ngenes = adata.var['gene_ids']\n\nfor pc in [1,2,3,4]:\n    g = adata.varm['PCs'][:,pc-1]\n    o = np.argsort(g)\n    sel = np.concatenate((o[:10],o[-10:])).tolist()\n    emb = adata.obsm['X_pca'][:,pc-1]\n    # order by position on that pc\n    tempdata = adata[np.argsort(emb),]\n    sc.pl.heatmap(tempdata, var_names = genes[sel].index.tolist(), groupby='predicted_doublets', swap_axes = True, use_raw=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also plot the amount of variance explained by each PC.\n\nsc.pl.pca_variance_ratio(adata, log=True, n_pcs = 50)\n\n\n\n\n\n\n\n\nBased on this plot, we can see that the top 8 PCs retain a lot of information, while other PCs contain progressively less. However, it is still advisable to use more PCs since they might contain information about rare cell types (such as platelets and DCs in this dataset)"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_tsne",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_tsne",
    "title": " Dimensionality Reduction",
    "section": "5 tSNE",
    "text": "5 tSNE\nWe can now run BH-tSNE.\n\nsc.tl.tsne(adata, n_pcs = 30)\n\nWe can now plot the tSNE colored per dataset. We can clearly see the effect of batches present in the dataset.\n\nsc.pl.tsne(adata, color='sample')"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_umap",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_umap",
    "title": " Dimensionality Reduction",
    "section": "6 UMAP",
    "text": "6 UMAP\nThe UMAP implementation in SCANPY uses a neighborhood graph as the distance matrix, so we need to first calculate the graph.\n\nsc.pp.neighbors(adata, n_pcs = 30, n_neighbors = 20)\n\nWe can now run UMAP for cell embeddings.\n\nsc.tl.umap(adata)\nsc.pl.umap(adata, color='sample')\n\n\n\n\n\n\n\n\nUMAP is plotted colored per dataset. Although less distinct as in the tSNE, we still see quite an effect of the different batches in the data. UMAP is not limited by the number of dimensions the data can be reduced into (unlike tSNE). We can simply reduce the dimensions altering the n.components parameter.\n\n#run with 10 components, save to a new object so that the umap with 2D is not overwritten.\numap10 = sc.tl.umap(adata, n_components=10, copy=True)\nfig, axs = plt.subplots(1, 3, figsize=(10,4),constrained_layout=True)\n\nsc.pl.umap(adata, color='sample',  title=\"UMAP\", show=False, ax=axs[0])\nsc.pl.umap(umap10, color='sample', title=\"UMAP10\", show=False, ax=axs[1], components=['1,2'])\nsc.pl.umap(umap10, color='sample', title=\"UMAP10\", show=False, ax=axs[2], components=['3,4'])\n\n# we can also plot the umap with neighbor edges\nsc.pl.umap(adata, color='sample', title=\"UMAP\", edges=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can now plot PCA, UMAP and tSNE side by side for comparison. Here, we can conclude that our dataset contains a batch effect that needs to be corrected before proceeding to clustering and differential gene expression analysis.\nTODO: [pca, tsne and umap plots side by side]\n\n\n\n\n\n\nDiscuss\n\n\n\nWe have now done Variable gene selection, PCA and UMAP with the settings we chose. Test a few different ways of selecting variable genes, number of PCs for UMAP and check how it influences your embedding."
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_plotgenes",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_plotgenes",
    "title": " Dimensionality Reduction",
    "section": "7 Genes of interest",
    "text": "7 Genes of interest\nLet’s plot some marker genes for different cell types onto the embedding.\n\n\n\nMarkers\nCell Type\n\n\n\n\nCD3E\nT cells\n\n\nCD3E CD4\nCD4+ T cells\n\n\nCD3E CD8A\nCD8+ T cells\n\n\nGNLY, NKG7\nNK cells\n\n\nMS4A1\nB cells\n\n\nCD14, LYZ, CST3, MS4A7\nCD14+ Monocytes\n\n\nFCGR3A, LYZ, CST3, MS4A7\nFCGR3A+ Monocytes\n\n\nFCER1A, CST3\nDCs\n\n\n\n\nsc.pl.umap(adata, color=[\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR3A\"])\n\n\n\n\n\n\n\n\nThe default is to plot gene expression in the normalized and log-transformed data. You can also plot it on the scaled and corrected data by using use_raw=False. However, not all of these genes are included in the variable gene set so we first need to filter them.\n\ngenes  = [\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR3A\"]\nvar_genes = adata.var.highly_variable\nvar_genes.index[var_genes]\nvarg = [x for x in genes if x in var_genes.index[var_genes]]\nsc.pl.umap(adata, color=varg, use_raw=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nSelect some of your dimensionality reductions and plot some of the QC stats that were calculated in the previous lab. Can you see if some of the separation in your data is driven by quality of the cells?"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_save",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-dimred_save",
    "title": " Dimensionality Reduction",
    "section": "8 Save data",
    "text": "8 Save data\nWe can finally save the object for use in future steps.\n\nimport os\npath = \"./data/results/scanpy_dr_covid.h5ad\"\nif not os.path.exists(path):\n    adata.write_h5ad(path)\n\n\nprint(adata.X.shape)\nprint(adata.raw.X.shape)\n\n(5646, 3090)\n(5646, 18752)"
  },
  {
    "objectID": "labs/scanpy/scanpy_02_dimred.html#meta-session",
    "href": "labs/scanpy/scanpy_02_dimred.html#meta-session",
    "title": " Dimensionality Reduction",
    "section": "9 Session info",
    "text": "9 Session info\n\nsc.logging.print_versions()\n\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfqdn                        NA\nget_version                 3.5.4\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nipykernel                   6.25.2\nipywidgets                  8.1.1\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnetworkx                    3.1\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npatsy                       0.5.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npycparser                   2.21\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npynndescent                 0.5.10\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanpy                      1.7.2\nscipy                       1.10.1\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nstack_data                  0.6.2\nstatsmodels                 0.14.0\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntqdm                        4.65.0\ntraitlets                   5.11.2\ntyping_extensions           NA\numap                        0.5.4\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-10 19:10"
  },
  {
    "objectID": "labs/seurat/seurat_04_clustering.html",
    "href": "labs/seurat/seurat_04_clustering.html",
    "title": " Clustering",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nIn this tutorial we will continue the analysis of the integrated dataset. We will use the integrated PCA to perform the clustering. First we will construct a \\(k\\)-nearest neighbor graph in order to perform a clustering on the graph. We will also show how to perform hierarchical clustering and k-means clustering on PCA space.\nLet’s first load all necessary libraries and also the integrated dataset from the previous step.\nsuppressPackageStartupMessages({\n  library(Seurat)\n  library(cowplot)\n  library(ggplot2)\n  library(pheatmap)\n  library(rafalib)\n  library(clustree)\n})\n\nalldata &lt;- readRDS(\"data/results/covid_qc_dr_int.rds\")"
  },
  {
    "objectID": "labs/seurat/seurat_04_clustering.html#meta-clust_graphclust",
    "href": "labs/seurat/seurat_04_clustering.html#meta-clust_graphclust",
    "title": " Clustering",
    "section": "1 Graph clustering",
    "text": "1 Graph clustering\nThe procedure of clustering on a Graph can be generalized as 3 main steps: 1) Build a kNN graph from the data 2) Prune spurious connections from kNN graph (optional step). This is a SNN graph. 3) Find groups of cells that maximizes the connections within the group compared other groups.\n\n1.1 Building kNN / SNN graph\nThe first step into graph clustering is to construct a k-nn graph, in case you don’t have one. For this, we will use the PCA space. Thus, as done for dimensionality reduction, we will use ony the top N PCA dimensions for this purpose (the same used for computing UMAP / tSNE).\nAs we can see above, the Seurat function FindNeighbors() already computes both the KNN and SNN graphs, in which we can control the minimal percentage of shared neighbours to be kept. See ?FindNeighbors for additional options.\n\n# check that CCA is still the active assay\nalldata@active.assay\n\nalldata &lt;- FindNeighbors(alldata, dims = 1:30, k.param = 60, prune.SNN = 1/15)\n\n# check the names for graphs in the object.\nnames(alldata@graphs)\n\n[1] \"CCA\"\n[1] \"CCA_nn\"  \"CCA_snn\"\n\n\nWe can take a look at the kNN graph. It is a matrix where every connection between cells is represented as \\(1\\)s. This is called a unweighted graph (default in Seurat). Some cell connections can however have more importance than others, in that case the scale of the graph from \\(0\\) to a maximum distance. Usually, the smaller the distance, the closer two points are, and stronger is their connection. This is called a weighted graph. Both weighted and unweighted graphs are suitable for clustering, but clustering on unweighted graphs is faster for large datasets (&gt; 100k cells).\n\npheatmap(alldata@graphs$CCA_nn[1:200,1:200],\n         col=c(\"white\",\"black\"),border_color = \"grey90\", main = \"KNN graph\",\n         legend = F,cluster_rows = F,cluster_cols = F,fontsize = 2)\n\n\n\n\n\n\n\npheatmap(alldata@graphs$CCA_snn[1:200,1:200],\n         col=colorRampPalette(c(\"white\",\"yellow\",\"red\"))(100), \n         border_color = \"grey90\", main = \"SNN graph\",\n         legend = F,cluster_rows = F,cluster_cols = F,fontsize = 2)\n\n\n\n\n\n\n\n\n\n\n1.2 Clustering on a graph\nOnce the graph is built, we can now perform graph clustering. The clustering is done respective to a resolution which can be interpreted as how coarse you want your cluster to be. Higher resolution means higher number of clusters.\nIn Seurat, the function FindClusters() will do a graph-based clustering using “Louvain” algorithim by default (algorithm = 1). To use the leiden algorithm, you need to set it to algorithm = 4. See ?FindClusters for additional options.\n\n# Clustering with louvain (algorithm 1)\nfor (res in c( 0.1 , 0.25 , .5 , 1 , 1.5 , 2 )){\n  alldata &lt;- FindClusters(alldata, graph.name = \"CCA_snn\", resolution = res , algorithm = 1)\n}\n\n# each time you run clustering, the data is stored in meta data columns:\n# seurat_clusters - lastest results only\n# CCA_snn_res.XX - for each different resolution you test.\n\n\nplot_grid(ncol = 3,\n  DimPlot(alldata, reduction = \"umap\", group.by = \"CCA_snn_res.0.5\")+ggtitle(\"louvain_0.5\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"CCA_snn_res.1\")+ggtitle(\"louvain_1\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"CCA_snn_res.2\")+ggtitle(\"louvain_2\")\n)\n\n\n\n\n\n\n\n\nWe can now use the clustree package to visualize how cells are distributed between clusters depending on resolution.\n\nsuppressPackageStartupMessages(library(clustree))\nclustree(alldata@meta.data, prefix = \"CCA_snn_res.\")"
  },
  {
    "objectID": "labs/seurat/seurat_04_clustering.html#meta-clust_kmean",
    "href": "labs/seurat/seurat_04_clustering.html#meta-clust_kmean",
    "title": " Clustering",
    "section": "2 K-means clustering",
    "text": "2 K-means clustering\nK-means is a generic clustering algorithm that has been used in many application areas. In R, it can be applied via the kmeans function. Typically, it is applied to a reduced dimension representation of the expression data (most often PCA, because of the interpretability of the low-dimensional distances). We need to define the number of clusters in advance. Since the results depend on the initialization of the cluster centers, it is typically recommended to run K-means with multiple starting configurations (via the nstart argument).\n\nfor (k in c( 5 , 7 , 10 , 12 , 15 , 17 , 20)){\n  alldata@meta.data[,paste0(\"kmeans_\",k)] &lt;- kmeans(x = alldata@reductions[[\"pca\"]]@cell.embeddings, centers = k,nstart = 100)$cluster\n}\n\nplot_grid(ncol = 3,\n  DimPlot(alldata, reduction = \"umap\", group.by = \"kmeans_5\")+ggtitle(\"kmeans_5\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"kmeans_10\")+ggtitle(\"kmeans_10\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"kmeans_15\")+ggtitle(\"kmeans_15\")\n)\n\n\n\n\n\n\n\n\n\nclustree(alldata@meta.data, prefix = \"kmeans_\")"
  },
  {
    "objectID": "labs/seurat/seurat_04_clustering.html#meta-clust_hier",
    "href": "labs/seurat/seurat_04_clustering.html#meta-clust_hier",
    "title": " Clustering",
    "section": "3 Hierarchical clustering",
    "text": "3 Hierarchical clustering\n\n3.1 Defining distance between cells\nThe base R stats package already contains a function dist that calculates distances between all pairs of samples. Since we want to compute distances between samples, rather than among genes, we need to transpose the data before applying it to the dist function. This can be done by simply adding the transpose function t() to the data. The distance methods available in dist are: ‘euclidean’, ‘maximum’, ‘manhattan’, ‘canberra’, ‘binary’ or ‘minkowski’.\n\nd &lt;- dist( alldata@reductions[[\"pca\"]]@cell.embeddings, method=\"euclidean\")\n\nAs you might have realized, correlation is not a method implemented in the dist() function. However, we can create our own distances and transform them to a distance object. We can first compute sample correlations using the cor function.\nAs you already know, correlation range from -1 to 1, where 1 indicates that two samples are closest, -1 indicates that two samples are the furthest and 0 is somewhat in between. This, however, creates a problem in defining distances because a distance of 0 indicates that two samples are closest, 1 indicates that two samples are the furthest and distance of -1 is not meaningful. We thus need to transform the correlations to a positive scale (a.k.a. adjacency):\n[adj = ]\nOnce we transformed the correlations to a 0-1 scale, we can simply convert it to a distance object using as.dist function. The transformation does not need to have a maximum of 1, but it is more intuitive to have it at 1, rather than at any other number.\n\n#Compute sample correlations\nsample_cor &lt;- cor( Matrix::t(alldata@reductions[[\"pca\"]]@cell.embeddings) )\n\n#Transform the scale from correlations\nsample_cor &lt;- (1 - sample_cor) / 2\n\n#Convert it to a distance object\nd2 &lt;- as.dist(sample_cor)\n\n\n\n3.2 Clustering cells\nAfter having calculated the distances between samples calculated, we can now proceed with the hierarchical clustering per-se. We will use the function hclust for this purpose, in which we can simply run it with the distance objects created above. The methods available are: ‘ward.D’, ‘ward.D2’, ‘single’, ‘complete’, ‘average’, ‘mcquitty’, ‘median’ or ‘centroid’. It is possible to plot the dendrogram for all cells, but this is very time consuming and we will omit for this tutorial.\n\n#euclidean\nh_euclidean &lt;- hclust(d, method=\"ward.D2\")\n\n#correlation\nh_correlation &lt;- hclust(d2, method=\"ward.D2\")\n\nOnce your dendrogram is created, the next step is to define which samples belong to a particular cluster. After identifying the dendrogram, we can now literally cut the tree at a fixed threshold (with cutree) at different levels to define the clusters. We can either define the number of clusters or decide on a height. We can simply try different clustering levels.\n\n#euclidean distance\nalldata$hc_euclidean_5 &lt;- cutree(h_euclidean,k = 5)\nalldata$hc_euclidean_10 &lt;- cutree(h_euclidean,k = 10)\nalldata$hc_euclidean_15 &lt;- cutree(h_euclidean,k = 15)\n\n#correlation distance\nalldata$hc_corelation_5 &lt;- cutree(h_correlation,k = 5)\nalldata$hc_corelation_10 &lt;- cutree(h_correlation,k = 10)\nalldata$hc_corelation_15 &lt;- cutree(h_correlation,k = 15)\n\n\nplot_grid(ncol = 3,\n  DimPlot(alldata, reduction = \"umap\", group.by = \"hc_euclidean_5\")+ggtitle(\"hc_euc_5\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"hc_euclidean_10\")+ggtitle(\"hc_euc_10\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"hc_euclidean_15\")+ggtitle(\"hc_euc_15\"),\n\n  DimPlot(alldata, reduction = \"umap\", group.by = \"hc_corelation_5\")+ggtitle(\"hc_cor_5\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"hc_corelation_10\")+ggtitle(\"hc_cor_10\"),\n  DimPlot(alldata, reduction = \"umap\", group.by = \"hc_corelation_15\")+ggtitle(\"hc_cor_15\")\n)\n\n\n\n\n\n\n\n\nFinally, lets save the clustered data for further analysis.\n\nsaveRDS(alldata,\"data/results/covid_qc_dr_int_cl.rds\")\n\n\n\n\n\n\n\nDiscuss\n\n\n\nBy now you should know how to plot different features onto your data. Take the QC metrics that were calculated in the first exercise, that should be stored in your data object, and plot it as violin plots per cluster using the clustering method of your choice. For example, plot number of UMIS, detected genes, percent mitochondrial reads. Then, check carefully if there is any bias in how your data is separated due to quality metrics. Could it be explained biologically, or could you have technical bias there?"
  },
  {
    "objectID": "labs/seurat/seurat_04_clustering.html#meta-session",
    "href": "labs/seurat/seurat_04_clustering.html#meta-session",
    "title": " Clustering",
    "section": "4 Session info",
    "text": "4 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] clustree_0.5.0     ggraph_2.1.0       rafalib_1.0.0      pheatmap_1.0.12   \n[5] ggplot2_3.4.2      cowplot_1.1.1      SeuratObject_4.1.3 Seurat_4.3.0.1    \n\nloaded via a namespace (and not attached):\n  [1] Rtsne_0.16             colorspace_2.1-0       deldir_1.0-9          \n  [4] ellipsis_0.3.2         ggridges_0.5.4         rstudioapi_0.14       \n  [7] spatstat.data_3.0-1    farver_2.1.1           leiden_0.4.3          \n [10] listenv_0.9.0          graphlayouts_1.0.0     ggrepel_0.9.3         \n [13] fansi_1.0.4            codetools_0.2-19       splines_4.2.3         \n [16] knitr_1.43             polyclip_1.10-4        jsonlite_1.8.7        \n [19] ica_1.0-3              cluster_2.1.4          png_0.1-8             \n [22] uwot_0.1.16            ggforce_0.4.1          shiny_1.7.4           \n [25] sctransform_0.3.5      spatstat.sparse_3.0-2  compiler_4.2.3        \n [28] httr_1.4.6             backports_1.4.1        Matrix_1.6-0          \n [31] fastmap_1.1.1          lazyeval_0.2.2         cli_3.6.1             \n [34] tweenr_2.0.2           later_1.3.1            htmltools_0.5.5       \n [37] tools_4.2.3            igraph_1.5.0           gtable_0.3.3          \n [40] glue_1.6.2             RANN_2.6.1             reshape2_1.4.4        \n [43] dplyr_1.1.1            Rcpp_1.0.10            scattermore_1.2       \n [46] vctrs_0.6.3            spatstat.explore_3.2-1 nlme_3.1-162          \n [49] progressr_0.13.0       lmtest_0.9-40          spatstat.random_3.1-5 \n [52] xfun_0.39              stringr_1.5.0          globals_0.16.2        \n [55] mime_0.12              miniUI_0.1.1.1         lifecycle_1.0.3       \n [58] irlba_2.3.5.1          goftest_1.2-3          future_1.33.0         \n [61] MASS_7.3-58.2          zoo_1.8-12             scales_1.2.1          \n [64] tidygraph_1.2.3        promises_1.2.0.1       spatstat.utils_3.0-3  \n [67] parallel_4.2.3         RColorBrewer_1.1-3     yaml_2.3.7            \n [70] reticulate_1.30        pbapply_1.7-2          gridExtra_2.3         \n [73] stringi_1.7.12         checkmate_2.2.0        rlang_1.1.1           \n [76] pkgconfig_2.0.3        matrixStats_1.0.0      evaluate_0.21         \n [79] lattice_0.20-45        ROCR_1.0-11            purrr_1.0.1           \n [82] tensor_1.5             labeling_0.4.2         patchwork_1.1.2       \n [85] htmlwidgets_1.6.2      tidyselect_1.2.0       parallelly_1.36.0     \n [88] RcppAnnoy_0.0.21       plyr_1.8.8             magrittr_2.0.3        \n [91] R6_2.5.1               generics_0.1.3         pillar_1.9.0          \n [94] withr_2.5.0            fitdistrplus_1.1-11    survival_3.5-3        \n [97] abind_1.4-5            sp_2.0-0               tibble_3.2.1          \n[100] future.apply_1.11.0    KernSmooth_2.23-20     utf8_1.2.3            \n[103] spatstat.geom_3.2-1    plotly_4.10.2          rmarkdown_2.21        \n[106] viridis_0.6.3          grid_4.2.3             data.table_1.14.8     \n[109] digest_0.6.33          xtable_1.8-4           tidyr_1.3.0           \n[112] httpuv_1.6.11          munsell_0.5.0          viridisLite_0.4.2"
  },
  {
    "objectID": "labs/bioc/bioc_03_integration.html",
    "href": "labs/bioc/bioc_03_integration.html",
    "title": " Data Integration",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nIn this tutorial we will look at different ways of integrating multiple single cell RNA-seq datasets. We will explore two different methods to correct for batch effects across datasets. We will also look at a quantitative measure to assess the quality of the integrated data. Seurat uses the data integration method presented in Comprehensive Integration of Single Cell Data, while Scran and Scanpy use a mutual Nearest neighbour method (MNN). Below you can find a list of the most recent methods for single data integration:"
  },
  {
    "objectID": "labs/bioc/bioc_03_integration.html#meta-int_prep",
    "href": "labs/bioc/bioc_03_integration.html#meta-int_prep",
    "title": " Data Integration",
    "section": "1 Data preparation",
    "text": "1 Data preparation\nLet’s first load necessary libraries and the data saved in the previous lab.\n\nsuppressPackageStartupMessages({\n  library(scater)\n  library(scran)\n  library(cowplot)\n  library(ggplot2)\n  library(rafalib)\n# library(venn)\n})\n\nsce &lt;- readRDS(\"data/results/covid_qc_dm.rds\")\nprint(reducedDims(sce))\n\nList of length 8\nnames(8): PCA UMAP tSNE_on_PCA ... UMAP_on_ScaleData KNN UMAP_on_Graph\n\n\nWe split the combined object into a list, with each dataset as an element. We perform standard preprocessing (log-normalization), and identify variable features individually for each dataset based on a variance stabilizing transformation (vst).\n\nsce.list &lt;- lapply( unique(sce$sample), function(x){\n  x &lt;- sce[ , sce$sample == x ] })\n\nmypar(1,3)\nhvgs_per_dataset &lt;- lapply( sce.list, function(x){\n  x &lt;- computeSumFactors(x, sizes=c(20, 40, 60, 80))\n  x &lt;- logNormCounts(x)\n  var.out &lt;- modelGeneVar(x, method=\"loess\")\n  hvg.out &lt;- var.out[which(var.out$FDR &lt;= 0.05 & var.out$bio &gt;= 0.2),]\n  hvg.out &lt;- hvg.out[order(hvg.out$bio, decreasing=TRUE),]\n  return(rownames(hvg.out))\n})\nnames(hvgs_per_dataset) &lt;- unique(sce$sample)\n\n# venn::venn(hvgs_per_dataset,opacity = .4,zcolor = scales::hue_pal()(3),cexsn = 1,cexil = 1,lwd=1,col=\"white\",borders = NA)\n\ntemp &lt;- unique(unlist(hvgs_per_dataset))\noverlap &lt;- sapply( hvgs_per_dataset, function(x) { temp %in% x } )\npheatmap::pheatmap(t(overlap*1),cluster_rows = F, color = c(\"grey90\",\"grey20\"))"
  },
  {
    "objectID": "labs/bioc/bioc_03_integration.html#mnn",
    "href": "labs/bioc/bioc_03_integration.html#mnn",
    "title": " Data Integration",
    "section": "2 MNN",
    "text": "2 MNN\nThe mutual nearest neighbors (MNN) approach within the scran package utilizes a novel approach to adjust for batch effects. The fastMNN() function returns a representation of the data with reduced dimensionality, which can be used in a similar fashion to other lower-dimensional representations such as PCA. In particular, this representation can be used for downstream methods such as clustering. The BNPARAM can be used to specify the specific nearest neighbors method to use from the BiocNeighbors package. Here we make use of the Annoy library via the BiocNeighbors::AnnoyParam() argument. We save the reduced-dimension MNN representation into the reducedDims slot of our sce object.\n\nmnn_out &lt;- batchelor::fastMNN(sce,subset.row = unique(unlist(hvgs_per_dataset)), batch = factor(sce$sample), k = 20, d = 50)\n\n\n\n\n\n\n\nCaution\n\n\n\nfastMNN() does not produce a batch-corrected expression matrix.\n\n\n\nmnn_out &lt;- t(reducedDim(mnn_out,\"corrected\"))\ncolnames(mnn_out) &lt;- unlist(lapply(sce.list,function(x){colnames(x)}))\nmnn_out &lt;- mnn_out[,colnames(sce)]\nrownames(mnn_out) &lt;- paste0(\"dim\",1:50)\nreducedDim(sce, \"MNN\") &lt;- t(mnn_out)\n\nWe can observe that a new assay slot is now created under the name MNN.\n\nreducedDims(sce)\n\nList of length 9\nnames(9): PCA UMAP tSNE_on_PCA UMAP_on_PCA ... KNN UMAP_on_Graph MNN\n\n\nThus, the result from fastMNN() should solely be treated as a reduced dimensionality representation, suitable for direct plotting, TSNE/UMAP, clustering, and trajectory analysis that relies on such results.\n\nset.seed(42)\nsce &lt;- runTSNE(sce, dimred = \"MNN\", n_dimred = 50, perplexity = 30,name = \"tSNE_on_MNN\")\nsce &lt;- runUMAP(sce,dimred = \"MNN\", n_dimred = 50, ncomponents = 2,name = \"UMAP_on_MNN\")\n\nWe can now plot the unintegrated and the integrated space reduced dimensions.\n\nplot_grid(ncol = 3,\n  plotReducedDim(sce,dimred = \"PCA\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"PCA\"),\n  plotReducedDim(sce,dimred = \"tSNE_on_PCA\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"tSNE_on_PCA\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_PCA\",colour_by = \"sample\",point_size = 0.6)+ ggplot2::ggtitle(label =\"UMAP_on_PCA\"),\n\n  plotReducedDim(sce,dimred = \"MNN\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"MNN\"),\n  plotReducedDim(sce,dimred = \"tSNE_on_MNN\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"tSNE_on_MNN\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"UMAP_on_MNN\")\n)\n\n\n\n\n\n\n\n\nLet’s plot some marker genes for different cell types onto the embedding.\n\n\n\nMarkers\nCell Type\n\n\n\n\nCD3E\nT cells\n\n\nCD3E CD4\nCD4+ T cells\n\n\nCD3E CD8A\nCD8+ T cells\n\n\nGNLY, NKG7\nNK cells\n\n\nMS4A1\nB cells\n\n\nCD14, LYZ, CST3, MS4A7\nCD14+ Monocytes\n\n\nFCGR3A, LYZ, CST3, MS4A7\nFCGR3A+ Monocytes\n\n\nFCER1A, CST3\nDCs\n\n\n\n\nplotlist &lt;- list()\nfor(i in c(\"CD3E\",\"CD4\",\"CD8A\",\"NKG7\",\"GNLY\",\"MS4A1\",\"CD14\",\"LYZ\",\"MS4A7\",\"FCGR3A\",\"CST3\",\"FCER1A\")){\n  plotlist[[i]] &lt;- plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = i,by_exprs_values = \"logcounts\", point_size = 0.6) +\n  scale_fill_gradientn(colours = colorRampPalette(c(\"grey90\",\"orange3\",\"firebrick\",\"firebrick\",\"red\",\"red\" ))(10)) +\n  ggtitle(label = i)+ theme(plot.title = element_text(size=20)) }\nplot_grid(ncol=3, plotlist = plotlist)\n\n\n\n\n\n\n\n\nINTEG_R1:\nINTEG_R2:\n\nlibrary(harmony)\n\nreducedDimNames(sce)\n\nsce &lt;- RunHarmony(\n  sce,\n  group.by.vars = \"sample\",\n  reduction.save = \"harmony\",\n  reduction = \"PCA\",\n  dims.use = 1:50)\n\n#Here we use all PCs computed from Harmony for UMAP calculation\nsce &lt;- runUMAP(sce,dimred = \"harmony\", n_dimred = 50, ncomponents = 2,name = \"UMAP_on_Harmony\")\n\n [1] \"PCA\"               \"UMAP\"              \"tSNE_on_PCA\"      \n [4] \"UMAP_on_PCA\"       \"UMAP10_on_PCA\"     \"UMAP_on_ScaleData\"\n [7] \"KNN\"               \"UMAP_on_Graph\"     \"MNN\"              \n[10] \"tSNE_on_MNN\"       \"UMAP_on_MNN\"      \n\n\nINTEG_R3:\nINTEG_R4:\n\nhvgs &lt;- unique(unlist(hvgs_per_dataset))\n\nscelist &lt;- list()\ngenelist &lt;- list()\nfor(i in 1:length(sce.list)) {\n  scelist[[i]] &lt;- t(as.matrix(logcounts(sce.list[[i]])[hvgs,]))\n  genelist[[i]] &lt;- hvgs\n}\n\nlapply(scelist,dim)\n\n[[1]]\n[1] 901 444\n\n[[2]]\n[1] 598 444\n\n[[3]]\n[1] 1052  444\n\n[[4]]\n[1] 1062  444\n\n[[5]]\n[1] 1175  444\n\n[[6]]\n[1] 1108  444\n\n\nINTEG_R5:\n\nlibrary(reticulate)\nreticulate::use_condaenv(\"sspy\")\nscanorama &lt;- import(\"scanorama\")\n\nintegrated.data &lt;- scanorama$integrate(datasets_full = scelist, genes_list = genelist )\n\nintdimred &lt;- do.call(rbind, integrated.data[[1]])\ncolnames(intdimred) &lt;- paste0(\"PC_\", 1:100)\nrownames(intdimred) &lt;- colnames(logcounts(sce))\n\n# Add standard deviations in order to draw Elbow Plots in Seurat\nstdevs &lt;- apply(intdimred, MARGIN = 2, FUN = sd)\nattr(intdimred,\"varExplained\") &lt;- stdevs\n\nreducedDim(sce,\"Scanorama_PCA\") &lt;- intdimred\n\n#Here we use all PCs computed from Scanorama for UMAP calculation\nsce &lt;- runUMAP(sce, dimred = \"Scanorama_PCA\", n_dimred = 50, ncomponents = 2, name = \"UMAP_on_Scanorama\")\n\nINTEG_R6:\n\np1 &lt;- plotReducedDim(sce,dimred = \"UMAP_on_PCA\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"UMAP_on_PCA\")\np2 &lt;- plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"UMAP_on_MNN\")\np3 &lt;- plotReducedDim(sce,dimred = \"UMAP_on_Harmony\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"UMAP_on_Harmony\")\np4 &lt;- plotReducedDim(sce,dimred = \"UMAP_on_Scanorama\",colour_by = \"sample\", point_size = 0.6)+ ggplot2::ggtitle(label =\"UMAP_on_Scanorama\")\nleg &lt;- get_legend(p1)\n\ngridExtra::grid.arrange(\n  gridExtra::arrangeGrob(\n    p1 + Seurat::NoLegend() + Seurat::NoAxes(),\n    p2 + Seurat::NoLegend() + Seurat::NoAxes(),\n    p3 + Seurat::NoLegend() + Seurat::NoAxes(),\n    p4 + Seurat::NoLegend() + Seurat::NoAxes(), nrow=2),\n  leg, ncol=2,widths=c(8,2)\n)\n\n\n\n\n\n\n\n\nINTEG_R7:\nLet’s save the integrated data for further analysis.\n\nsaveRDS(sce,\"data/results/covid_qc_dr_int.rds\")"
  },
  {
    "objectID": "labs/bioc/bioc_03_integration.html#meta-session",
    "href": "labs/bioc/bioc_03_integration.html#meta-session",
    "title": " Data Integration",
    "section": "3 Session info",
    "text": "3 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] reticulate_1.30             harmony_0.1.1              \n [3] Rcpp_1.0.10                 rafalib_1.0.0              \n [5] cowplot_1.1.1               scran_1.26.2               \n [7] scater_1.26.1               ggplot2_3.4.2              \n [9] scuttle_1.8.4               SingleCellExperiment_1.20.1\n[11] SummarizedExperiment_1.28.0 Biobase_2.58.0             \n[13] GenomicRanges_1.50.2        GenomeInfoDb_1.34.9        \n[15] IRanges_2.32.0              S4Vectors_0.36.2           \n[17] BiocGenerics_0.44.0         MatrixGenerics_1.10.0      \n[19] matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n  [1] plyr_1.8.8                igraph_1.5.0             \n  [3] lazyeval_0.2.2            sp_2.0-0                 \n  [5] splines_4.2.3             BiocParallel_1.32.6      \n  [7] listenv_0.9.0             scattermore_1.2          \n  [9] digest_0.6.33             htmltools_0.5.5          \n [11] viridis_0.6.3             fansi_1.0.4              \n [13] magrittr_2.0.3            ScaledMatrix_1.6.0       \n [15] tensor_1.5                cluster_2.1.4            \n [17] ROCR_1.0-11               limma_3.54.2             \n [19] globals_0.16.2            spatstat.sparse_3.0-2    \n [21] colorspace_2.1-0          rappdirs_0.3.3           \n [23] ggrepel_0.9.3             xfun_0.39                \n [25] dplyr_1.1.1               RCurl_1.98-1.12          \n [27] jsonlite_1.8.7            spatstat.data_3.0-1      \n [29] progressr_0.13.0          survival_3.5-3           \n [31] zoo_1.8-12                glue_1.6.2               \n [33] polyclip_1.10-4           gtable_0.3.3             \n [35] zlibbioc_1.44.0           XVector_0.38.0           \n [37] leiden_0.4.3              DelayedArray_0.24.0      \n [39] BiocSingular_1.14.0       future.apply_1.11.0      \n [41] abind_1.4-5               scales_1.2.1             \n [43] pheatmap_1.0.12           edgeR_3.40.2             \n [45] spatstat.random_3.1-5     miniUI_0.1.1.1           \n [47] viridisLite_0.4.2         xtable_1.8-4             \n [49] dqrng_0.3.0               rsvd_1.0.5               \n [51] ResidualMatrix_1.8.0      metapod_1.6.0            \n [53] htmlwidgets_1.6.2         httr_1.4.6               \n [55] RColorBrewer_1.1-3        ellipsis_0.3.2           \n [57] Seurat_4.3.0.1            ica_1.0-3                \n [59] pkgconfig_2.0.3           farver_2.1.1             \n [61] deldir_1.0-9              uwot_0.1.16              \n [63] locfit_1.5-9.8            utf8_1.2.3               \n [65] here_1.0.1                reshape2_1.4.4           \n [67] tidyselect_1.2.0          labeling_0.4.2           \n [69] rlang_1.1.1               later_1.3.1              \n [71] munsell_0.5.0             tools_4.2.3              \n [73] cli_3.6.1                 generics_0.1.3           \n [75] ggridges_0.5.4            stringr_1.5.0            \n [77] batchelor_1.14.1          evaluate_0.21            \n [79] fastmap_1.1.1             goftest_1.2-3            \n [81] yaml_2.3.7                knitr_1.43               \n [83] fitdistrplus_1.1-11       purrr_1.0.1              \n [85] RANN_2.6.1                nlme_3.1-162             \n [87] pbapply_1.7-2             future_1.33.0            \n [89] sparseMatrixStats_1.10.0  mime_0.12                \n [91] compiler_4.2.3            rstudioapi_0.14          \n [93] beeswarm_0.4.0            plotly_4.10.2            \n [95] png_0.1-8                 spatstat.utils_3.0-3     \n [97] tibble_3.2.1              statmod_1.5.0            \n [99] stringi_1.7.12            lattice_0.20-45          \n[101] bluster_1.8.0             Matrix_1.6-0             \n[103] vctrs_0.6.3               pillar_1.9.0             \n[105] lifecycle_1.0.3           spatstat.geom_3.2-1      \n[107] lmtest_0.9-40             RcppAnnoy_0.0.21         \n[109] BiocNeighbors_1.16.0      data.table_1.14.8        \n[111] bitops_1.0-7              irlba_2.3.5.1            \n[113] httpuv_1.6.11             patchwork_1.1.2          \n[115] R6_2.5.1                  promises_1.2.0.1         \n[117] KernSmooth_2.23-20        gridExtra_2.3            \n[119] vipor_0.4.5               parallelly_1.36.0        \n[121] codetools_0.2-19          MASS_7.3-58.2            \n[123] rprojroot_2.0.3           withr_2.5.0              \n[125] SeuratObject_4.1.3        sctransform_0.3.5        \n[127] GenomeInfoDbData_1.2.9    parallel_4.2.3           \n[129] grid_4.2.3                beachmat_2.14.2          \n[131] tidyr_1.3.0               rmarkdown_2.21           \n[133] DelayedMatrixStats_1.20.0 Rtsne_0.16               \n[135] spatstat.explore_3.2-1    shiny_1.7.4              \n[137] ggbeeswarm_0.7.2"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html",
    "href": "labs/scanpy/scanpy_03_integration.html",
    "title": " Data Integration",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run Python commands unless it starts with %%bash, in which case, those chunks run shell commands.\nIn this tutorial we will look at different ways of integrating multiple single cell RNA-seq datasets. We will explore two different methods to correct for batch effects across datasets. We will also look at a quantitative measure to assess the quality of the integrated data. Seurat uses the data integration method presented in Comprehensive Integration of Single Cell Data, while Scran and Scanpy use a mutual Nearest neighbour method (MNN). Below you can find a list of the most recent methods for single data integration:"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html#meta-int_prep",
    "href": "labs/scanpy/scanpy_03_integration.html#meta-int_prep",
    "title": " Data Integration",
    "section": "1 Data preparation",
    "text": "1 Data preparation\nLet’s first load necessary libraries and the data saved in the previous lab.\n\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3             \n\nsc.settings.set_figure_params(dpi=80)\n%matplotlib inline\n\nCreate individual adata objects per batch.\n\n# Load the stored data object\nsave_file = './data/results/scanpy_dr_covid.h5ad'\nadata = sc.read_h5ad(save_file)\n\nprint(adata.X.shape)\n\n(5646, 3090)\n\n\nAs the stored AnnData object contains scaled data based on variable genes, we need to make a new object with the logtransformed normalized counts. The new variable gene selection should not be performed on the scaled data matrix.\n\nadata2 = adata.raw.to_adata() \n\nadata2.uns['log1p']['base']=None\n\n# check that the matrix looks like normalized counts\nprint(adata2.X[1:10,1:10])\n\n  (0, 5)    0.9678402572038912\n  (1, 5)    0.5124039238100646"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html#detect-variable-genes",
    "href": "labs/scanpy/scanpy_03_integration.html#detect-variable-genes",
    "title": " Data Integration",
    "section": "2 Detect variable genes",
    "text": "2 Detect variable genes\nVariable genes can be detected across the full dataset, but then we run the risk of getting many batch-specific genes that will drive a lot of the variation. Or we can select variable genes from each batch separately to get only celltype variation. In the dimensionality reduction exercise, we already selected variable genes, so they are already stored in adata.var.highly_variable.\n\nvar_genes_all = adata.var.highly_variable\n\nprint(\"Highly variable genes: %d\"%sum(var_genes_all))\n\nHighly variable genes: 3090\n\n\nDetect variable genes in each dataset separately using the batch_key parameter.\n\nsc.pp.highly_variable_genes(adata2, min_mean=0.0125, max_mean=3, min_disp=0.5, batch_key = 'sample')\n\nprint(\"Highly variable genes intersection: %d\"%sum(adata2.var.highly_variable_intersection))\n\nprint(\"Number of batches where gene is variable:\")\nprint(adata2.var.highly_variable_nbatches.value_counts())\n\nvar_genes_batch = adata2.var.highly_variable_nbatches &gt; 0\n\nHighly variable genes intersection: 147\nNumber of batches where gene is variable:\n0    8103\n1    4754\n2    3154\n3    1638\n4     705\n5     251\n6     147\nName: highly_variable_nbatches, dtype: int64\n\n\nCompare overlap of variable genes with batches or with all data.\n\nprint(\"Any batch var genes: %d\"%sum(var_genes_batch))\nprint(\"All data var genes: %d\"%sum(var_genes_all))\nprint(\"Overlap: %d\"%sum(var_genes_batch & var_genes_all))\nprint(\"Variable genes in all batches: %d\"%sum(adata2.var.highly_variable_nbatches == 6))\nprint(\"Overlap batch instersection and all: %d\"%sum(var_genes_all & adata2.var.highly_variable_intersection))\n\nAny batch var genes: 10649\nAll data var genes: 3090\nOverlap: 3086\nVariable genes in all batches: 147\nOverlap batch instersection and all: 147\n\n\nSelect all genes that are variable in at least 2 datasets and use for remaining analysis.\n\nvar_select = adata2.var.highly_variable_nbatches &gt; 2\nvar_genes = var_select.index[var_select]\nlen(var_genes)\n\n2741"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html#bbknn",
    "href": "labs/scanpy/scanpy_03_integration.html#bbknn",
    "title": " Data Integration",
    "section": "3 BBKNN",
    "text": "3 BBKNN\nFirst, we will run BBKNN that is implemented in scanpy.\n\nimport bbknn\nbbknn.bbknn(adata2,batch_key='sample')\n\n# then run umap on the integrated space\nsc.tl.umap(adata2)\nsc.tl.tsne(adata2)\n\nWe can now plot the unintegrated and the integrated space reduced dimensions.\n\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.tsne(adata2, color=\"sample\", title=\"BBKNN Corrected tsne\", ax=axs[0,0], show=False)\nsc.pl.tsne(adata, color=\"sample\", title=\"Uncorrected tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN Corrected umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected umap\", ax=axs[1,1], show=False)\n\n&lt;AxesSubplot: title={'center': 'Uncorrected umap'}, xlabel='UMAP1', ylabel='UMAP2'&gt;\n\n\n\n\n\n\n\n\n\nLet’s save the integrated data for further analysis.\n\nsave_file = './data/results/scanpy_bbknn_corrected_covid.h5ad'\nadata2.write_h5ad(save_file)"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html#combat",
    "href": "labs/scanpy/scanpy_03_integration.html#combat",
    "title": " Data Integration",
    "section": "4 Combat",
    "text": "4 Combat\nBatch correction can also be performed with combat. Note that ComBat batch correction requires a dense matrix format as input (which is already the case in this example).\n\n# create a new object with lognormalized counts\nadata_combat = sc.AnnData(X=adata.raw.X, var=adata.raw.var, obs = adata.obs)\n\n# first store the raw data \nadata_combat.raw = adata_combat\n\n# run combat\nsc.pp.combat(adata_combat, key='sample')\n\nFound 25 genes with zero variance.\n\n\nThen we run the regular steps of dimensionality reduction on the combat corrected data. Variable gene selection, pca and umap with combat data.\n\nsc.pp.highly_variable_genes(adata_combat)\nprint(\"Highly variable genes: %d\"%sum(adata_combat.var.highly_variable))\nsc.pl.highly_variable_genes(adata_combat)\n\nsc.pp.pca(adata_combat, n_comps=30, use_highly_variable=True, svd_solver='arpack')\n\nsc.pp.neighbors(adata_combat)\n\nsc.tl.umap(adata_combat)\nsc.tl.tsne(adata_combat)\n\nHighly variable genes: 3915\n\n\n\n\n\n\n\n\n\n\n# compare var_genes\nvar_genes_combat = adata_combat.var.highly_variable\nprint(\"With all data %d\"%sum(var_genes_all))\nprint(\"With combat %d\"%sum(var_genes_combat))\nprint(\"Overlap %d\"%sum(var_genes_all & var_genes_combat))\n\nprint(\"With 2 batches %d\"%sum(var_select))\nprint(\"Overlap %d\"%sum(var_genes_combat & var_select))\n\nWith all data 3090\nWith combat 3915\nOverlap 2268\nWith 2 batches 2741\nOverlap 2040\n\n\nWe can now plot the unintegrated and the integrated space reduced dimensions.\n\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.tsne(adata2, color=\"sample\", title=\"BBKNN tsne\", ax=axs[0,0], show=False)\nsc.pl.tsne(adata_combat, color=\"sample\", title=\"Combat tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata_combat, color=\"sample\", title=\"Combat umap\", ax=axs[1,1], show=False)\n\n&lt;AxesSubplot: title={'center': 'Combat umap'}, xlabel='UMAP1', ylabel='UMAP2'&gt;\n\n\n\n\n\n\n\n\n\nLet’s save the integrated data for further analysis.\n\n#save to file\nsave_file = './data/results/scanpy_combat_corrected_covid.h5ad'\nadata_combat.write_h5ad(save_file)"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html#meta-int_scanorama",
    "href": "labs/scanpy/scanpy_03_integration.html#meta-int_scanorama",
    "title": " Data Integration",
    "section": "5 Scanorama",
    "text": "5 Scanorama\nTry out Scanorama for data integration as well. First we need to create individual AnnData objects from each of the datasets.\n\n# split per batch into new objects.\nbatches = adata.obs['sample'].cat.categories.tolist()\nalldata = {}\nfor batch in batches:\n    alldata[batch] = adata2[adata2.obs['sample'] == batch,]\n\nalldata   \n\n{'covid_1': View of AnnData object with n_obs × n_vars = 844 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'covid_15': View of AnnData object with n_obs × n_vars = 583 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'covid_17': View of AnnData object with n_obs × n_vars = 1018 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_5': View of AnnData object with n_obs × n_vars = 1028 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_13': View of AnnData object with n_obs × n_vars = 1132 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances',\n 'ctrl_14': View of AnnData object with n_obs × n_vars = 1041 × 18752\n     obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n     var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n     uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n     obsm: 'X_pca', 'X_tsne', 'X_umap'\n     obsp: 'connectivities', 'distances'}\n\n\n\nimport scanorama\n\n#subset the individual dataset to the variable genes we defined at the beginning\nalldata2 = dict()\nfor ds in alldata.keys():\n    print(ds)\n    alldata2[ds] = alldata[ds][:,var_genes]\n\n#convert to list of AnnData objects\nadatas = list(alldata2.values())\n\n# run scanorama.integrate\nscanorama.integrate_scanpy(adatas, dimred = 50)\n\ncovid_1\ncovid_15\ncovid_17\nctrl_5\nctrl_13\nctrl_14\nFound 2741 genes among all datasets\n[[0.         0.78216123 0.3497053  0.57345972 0.45260664 0.40521327]\n [0.         0.         0.55403087 0.5        0.31903945 0.37049743]\n [0.         0.         0.         0.36770428 0.10314342 0.1453831 ]\n [0.         0.         0.         0.         0.86770428 0.72568093]\n [0.         0.         0.         0.         0.         0.85424028]\n [0.         0.         0.         0.         0.         0.        ]]\nProcessing datasets (3, 4)\nProcessing datasets (4, 5)\nProcessing datasets (0, 1)\nProcessing datasets (3, 5)\nProcessing datasets (0, 3)\nProcessing datasets (1, 2)\nProcessing datasets (1, 3)\nProcessing datasets (0, 4)\nProcessing datasets (0, 5)\nProcessing datasets (1, 5)\nProcessing datasets (2, 3)\nProcessing datasets (0, 2)\nProcessing datasets (1, 4)\nProcessing datasets (2, 5)\nProcessing datasets (2, 4)\n\n\n\n#scanorama adds the corrected matrix to adata.obsm in each of the datasets in adatas.\nadatas[0].obsm['X_scanorama'].shape\n\n(844, 50)\n\n\n\n# Get all the integrated matrices.\nscanorama_int = [ad.obsm['X_scanorama'] for ad in adatas]\n\n# make into one matrix.\nall_s = np.concatenate(scanorama_int)\nprint(all_s.shape)\n\n# add to the AnnData object, create a new object first\nadata_sc = adata.copy()\nadata_sc.obsm[\"Scanorama\"] = all_s\n\n(5646, 50)\n\n\n\n# tsne and umap\nsc.pp.neighbors(adata_sc, n_pcs =30, use_rep = \"Scanorama\")\nsc.tl.umap(adata_sc)\nsc.tl.tsne(adata_sc, n_pcs = 30, use_rep = \"Scanorama\")\n\nWe can now plot the unintegrated and the integrated space reduced dimensions.\n\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN tsne\", ax=axs[0,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Scanorama tsne\", ax=axs[0,1], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN umap\", ax=axs[1,0], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Scanorama umap\", ax=axs[1,1], show=False)\n\n&lt;AxesSubplot: title={'center': 'Scanorama umap'}, xlabel='UMAP1', ylabel='UMAP2'&gt;\n\n\n\n\n\n\n\n\n\nLet’s save the integrated data for further analysis.\n\n#save to file\nsave_file = './data/results/scanpy_scanorama_corrected_covid.h5ad'\nadata_sc.write_h5ad(save_file)"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html#compare-all",
    "href": "labs/scanpy/scanpy_03_integration.html#compare-all",
    "title": " Data Integration",
    "section": "6 Compare all",
    "text": "6 Compare all\n\n\n\n\n\n\nDiscuss\n\n\n\nPlot umap of all the methods we tested here. Which do you think looks better and why?\n\n\n\nfig, axs = plt.subplots(2, 2, figsize=(10,8),constrained_layout=True)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected\", ax=axs[0,0], show=False)\nsc.pl.umap(adata2, color=\"sample\", title=\"BBKNN\", ax=axs[0,1], show=False)\nsc.pl.umap(adata_combat, color=\"sample\", title=\"Combat\", ax=axs[1,0], show=False)\nsc.pl.umap(adata_sc, color=\"sample\", title=\"Scanorama\", ax=axs[1,1], show=False)\n\n&lt;AxesSubplot: title={'center': 'Scanorama'}, xlabel='UMAP1', ylabel='UMAP2'&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nHave a look at the documentation for BBKNN\nTry changing some of the parameteres in BBKNN, such as distance metric, number of PCs and number of neighbors. How does the results change with different parameters? Can you explain why?"
  },
  {
    "objectID": "labs/scanpy/scanpy_03_integration.html#meta-session",
    "href": "labs/scanpy/scanpy_03_integration.html#meta-session",
    "title": " Data Integration",
    "section": "7 Session info",
    "text": "7 Session info\n\nsc.logging.print_versions()\n\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nannoy                       NA\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbbknn                       1.6.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfbpca                       NA\nfqdn                        NA\nget_version                 3.5.4\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nintervaltree                NA\nipykernel                   6.25.2\nipywidgets                  8.1.1\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npatsy                       0.5.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npycparser                   2.21\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npynndescent                 0.5.10\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanorama                   1.7.3\nscanpy                      1.7.2\nscipy                       1.10.1\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nsortedcontainers            2.4.0\nstack_data                  0.6.2\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntqdm                        4.65.0\ntraitlets                   5.11.2\ntyping_extensions           NA\numap                        0.5.4\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-10 19:13"
  },
  {
    "objectID": "labs/scanpy/scanpy_04_clustering.html",
    "href": "labs/scanpy/scanpy_04_clustering.html",
    "title": " Clustering",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run Python commands unless it starts with %%bash, in which case, those chunks run shell commands.\nIn this tutorial we will continue the analysis of the integrated dataset. We will use the scanpy enbedding to perform the clustering using graph community detection algorithms.\nLet’s first load all necessary libraries and also the integrated dataset from the previous step.\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 3             \nsc.settings.set_figure_params(dpi=80)\n# select the scanorama integration data.\n\nsave_file = './data/results/scanpy_scanorama_corrected_covid.h5ad'\nadata = sc.read_h5ad(save_file)\n\nadata\n\nAnnData object with n_obs × n_vars = 5646 × 3090\n    obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'\n    uns: 'doublet_info_colors', 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'umap'\n    obsm: 'Scanorama', 'X_pca', 'X_tsne', 'X_umap'\n    varm: 'PCs'\n    obsp: 'connectivities', 'distances'"
  },
  {
    "objectID": "labs/scanpy/scanpy_04_clustering.html#meta-clust_graphclust",
    "href": "labs/scanpy/scanpy_04_clustering.html#meta-clust_graphclust",
    "title": " Clustering",
    "section": "1 Graph clustering",
    "text": "1 Graph clustering\nThe procedure of clustering on a Graph can be generalized as 3 main steps: 1) Build a kNN graph from the data 2) Prune spurious connections from kNN graph (optional step). This is a SNN graph. 3) Find groups of cells that maximizes the connections within the group compared other groups.\nIf you recall from the integration, we already constructed a knn graph before running UMAP. Hence we do not need to do it again, and can run the community detection right away.\nThe modularity optimization algoritm in Scanpy are Leiden and Louvain. Lets test both and see how they compare.\n\n1.1 Leiden\n\nsc.tl.leiden(adata, key_added = \"leiden_1.0\") # default resolution in 1.0\nsc.tl.leiden(adata, resolution = 0.6, key_added = \"leiden_0.6\")\nsc.tl.leiden(adata, resolution = 0.4, key_added = \"leiden_0.4\")\nsc.tl.leiden(adata, resolution = 1.4, key_added = \"leiden_1.4\")\n\nPlot the clusters, as you can see, with increased resolution, we get higher granularity in the clustering.\n\nsc.pl.umap(adata, color=['leiden_0.4', 'leiden_0.6', 'leiden_1.0','leiden_1.4'])\n\n\n\n\n\n\n\n\nOnce we have done clustering, the relationships between clusters can be calculated as correlation in PCA space and we also visualize some of the marker genes that we used in the Dim Reduction lab onto the clusters.\n\nsc.tl.dendrogram(adata, groupby = \"leiden_0.6\")\nsc.pl.dendrogram(adata, groupby = \"leiden_0.6\")\n\ngenes  = [\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"FCGR3A\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR1A\"]\nsc.pl.dotplot(adata, genes, groupby='leiden_0.6', dendrogram=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot proportion of cells from each condition per cluster.\n\ntmp = pd.crosstab(adata.obs['leiden_0.6'],adata.obs['type'], normalize='index')\ntmp.plot.bar(stacked=True).legend(loc='upper right')\n\n&lt;matplotlib.legend.Legend at 0x7fffd81f6850&gt;\n\n\n\n\n\n\n\n\n\n\n\n1.2 Louvain\n\nsc.tl.louvain(adata, key_added = \"louvain_1.0\") # default resolution in 1.0\nsc.tl.louvain(adata, resolution = 0.6, key_added = \"louvain_0.6\")\nsc.tl.louvain(adata, resolution = 0.4, key_added = \"louvain_0.4\")\nsc.tl.louvain(adata, resolution = 1.4, key_added = \"louvain_1.4\")\n\nsc.pl.umap(adata, color=['louvain_0.4', 'louvain_0.6', 'louvain_1.0','louvain_1.4'])\n\nsc.tl.dendrogram(adata, groupby = \"louvain_0.6\")\nsc.pl.dendrogram(adata, groupby = \"louvain_0.6\")\n\ngenes  = [\"CD3E\", \"CD4\", \"CD8A\", \"GNLY\",\"NKG7\", \"MS4A1\",\"FCGR3A\",\"CD14\",\"LYZ\",\"CST3\",\"MS4A7\",\"FCGR1A\"]\n\nsc.pl.dotplot(adata, genes, groupby='louvain_0.6', dendrogram=True)"
  },
  {
    "objectID": "labs/scanpy/scanpy_04_clustering.html#meta-clust_kmean",
    "href": "labs/scanpy/scanpy_04_clustering.html#meta-clust_kmean",
    "title": " Clustering",
    "section": "2 K-means clustering",
    "text": "2 K-means clustering\nK-means is a generic clustering algorithm that has been used in many application areas. In R, it can be applied via the kmeans function. Typically, it is applied to a reduced dimension representation of the expression data (most often PCA, because of the interpretability of the low-dimensional distances). We need to define the number of clusters in advance. Since the results depend on the initialization of the cluster centers, it is typically recommended to run K-means with multiple starting configurations (via the nstart argument).\n\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import adjusted_rand_score\n\n# extract pca coordinates\nX_pca = adata.obsm['Scanorama'] \n\n# kmeans with k=5\nkmeans = KMeans(n_clusters=5, random_state=0).fit(X_pca) \nadata.obs['kmeans5'] = kmeans.labels_.astype(str)\n\n# kmeans with k=10\nkmeans = KMeans(n_clusters=10, random_state=0).fit(X_pca) \nadata.obs['kmeans10'] = kmeans.labels_.astype(str)\n\n# kmeans with k=15\nkmeans = KMeans(n_clusters=15, random_state=0).fit(X_pca) \nadata.obs['kmeans15'] = kmeans.labels_.astype(str)\n\nsc.pl.umap(adata, color=['kmeans5', 'kmeans10', 'kmeans15'])\n\nadata.obsm\n\n\n\n\n\n\n\n\nAxisArrays with keys: Scanorama, X_pca, X_tsne, X_umap"
  },
  {
    "objectID": "labs/scanpy/scanpy_04_clustering.html#meta-clust_hier",
    "href": "labs/scanpy/scanpy_04_clustering.html#meta-clust_hier",
    "title": " Clustering",
    "section": "3 Hierarchical clustering",
    "text": "3 Hierarchical clustering\nHierarchical clustering is another generic form of clustering that can be applied also to scRNA-seq data. As K-means, it is typically applied to a reduced dimension representation of the data. Hierarchical clustering returns an entire hierarchy of partitionings (a dendrogram) that can be cut at different levels. Hierarchical clustering is done in these steps:\n\nDefine the distances between samples. The most common are Euclidean distance (a.k.a. straight line between two points) or correlation coefficients.\nDefine a measure of distances between clusters, called linkage criteria. It can for example be average distances between clusters. Commonly used methods are single, complete, average, median, centroid and ward.\nDefine the dendrogram among all samples using Bottom-up or Top-down approach. Bottom-up is where samples start with their own cluster which end up merged pair-by-pair until only one cluster is left. Top-down is where samples start all in the same cluster that end up being split by 2 until each sample has its own cluster.\n\nAs you might have realized, correlation is not a method implemented in the dist() function. However, we can create our own distances and transform them to a distance object. We can first compute sample correlations using the cor function.\nAs you already know, correlation range from -1 to 1, where 1 indicates that two samples are closest, -1 indicates that two samples are the furthest and 0 is somewhat in between. This, however, creates a problem in defining distances because a distance of 0 indicates that two samples are closest, 1 indicates that two samples are the furthest and distance of -1 is not meaningful. We thus need to transform the correlations to a positive scale (a.k.a. adjacency):\n[adj = ]\nOnce we transformed the correlations to a 0-1 scale, we can simply convert it to a distance object using as.dist function. The transformation does not need to have a maximum of 1, but it is more intuitive to have it at 1, rather than at any other number.\nThe function AgglomerativeClustering has the option of running with disntance metrics “euclidean”, “l1”, “l2”, “manhattan”, “cosine”, or “precomputed”. However, with ward linkage only euklidean distances works. Here we will try out euclidean distance and ward linkage calculated in PCA space.\n\nfrom sklearn.cluster import AgglomerativeClustering\n\ncluster = AgglomerativeClustering(n_clusters=5, affinity='euclidean', linkage='ward')\nadata.obs['hclust_5'] = cluster.fit_predict(X_pca).astype(str)\n\ncluster = AgglomerativeClustering(n_clusters=10, affinity='euclidean', linkage='ward')\nadata.obs['hclust_10'] = cluster.fit_predict(X_pca).astype(str)\n\ncluster = AgglomerativeClustering(n_clusters=15, affinity='euclidean', linkage='ward')\nadata.obs['hclust_15'] = cluster.fit_predict(X_pca).astype(str)\n\nsc.pl.umap(adata, color=['hclust_5', 'hclust_10', 'hclust_15'])\n\n\n\n\n\n\n\n\nFinally, lets save the clustered data for further analysis.\n\nadata.write_h5ad('./data/results/scanpy_clustered_covid.h5ad')\n\n\n\n\n\n\n\nDiscuss\n\n\n\nBy now you should know how to plot different features onto your data. Take the QC metrics that were calculated in the first exercise, that should be stored in your data object, and plot it as violin plots per cluster using the clustering method of your choice. For example, plot number of UMIS, detected genes, percent mitochondrial reads. Then, check carefully if there is any bias in how your data is separated due to quality metrics. Could it be explained biologically, or could you have technical bias there?"
  },
  {
    "objectID": "labs/scanpy/scanpy_04_clustering.html#meta-session",
    "href": "labs/scanpy/scanpy_04_clustering.html#meta-session",
    "title": " Clustering",
    "section": "4 Session info",
    "text": "4 Session info\n\nsc.logging.print_versions()\n\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfqdn                        NA\nget_version                 3.5.4\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nipykernel                   6.25.2\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanpy                      1.7.2\nscipy                       1.10.1\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nstack_data                  0.6.2\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntraitlets                   5.11.2\ntyping_extensions           NA\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-10 19:14"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html",
    "href": "labs/seurat/seurat_05_dge.html",
    "title": " Differential gene expression",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nIn this tutorial we will cover about Differetial gene expression, which comprises an extensive range of topics and methods. In single cell, differential expresison can have multiple functionalities such as of identifying marker genes for cell populations, as well as differentially regulated genes across conditions (healthy vs control). We will also exercise on how to account the batch information in your test.\nWe can first load the data from the clustering session. Moreover, we can already decide which clustering resolution to use. First let’s define using the louvain clustering to identifying differentially expressed genes.\nsuppressPackageStartupMessages({\n  library(Seurat)\n  library(dplyr)\n  library(cowplot)\n  library(ggplot2)\n  library(pheatmap)\n  library(enrichR)\n  library(rafalib)\n  library(Matrix)\n  library(edgeR)\n  library(MAST)\n})\n\nalldata &lt;- readRDS(\"data/results/covid_qc_dr_int_cl.rds\")\n#Set the identity as louvain with resolution 0.5\nsel.clust = \"CCA_snn_res.0.5\"\n\nalldata &lt;- SetIdent(alldata, value = sel.clust)\ntable(alldata@active.ident)\n\n\n   0    1    2    3    4    5    6    7    8    9 \n1526 1024  569  437  427  411  410  272  241  215\n# plot this clustering\nplot_grid(ncol = 3,\n  DimPlot(alldata, label = T) + NoAxes(),\n  DimPlot(alldata, group.by = \"orig.ident\") + NoAxes(),\n  DimPlot(alldata, group.by = \"type\") + NoAxes() )"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#meta-dge_cmg",
    "href": "labs/seurat/seurat_05_dge.html#meta-dge_cmg",
    "title": " Differential gene expression",
    "section": "1 Cell marker genes",
    "text": "1 Cell marker genes\nLet us first compute a ranking for the highly differential genes in each cluster. There are many different tests and parameters to be chosen that can be used to refine your results. When looking for marker genes, we want genes that are positivelly expressed in a cell type and possibly not expressed in the others.\n\n#Compute differentiall expression\nmarkers_genes &lt;- FindAllMarkers(\n    alldata,\n    log2FC.threshold = 0.2,\n    test.use = \"wilcox\",\n    min.pct = 0.1,\n    min.diff.pct = 0.2,\n    only.pos = TRUE,\n    max.cells.per.ident = 50,\n    assay = \"RNA\"\n)\n\nWe can now select the top 25 up regulated genes for plotting.\n\nmarkers_genes %&gt;% group_by(cluster)  %&gt;% top_n(-25, p_val_adj) -&gt; top25\ntop25\n\n\n\n\n\np_val\navg_log2FC\npct.1\npct.2\np_val_adj\ncluster\ngene\n\n\n\n\n0.0000000\n2.7526588\n0.968\n0.094\n0.0000000\n0\nMNDA\n\n\n0.0000000\n3.2319551\n0.986\n0.105\n0.0000000\n0\nAC020656.1\n\n\n0.0000000\n2.8642486\n0.935\n0.042\n0.0000000\n0\nCD14\n\n\n0.0000000\n3.3691875\n0.965\n0.055\n0.0000000\n0\nVCAN\n\n\n0.0000000\n1.7500035\n0.954\n0.342\n0.0000000\n0\nTALDO1\n\n\n0.0000000\n3.8952712\n1.000\n0.246\n0.0000000\n0\nLYZ\n\n\n0.0000000\n2.3230422\n0.951\n0.066\n0.0000000\n0\nCSTA\n\n\n0.0000000\n2.3830375\n0.933\n0.047\n0.0000000\n0\nMS4A6A\n\n\n0.0000000\n1.7313056\n0.854\n0.106\n0.0000000\n0\nBLVRB\n\n\n0.0000000\n5.1343922\n0.991\n0.242\n0.0000000\n0\nS100A8\n\n\n0.0000000\n3.0595649\n0.992\n0.118\n0.0000000\n0\nFCN1\n\n\n0.0000000\n2.4519054\n0.967\n0.158\n0.0000000\n0\nGRN\n\n\n0.0000000\n2.1434163\n0.950\n0.145\n0.0000000\n0\nCYBB\n\n\n0.0000000\n3.8399333\n0.940\n0.050\n0.0000000\n0\nS100A12\n\n\n0.0000000\n2.0850701\n0.923\n0.074\n0.0000000\n0\nCSF3R\n\n\n0.0000000\n1.8996634\n0.885\n0.069\n0.0000000\n0\nTNFSF13B\n\n\n0.0000000\n1.6144428\n0.845\n0.077\n0.0000000\n0\nCFP\n\n\n0.0000000\n1.8966813\n0.804\n0.064\n0.0000000\n0\nPLAUR\n\n\n0.0000000\n4.3722734\n0.996\n0.331\n0.0000000\n0\nS100A9\n\n\n0.0000000\n1.8966255\n0.880\n0.083\n0.0000000\n0\nMPEG1\n\n\n0.0000000\n1.8575946\n0.822\n0.030\n0.0000000\n0\nCD36\n\n\n0.0000000\n2.3719547\n0.980\n0.283\n0.0000000\n0\nTYMP\n\n\n0.0000000\n1.6972589\n0.774\n0.059\n0.0000000\n0\nIGSF6\n\n\n0.0000000\n1.8142623\n0.940\n0.172\n0.0000000\n0\nSPI1\n\n\n0.0000000\n1.9486618\n0.985\n0.444\n0.0000000\n0\nBRI3\n\n\n0.0000000\n2.1197633\n0.937\n0.186\n0.0000000\n1\nCD3D\n\n\n0.0000000\n1.7399391\n0.983\n0.326\n0.0000000\n1\nIL32\n\n\n0.0000000\n1.7001176\n0.951\n0.274\n0.0000000\n1\nCD3E\n\n\n0.0000000\n1.8916915\n0.855\n0.163\n0.0000000\n1\nCD3G\n\n\n0.0000000\n1.9508589\n0.990\n0.391\n0.0000000\n1\nCCL5\n\n\n0.0000000\n1.9918666\n0.844\n0.190\n0.0000001\n1\nGZMH\n\n\n0.0000000\n1.2439355\n0.958\n0.297\n0.0000017\n1\nCST7\n\n\n0.0000000\n1.3598355\n0.897\n0.258\n0.0000029\n1\nGZMM\n\n\n0.0000000\n1.5860847\n0.730\n0.170\n0.0000060\n1\nTRAC\n\n\n0.0000000\n1.2195821\n0.779\n0.275\n0.0000094\n1\nRORA\n\n\n0.0000000\n1.7022563\n0.586\n0.057\n0.0000094\n1\nTRGC2\n\n\n0.0000000\n1.6195271\n0.782\n0.238\n0.0000121\n1\nLYAR\n\n\n0.0000000\n1.5359565\n0.630\n0.073\n0.0000181\n1\nKLRG1\n\n\n0.0000000\n0.9634264\n0.680\n0.234\n0.0000182\n1\nLCK\n\n\n0.0000000\n1.0054477\n0.933\n0.656\n0.0000186\n1\nCD99\n\n\n0.0000000\n1.4580271\n0.782\n0.344\n0.0000277\n1\nTRBC2\n\n\n0.0000000\n1.3792771\n0.987\n0.393\n0.0000303\n1\nNKG7\n\n\n0.0000000\n1.0898390\n0.910\n0.614\n0.0000681\n1\nPPP2R5C\n\n\n0.0000000\n0.9353046\n0.850\n0.258\n0.0001137\n1\nCTSW\n\n\n0.0000000\n1.3611959\n0.914\n0.229\n0.0001206\n1\nGZMA\n\n\n0.0000000\n1.0426451\n0.547\n0.139\n0.0002790\n1\nCD6\n\n\n0.0000000\n1.2231150\n0.718\n0.242\n0.0003982\n1\nSPOCK2\n\n\n0.0000000\n1.1521196\n0.924\n0.469\n0.0007262\n1\nARL4C\n\n\n0.0000001\n1.7942248\n0.461\n0.041\n0.0023063\n1\nCD8B\n\n\n0.0000001\n2.1761243\n0.554\n0.071\n0.0024786\n1\nCD8A\n\n\n0.0000000\n2.5673312\n0.888\n0.061\n0.0000000\n2\nLINC00926\n\n\n0.0000000\n3.5479370\n0.953\n0.028\n0.0000000\n2\nIGHD\n\n\n0.0000000\n3.2632570\n0.975\n0.073\n0.0000000\n2\nCD79A\n\n\n0.0000000\n2.4869435\n0.909\n0.065\n0.0000000\n2\nMS4A1\n\n\n0.0000000\n2.4543227\n0.898\n0.067\n0.0000000\n2\nTNFRSF13C\n\n\n0.0000000\n4.2481994\n0.993\n0.063\n0.0000000\n2\nIGHM\n\n\n0.0000000\n1.9517703\n0.974\n0.528\n0.0000000\n2\nHLA-DQB1\n\n\n0.0000000\n1.8712582\n0.991\n0.620\n0.0000000\n2\nHLA-DRA\n\n\n0.0000000\n2.6029720\n0.754\n0.009\n0.0000000\n2\nTCL1A\n\n\n0.0000000\n1.3983224\n0.882\n0.309\n0.0000000\n2\nHLA-DQA1\n\n\n0.0000000\n1.8661538\n0.838\n0.342\n0.0000000\n2\nYBX3\n\n\n0.0000000\n1.4055082\n0.782\n0.302\n0.0000000\n2\nHLA-DMB\n\n\n0.0000000\n2.1402108\n0.842\n0.067\n0.0000000\n2\nBANK1\n\n\n0.0000000\n1.7716880\n0.692\n0.045\n0.0000000\n2\nAFF3\n\n\n0.0000000\n1.5743969\n0.974\n0.671\n0.0000000\n2\nHLA-DPB1\n\n\n0.0000000\n1.7390066\n0.654\n0.050\n0.0000000\n2\nCD22\n\n\n0.0000000\n2.3666327\n0.882\n0.288\n0.0000000\n2\nCD83\n\n\n0.0000000\n1.1733758\n0.831\n0.391\n0.0000000\n2\nHLA-DMA\n\n\n0.0000000\n1.2422358\n0.970\n0.687\n0.0000000\n2\nHLA-DPA1\n\n\n0.0000000\n1.8599266\n0.652\n0.028\n0.0000001\n2\nFCER2\n\n\n0.0000000\n1.5011181\n0.991\n0.709\n0.0000001\n2\nHLA-DRB1\n\n\n0.0000000\n2.4677149\n0.880\n0.141\n0.0000002\n2\nCD79B\n\n\n0.0000000\n1.6227274\n0.691\n0.196\n0.0000002\n2\nMEF2C\n\n\n0.0000000\n1.6680884\n0.968\n0.640\n0.0000003\n2\nCXCR4\n\n\n0.0000000\n1.7441200\n0.576\n0.026\n0.0000015\n2\nVPREB3\n\n\n0.0000000\n2.6838843\n0.966\n0.249\n0.0000000\n3\nGZMB\n\n\n0.0000000\n2.6992432\n0.943\n0.303\n0.0000000\n3\nGNLY\n\n\n0.0000000\n2.7177799\n0.975\n0.257\n0.0000000\n3\nPRF1\n\n\n0.0000000\n1.9511722\n0.929\n0.221\n0.0000000\n3\nKLRD1\n\n\n0.0000000\n2.1798101\n0.961\n0.328\n0.0000000\n3\nCD247\n\n\n0.0000000\n2.1285090\n0.986\n0.314\n0.0000000\n3\nCTSW\n\n\n0.0000000\n2.1184086\n0.998\n0.460\n0.0000000\n3\nNKG7\n\n\n0.0000000\n2.8696770\n0.865\n0.155\n0.0000000\n3\nSPON2\n\n\n0.0000000\n2.4504964\n0.963\n0.311\n0.0000000\n3\nCD7\n\n\n0.0000000\n1.5817669\n0.961\n0.518\n0.0000000\n3\nARL4C\n\n\n0.0000000\n1.7449937\n0.860\n0.270\n0.0000000\n3\nHOPX\n\n\n0.0000000\n2.0803480\n0.826\n0.100\n0.0000000\n3\nKLRF1\n\n\n0.0000000\n2.0551746\n0.856\n0.233\n0.0000001\n3\nFGFBP2\n\n\n0.0000000\n1.9457480\n0.730\n0.109\n0.0000003\n3\nIL2RB\n\n\n0.0000000\n1.5510018\n0.847\n0.253\n0.0000004\n3\nFCGR3A\n\n\n0.0000000\n1.7732242\n0.970\n0.372\n0.0000004\n3\nCST7\n\n\n0.0000000\n1.7269154\n0.913\n0.330\n0.0000021\n3\nGZMM\n\n\n0.0000000\n1.8475681\n0.931\n0.307\n0.0000043\n3\nGZMA\n\n\n0.0000000\n1.1641590\n0.641\n0.126\n0.0000078\n3\nTRDC\n\n\n0.0000000\n1.4490119\n0.721\n0.190\n0.0000113\n3\nMATK\n\n\n0.0000000\n2.2783540\n0.792\n0.116\n0.0000190\n3\nCLIC3\n\n\n0.0000000\n2.1196619\n0.849\n0.155\n0.0000241\n3\nKLRB1\n\n\n0.0000000\n1.0421418\n0.899\n0.565\n0.0001150\n3\nEVL\n\n\n0.0000000\n1.5453623\n0.670\n0.139\n0.0001431\n3\nS1PR5\n\n\n0.0000000\n1.0330073\n0.950\n0.722\n0.0001492\n3\nHCST\n\n\n0.0000018\n0.2988093\n0.204\n0.512\n0.0325061\n4\nANP32A\n\n\n0.0000029\n0.2723390\n0.119\n0.324\n0.0532923\n4\nUBE2E3\n\n\n0.0000143\n0.4177866\n0.255\n0.621\n0.2593009\n4\nPSMB3\n\n\n0.0000189\n0.3143055\n0.234\n0.596\n0.3428810\n4\nVPS28\n\n\n0.0000389\n0.3770437\n0.150\n0.403\n0.7040597\n4\nPSMA5\n\n\n0.0000681\n0.2742818\n0.253\n0.676\n1.0000000\n4\nHSP90B1\n\n\n0.0000887\n0.4555457\n0.375\n0.833\n1.0000000\n4\nNDUFA4\n\n\n0.0001019\n0.3538337\n0.213\n0.485\n1.0000000\n4\nCNPY3\n\n\n0.0001083\n0.7004309\n0.330\n0.735\n1.0000000\n4\nSRSF3\n\n\n0.0001103\n0.3024741\n0.122\n0.360\n1.0000000\n4\nSLC25A37\n\n\n0.0001317\n0.3730835\n0.340\n0.745\n1.0000000\n4\nSLC25A3\n\n\n0.0001543\n0.4103063\n0.190\n0.557\n1.0000000\n4\nBUD31\n\n\n0.0001597\n0.2553024\n0.112\n0.423\n1.0000000\n4\nTANK\n\n\n0.0001859\n0.2577918\n0.119\n0.355\n1.0000000\n4\nACADVL\n\n\n0.0002145\n0.4244954\n0.230\n0.492\n1.0000000\n4\nNCF1\n\n\n0.0002344\n0.3075716\n0.176\n0.498\n1.0000000\n4\nCNN2\n\n\n0.0002362\n0.2845856\n0.176\n0.471\n1.0000000\n4\nTBCB\n\n\n0.0002960\n0.3496014\n0.138\n0.402\n1.0000000\n4\nSAMSN1\n\n\n0.0003125\n0.6001010\n0.258\n0.618\n1.0000000\n4\nFKBP8\n\n\n0.0003169\n0.6606672\n0.272\n0.668\n1.0000000\n4\nPAIP2\n\n\n0.0005251\n1.0546429\n0.222\n0.550\n1.0000000\n4\nRPS27L\n\n\n0.0005671\n0.3788727\n0.208\n0.517\n1.0000000\n4\nLENG8\n\n\n0.0005923\n0.2791057\n0.138\n0.411\n1.0000000\n4\nALYREF\n\n\n0.0006493\n0.4771722\n0.356\n0.820\n1.0000000\n4\nSSR4\n\n\n0.0006770\n0.3531958\n0.187\n0.499\n1.0000000\n4\nCOX14\n\n\n0.0007357\n0.4022996\n0.185\n0.476\n1.0000000\n4\nPRDX1\n\n\n0.0008248\n0.3898553\n0.222\n0.537\n1.0000000\n4\nCDC37\n\n\n0.0008741\n0.3048731\n0.314\n0.708\n1.0000000\n4\nCAP1\n\n\n0.0008965\n0.3744017\n0.141\n0.347\n1.0000000\n4\nCAPG\n\n\n0.0010065\n0.3383049\n0.230\n0.579\n1.0000000\n4\nMOB1A\n\n\n0.0010306\n0.5449567\n0.176\n0.423\n1.0000000\n4\nVPS29\n\n\n0.0010418\n0.3528579\n0.173\n0.500\n1.0000000\n4\nRNPEPL1\n\n\n0.0010775\n0.2590552\n0.286\n0.622\n1.0000000\n4\nARPC5\n\n\n0.0012104\n0.2692010\n0.227\n0.636\n1.0000000\n4\nPSMB8\n\n\n0.0012902\n0.2854584\n0.225\n0.567\n1.0000000\n4\nSELENOW\n\n\n0.0013181\n0.2911485\n0.166\n0.455\n1.0000000\n4\nZNHIT1\n\n\n0.0013731\n0.2900057\n0.276\n0.538\n1.0000000\n4\nVSIR\n\n\n0.0014171\n0.4942266\n0.187\n0.520\n1.0000000\n4\nCBX3\n\n\n0.0014769\n0.4119366\n0.244\n0.626\n1.0000000\n4\nUFC1\n\n\n0.0015938\n0.2664887\n0.239\n0.632\n1.0000000\n4\nDEK\n\n\n0.0016143\n0.2974176\n0.138\n0.356\n1.0000000\n4\nCOMT\n\n\n0.0017154\n1.0316015\n0.297\n0.615\n1.0000000\n4\nTLN1\n\n\n0.0017262\n0.3828282\n0.192\n0.499\n1.0000000\n4\nSRP9\n\n\n0.0017593\n0.3670353\n0.258\n0.684\n1.0000000\n4\nATP5MC3\n\n\n0.0017841\n0.4338332\n0.220\n0.520\n1.0000000\n4\nGDI2\n\n\n0.0017960\n0.2550626\n0.253\n0.696\n1.0000000\n4\nSPCS1\n\n\n0.0019403\n0.4663362\n0.304\n0.724\n1.0000000\n4\nCAPZB\n\n\n0.0020334\n0.4890508\n0.206\n0.538\n1.0000000\n4\nNDUFV2\n\n\n0.0021433\n0.3331404\n0.227\n0.570\n1.0000000\n4\nATF4\n\n\n0.0023289\n0.6341686\n0.185\n0.392\n1.0000000\n4\nPOLR2E\n\n\n0.0023637\n0.2775607\n0.199\n0.558\n1.0000000\n4\nCD47\n\n\n0.0024949\n0.5274088\n0.150\n0.362\n1.0000000\n4\nBANF1\n\n\n0.0025287\n0.2577544\n0.197\n0.458\n1.0000000\n4\nVAMP5\n\n\n0.0025513\n0.3158038\n0.131\n0.376\n1.0000000\n4\nPPA1\n\n\n0.0026168\n0.3177607\n0.150\n0.453\n1.0000000\n4\nMYDGF\n\n\n0.0026416\n0.3173584\n0.274\n0.654\n1.0000000\n4\nHMGN1\n\n\n0.0027843\n0.3456820\n0.309\n0.720\n1.0000000\n4\nMTRNR2L12\n\n\n0.0028137\n0.3882467\n0.136\n0.367\n1.0000000\n4\nUFD1\n\n\n0.0028508\n0.2526561\n0.169\n0.471\n1.0000000\n4\nNDUFB1\n\n\n0.0029444\n1.1541759\n0.239\n0.621\n1.0000000\n4\nEIF1B\n\n\n0.0029444\n0.4067909\n0.222\n0.531\n1.0000000\n4\nRNH1\n\n\n0.0029514\n0.3515765\n0.117\n0.320\n1.0000000\n4\nMRPS36\n\n\n0.0030004\n0.6744656\n0.234\n0.607\n1.0000000\n4\nHMGB2\n\n\n0.0031437\n0.3543233\n0.197\n0.524\n1.0000000\n4\nMDH2\n\n\n0.0031626\n0.2891805\n0.152\n0.460\n1.0000000\n4\nSLC3A2\n\n\n0.0032930\n0.3132672\n0.169\n0.445\n1.0000000\n4\nANAPC11\n\n\n0.0037322\n0.2625237\n0.265\n0.721\n1.0000000\n4\nPSMB1\n\n\n0.0039585\n0.2591684\n0.155\n0.398\n1.0000000\n4\nNINJ1\n\n\n0.0040982\n0.2752792\n0.328\n0.777\n1.0000000\n4\nTMBIM6\n\n\n0.0041672\n0.4100357\n0.262\n0.668\n1.0000000\n4\nDNAJB6\n\n\n0.0042678\n0.4482798\n0.255\n0.606\n1.0000000\n4\nCOX5A\n\n\n0.0043240\n0.3379529\n0.286\n0.642\n1.0000000\n4\nRHOG\n\n\n0.0045417\n0.3171592\n0.159\n0.427\n1.0000000\n4\nUBE2J1\n\n\n0.0045970\n0.4691792\n0.162\n0.405\n1.0000000\n4\nECH1\n\n\n0.0046360\n0.5159805\n0.262\n0.634\n1.0000000\n4\nCCND3\n\n\n0.0046929\n0.4012024\n0.347\n0.747\n1.0000000\n4\nATP5MPL\n\n\n0.0047906\n0.3100867\n0.180\n0.484\n1.0000000\n4\nRIOK3\n\n\n0.0048018\n0.5213637\n0.262\n0.663\n1.0000000\n4\nVAPA\n\n\n0.0051360\n0.3043846\n0.183\n0.531\n1.0000000\n4\nGHITM\n\n\n0.0051591\n0.2520745\n0.129\n0.379\n1.0000000\n4\nATP5MC1\n\n\n0.0052436\n0.3159085\n0.150\n0.355\n1.0000000\n4\nNAP1L4\n\n\n0.0054739\n0.2502194\n0.157\n0.383\n1.0000000\n4\nNDUFB3\n\n\n0.0061984\n0.3738119\n0.272\n0.686\n1.0000000\n4\nLDHA\n\n\n0.0063358\n0.4367972\n0.187\n0.436\n1.0000000\n4\nTCIRG1\n\n\n0.0063613\n0.4487245\n0.131\n0.344\n1.0000000\n4\nRANBP1\n\n\n0.0064773\n0.3251459\n0.244\n0.490\n1.0000000\n4\nANXA5\n\n\n0.0069505\n0.3185756\n0.379\n0.583\n1.0000000\n4\nTKT\n\n\n0.0072546\n0.2568988\n0.201\n0.590\n1.0000000\n4\nPSMD8\n\n\n0.0081254\n0.4479412\n0.211\n0.456\n1.0000000\n4\nGLRX\n\n\n0.0087306\n0.6791424\n0.225\n0.560\n1.0000000\n4\nUBE2B\n\n\n0.0088919\n0.2517301\n0.253\n0.541\n1.0000000\n4\nMT2A\n\n\n0.0091332\n0.6590616\n0.194\n0.429\n1.0000000\n4\nNUCB1\n\n\n0.0091673\n0.3144769\n0.145\n0.436\n1.0000000\n4\nCCT4\n\n\n0.0093966\n0.4977166\n0.136\n0.377\n1.0000000\n4\nTWF2\n\n\n0.0095685\n0.4724045\n0.244\n0.629\n1.0000000\n4\nRABAC1\n\n\n0.0098593\n0.6574115\n0.215\n0.463\n1.0000000\n4\nSUPT4H1\n\n\n0.0000000\n2.1835582\n0.954\n0.201\n0.0000000\n5\nIL7R\n\n\n0.0000000\n1.5521272\n0.959\n0.534\n0.0000000\n5\nLDHB\n\n\n0.0000000\n1.9994919\n0.966\n0.367\n0.0000005\n5\nLTB\n\n\n0.0000000\n1.5546844\n0.903\n0.223\n0.0000008\n5\nTRAC\n\n\n0.0000000\n1.2615428\n0.891\n0.466\n0.0000016\n5\nLEPROTL1\n\n\n0.0000000\n0.7583884\n0.825\n0.248\n0.0000017\n5\nCD3G\n\n\n0.0000000\n0.8749897\n0.900\n0.279\n0.0000062\n5\nCD3D\n\n\n0.0000000\n1.1747288\n0.637\n0.118\n0.0000268\n5\nRCAN3\n\n\n0.0000000\n0.9659632\n0.973\n0.769\n0.0000629\n5\nKLF2\n\n\n0.0000000\n0.7493338\n0.418\n0.070\n0.0006229\n5\nTNFRSF25\n\n\n0.0000000\n0.9536662\n0.866\n0.396\n0.0007254\n5\nPIK3IP1\n\n\n0.0000001\n1.1550876\n0.723\n0.327\n0.0011702\n5\nNOSIP\n\n\n0.0000001\n0.8406949\n0.944\n0.355\n0.0015218\n5\nCD3E\n\n\n0.0000001\n1.3557717\n0.616\n0.137\n0.0026848\n5\nGATA3\n\n\n0.0000002\n0.7322785\n0.589\n0.252\n0.0031747\n5\nPBXIP1\n\n\n0.0000002\n1.1042186\n0.552\n0.092\n0.0037396\n5\nAP3M2\n\n\n0.0000002\n0.9789553\n0.433\n0.039\n0.0043989\n5\nAQP3\n\n\n0.0000004\n0.8624605\n0.465\n0.055\n0.0071645\n5\nTRAT1\n\n\n0.0000006\n1.1023829\n0.988\n0.405\n0.0103659\n5\nIL32\n\n\n0.0000013\n0.5591513\n0.440\n0.146\n0.0231174\n5\nTMEM238\n\n\n0.0000015\n0.9232437\n0.667\n0.197\n0.0271442\n5\nTCF7\n\n\n0.0000026\n0.5799372\n0.353\n0.056\n0.0469254\n5\nLEF1\n\n\n0.0000029\n0.8312722\n0.781\n0.276\n0.0523095\n5\nCD2\n\n\n0.0000030\n1.1267097\n0.506\n0.037\n0.0547826\n5\nMAL\n\n\n0.0000037\n0.8512899\n0.912\n0.632\n0.0678694\n5\nGSTK1\n\n\n0.0000000\n2.2368672\n1.000\n0.463\n0.0000000\n6\nNKG7\n\n\n0.0000000\n2.1033868\n0.993\n0.373\n0.0000000\n6\nCST7\n\n\n0.0000000\n2.4543623\n0.968\n0.304\n0.0000000\n6\nGNLY\n\n\n0.0000000\n2.1177031\n0.856\n0.111\n0.0000000\n6\nTRDC\n\n\n0.0000000\n2.0447025\n0.971\n0.319\n0.0000000\n6\nCTSW\n\n\n0.0000000\n2.4886234\n0.949\n0.229\n0.0000000\n6\nFGFBP2\n\n\n0.0000000\n2.0601598\n0.988\n0.251\n0.0000000\n6\nGZMB\n\n\n0.0000000\n2.0133462\n0.976\n0.258\n0.0000002\n6\nGZMH\n\n\n0.0000000\n1.7644637\n0.951\n0.332\n0.0000003\n6\nCD247\n\n\n0.0000000\n1.6396709\n0.873\n0.272\n0.0000005\n6\nHOPX\n\n\n0.0000000\n1.9224617\n0.995\n0.462\n0.0000007\n6\nCCL5\n\n\n0.0000000\n1.8988617\n0.922\n0.265\n0.0000026\n6\nPRF1\n\n\n0.0000000\n1.1623674\n0.917\n0.629\n0.0000072\n6\nCD81\n\n\n0.0000000\n2.0054956\n0.529\n0.026\n0.0000268\n6\nKLRC2\n\n\n0.0000000\n1.2552884\n0.644\n0.144\n0.0000319\n6\nS1PR5\n\n\n0.0000000\n1.8632307\n0.917\n0.226\n0.0000373\n6\nKLRD1\n\n\n0.0000000\n1.3033563\n0.841\n0.236\n0.0000516\n6\nTRBC1\n\n\n0.0000000\n1.9431032\n0.768\n0.109\n0.0000557\n6\nKLRF1\n\n\n0.0000000\n1.4774974\n0.880\n0.253\n0.0002340\n6\nFCGR3A\n\n\n0.0000000\n1.7554731\n0.946\n0.309\n0.0002581\n6\nGZMA\n\n\n0.0000000\n1.0206283\n0.898\n0.651\n0.0004048\n6\nPPP2R5C\n\n\n0.0000000\n1.3302579\n0.583\n0.136\n0.0006525\n6\nCLIC3\n\n\n0.0000001\n1.1507757\n0.729\n0.312\n0.0009942\n6\nAPMAP\n\n\n0.0000001\n1.3014262\n0.890\n0.335\n0.0010199\n6\nGZMM\n\n\n0.0000001\n1.2780443\n0.620\n0.147\n0.0010392\n6\nCEP78\n\n\n0.0000000\n1.6532862\n0.901\n0.406\n0.0000000\n7\nPIK3IP1\n\n\n0.0000000\n1.9636174\n0.765\n0.120\n0.0000001\n7\nCCR7\n\n\n0.0000000\n1.9203586\n0.949\n0.221\n0.0000003\n7\nIL7R\n\n\n0.0000000\n1.3644486\n0.801\n0.374\n0.0000147\n7\nGIMAP7\n\n\n0.0000000\n1.4244304\n0.853\n0.551\n0.0000329\n7\nLDHB\n\n\n0.0000000\n1.2278399\n0.467\n0.074\n0.0006976\n7\nCAMK4\n\n\n0.0000000\n1.6788412\n0.445\n0.016\n0.0008135\n7\nTSHZ2\n\n\n0.0000001\n1.3074415\n0.846\n0.480\n0.0019166\n7\nLEPROTL1\n\n\n0.0000001\n1.1852064\n0.835\n0.580\n0.0019977\n7\nIKZF1\n\n\n0.0000001\n0.9777944\n0.768\n0.502\n0.0024433\n7\nC12orf57\n\n\n0.0000001\n1.7790448\n0.765\n0.204\n0.0025421\n7\nTCF7\n\n\n0.0000002\n1.2138665\n0.500\n0.189\n0.0029198\n7\nBCL2\n\n\n0.0000002\n0.8806075\n0.912\n0.373\n0.0031297\n7\nCD3E\n\n\n0.0000003\n1.5469097\n0.544\n0.054\n0.0054154\n7\nLEF1\n\n\n0.0000003\n0.9608209\n0.735\n0.409\n0.0058669\n7\nTRBC2\n\n\n0.0000004\n1.4008672\n0.496\n0.045\n0.0071083\n7\nTRABD2A\n\n\n0.0000005\n1.7047776\n0.941\n0.384\n0.0091082\n7\nLTB\n\n\n0.0000005\n0.7011943\n0.699\n0.270\n0.0093889\n7\nCD3G\n\n\n0.0000007\n0.8680582\n0.426\n0.074\n0.0131311\n7\nCD27\n\n\n0.0000009\n1.0600617\n0.713\n0.251\n0.0166788\n7\nTRAC\n\n\n0.0000011\n1.3839811\n0.581\n0.134\n0.0190779\n7\nRCAN3\n\n\n0.0000015\n1.2504376\n0.540\n0.151\n0.0276805\n7\nPDE3B\n\n\n0.0000016\n1.3766879\n0.518\n0.049\n0.0290362\n7\nMAL\n\n\n0.0000041\n1.0916699\n0.471\n0.140\n0.0744289\n7\nBCL11B\n\n\n0.0000044\n0.8658580\n0.651\n0.368\n0.0798630\n7\nCLEC2D\n\n\n0.0000000\n2.6371809\n0.992\n0.128\n0.0000000\n8\nCD79A\n\n\n0.0000000\n2.1500595\n0.938\n0.111\n0.0000000\n8\nBANK1\n\n\n0.0000000\n2.4100344\n0.929\n0.117\n0.0000000\n8\nMS4A1\n\n\n0.0000000\n1.8766837\n0.909\n0.119\n0.0000000\n8\nTNFRSF13C\n\n\n0.0000000\n1.4324621\n0.834\n0.189\n0.0000000\n8\nCD79B\n\n\n0.0000000\n1.5159672\n0.826\n0.113\n0.0000000\n8\nRALGPS2\n\n\n0.0000000\n1.6390299\n0.992\n0.643\n0.0000000\n8\nHLA-DRA\n\n\n0.0000000\n1.5384877\n0.988\n0.689\n0.0000000\n8\nHLA-DPB1\n\n\n0.0000000\n1.3768830\n0.822\n0.115\n0.0000000\n8\nLINC00926\n\n\n0.0000000\n1.7072929\n0.950\n0.342\n0.0000001\n8\nHLA-DQA1\n\n\n0.0000000\n1.5291404\n0.983\n0.555\n0.0000002\n8\nHLA-DQB1\n\n\n0.0000000\n1.4491273\n0.710\n0.058\n0.0000003\n8\nBLK\n\n\n0.0000000\n0.6446052\n0.726\n0.173\n0.0000005\n8\nPDLIM1\n\n\n0.0000000\n1.3237118\n0.996\n0.703\n0.0000005\n8\nHLA-DPA1\n\n\n0.0000000\n1.0448056\n0.581\n0.082\n0.0000005\n8\nGNG7\n\n\n0.0000000\n1.3865715\n0.660\n0.092\n0.0000006\n8\nP2RX5\n\n\n0.0000000\n0.8525238\n0.382\n0.033\n0.0000203\n8\nFCRL2\n\n\n0.0000000\n1.1296329\n0.610\n0.143\n0.0000400\n8\nCCDC50\n\n\n0.0000000\n1.4233836\n0.664\n0.045\n0.0000423\n8\nSPIB\n\n\n0.0000000\n1.3709920\n0.934\n0.575\n0.0000879\n8\nEZR\n\n\n0.0000000\n0.9160839\n0.440\n0.034\n0.0002711\n8\nOSBPL10\n\n\n0.0000000\n1.4470085\n0.589\n0.042\n0.0004404\n8\nIGHG3\n\n\n0.0000000\n1.2844498\n0.506\n0.039\n0.0004844\n8\nCOBLL1\n\n\n0.0000000\n0.9917748\n0.452\n0.035\n0.0006229\n8\nCD24\n\n\n0.0000001\n0.8579067\n0.809\n0.331\n0.0009088\n8\nHLA-DMB\n\n\n0.0000000\n3.0533413\n0.995\n0.385\n0.0000000\n9\nLST1\n\n\n0.0000000\n2.5473430\n0.972\n0.273\n0.0000000\n9\nFCGR3A\n\n\n0.0000000\n2.0092308\n0.953\n0.218\n0.0000000\n9\nLRRC25\n\n\n0.0000000\n2.2459087\n0.907\n0.151\n0.0000000\n9\nMS4A7\n\n\n0.0000000\n1.9438602\n0.977\n0.360\n0.0000000\n9\nSPI1\n\n\n0.0000000\n3.2346530\n0.902\n0.036\n0.0000000\n9\nCDKN1C\n\n\n0.0000000\n2.3852009\n1.000\n0.369\n0.0000000\n9\nAIF1\n\n\n0.0000000\n2.1341440\n0.953\n0.151\n0.0000000\n9\nSMIM25\n\n\n0.0000000\n1.8843737\n0.865\n0.110\n0.0000000\n9\nCSF1R\n\n\n0.0000000\n2.3957297\n1.000\n0.643\n0.0000000\n9\nCOTL1\n\n\n0.0000000\n1.6123093\n0.851\n0.103\n0.0000000\n9\nTCF7L2\n\n\n0.0000000\n1.5792253\n0.860\n0.170\n0.0000000\n9\nHMOX1\n\n\n0.0000000\n1.6904513\n0.902\n0.179\n0.0000000\n9\nRRAS\n\n\n0.0000000\n1.5968753\n0.940\n0.225\n0.0000000\n9\nPILRA\n\n\n0.0000000\n1.3877009\n0.972\n0.590\n0.0000000\n9\nRNASET2\n\n\n0.0000000\n1.9888806\n1.000\n0.611\n0.0000000\n9\nPSAP\n\n\n0.0000000\n2.0073048\n0.995\n0.462\n0.0000000\n9\nFCER1G\n\n\n0.0000000\n1.8077275\n0.940\n0.274\n0.0000000\n9\nPECAM1\n\n\n0.0000000\n1.1476232\n0.898\n0.256\n0.0000000\n9\nHCK\n\n\n0.0000000\n1.9356242\n0.977\n0.269\n0.0000000\n9\nCFD\n\n\n0.0000000\n1.8569682\n0.944\n0.274\n0.0000001\n9\nWARS\n\n\n0.0000000\n1.5558324\n0.730\n0.065\n0.0000001\n9\nHES4\n\n\n0.0000000\n1.6914523\n0.986\n0.477\n0.0000001\n9\nNPC2\n\n\n0.0000000\n1.6320396\n0.967\n0.244\n0.0000001\n9\nLILRB2\n\n\n0.0000000\n2.0073076\n0.912\n0.294\n0.0000001\n9\nRHOC\n\n\n\n\n\n\n\nmypar(2,5,mar=c(4,6,3,1))\nfor(i in unique(top25$cluster)){\n  barplot( sort( setNames(top25$avg_log2FC, top25$gene) [top25$cluster == i], F),\n           horiz = T,las=1 ,main=paste0(i,\" vs. rest\"),border = \"white\", yaxs=\"i\" )\n  abline(v=c(0,0.25),lty=c(1,2))\n}\n\n\n\n\n\n\n\n\nWe can visualize them as a heatmap. Here we are selecting the top 5.\n\nmarkers_genes %&gt;% group_by(cluster)  %&gt;% top_n(-5, p_val_adj) -&gt; top5\n\n# create a scale.data slot for the selected genes\nalldata &lt;- ScaleData(alldata, features = as.character(unique(top5$gene)), assay = \"RNA\")\nDoHeatmap(alldata, features = as.character(unique(top5$gene)),group.by = sel.clust, assay = \"RNA\")\n\n\n\n\n\n\n\n\nAnother way is by representing the overal group expression and detection rates in a dot-plot.\n\nDotPlot(alldata, features = rev(as.character(unique(top5$gene))),group.by = sel.clust,assay = \"RNA\")+coord_flip()\n\n\n\n\n\n\n\n\nWe can also plot a violin plot for each gene.\n\n# take top 3 genes per cluster/\ntop5 %&gt;% group_by(cluster)  %&gt;% top_n(-3, p_val) -&gt; top3\n\n# set pt.size to zero if you do not want all the points to hide the violin shapes, or to a small value like 0.1\nVlnPlot(alldata, features = as.character(unique(top3$gene)), ncol = 5, group.by = sel.clust, assay = \"RNA\", pt.size = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nTake a screen shot of those results and re-run the same code above with another test: “wilcox” (Wilcoxon Rank Sum test), “bimod” (Likelihood-ratio test), “roc” (Identifies ‘markers’ of gene expression using ROC analysis),“t” (Student’s t-test),“negbinom” (negative binomial generalized linear model),“poisson” (poisson generalized linear model), “LR” (logistic regression), “MAST” (hurdle model), “DESeq2” (negative binomial distribution)."
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#meta-dge_cond",
    "href": "labs/seurat/seurat_05_dge.html#meta-dge_cond",
    "title": " Differential gene expression",
    "section": "2 DGE across conditions",
    "text": "2 DGE across conditions\nThe second way of computing differential expression is to answer which genes are differentially expressed within a cluster. For example, in our case we have libraries comming from patients and controls and we would like to know which genes are influenced the most in a particular cell type. For this end, we will first subset our data for the desired cell cluster, then change the cell identities to the variable of comparison (which now in our case is the “type”, e.g. Covid/Ctrl).\n\n# select all cells in cluster 1\ncell_selection &lt;- subset(alldata, cells = colnames(alldata)[ alldata@meta.data[,sel.clust] == 2])\ncell_selection &lt;- SetIdent(cell_selection, value = \"type\")\n#Compute differentiall expression\nDGE_cell_selection &lt;- FindAllMarkers(cell_selection,\n                               log2FC.threshold = 0.2,\n                               test.use = \"wilcox\",\n                               min.pct = 0.1,\n                               min.diff.pct = 0.2,\n                               only.pos = TRUE,\n                               max.cells.per.ident = 50,\n                               assay = \"RNA\")\n\nWe can now plot the expression across the “type”.\n\nDGE_cell_selection %&gt;% group_by(cluster)  %&gt;% top_n(-5, p_val) -&gt; top5_cell_selection\nVlnPlot(cell_selection, features = as.character(unique(top5_cell_selection$gene)), ncol = 5,group.by = \"type\",assay = \"RNA\", pt.size = .1)\n\n\n\n\n\n\n\n\nWe can also plot these genes across all clusters, but split by “type”, to check if the genes are also up/downregulated in other celltypes.\n\nVlnPlot(alldata, features = as.character(unique(top5_cell_selection$gene)),\n        ncol = 5, split.by = \"type\",assay = \"RNA\", pt.size = 0)\n\n\n\n\n\n\n\n\nAs you can see, we hwve many sex chromosome related genes among the top DE genes. And if you remember from the QC lab, we have inbalanced sex distribution among our subjects, so this may not be related to covid at all.\n\n2.1 Remove sex chromosome genes\nTo remove some of the bias due to inbalanced sex in the subjects we can remove the sex chromosome related genes.\n\ngene.info = read.csv(\"data/results/genes.table.csv\") #was created in the QC exercise\n\nauto.genes = gene.info$external_gene_name[!(gene.info$chromosome_name %in% c(\"X\", \"Y\"))]\n\ncell_selection@active.assay = \"RNA\"\nkeep.genes = intersect(rownames(cell_selection), auto.genes)\ncell_selection = cell_selection[keep.genes,]\n\n# then renormalize the data\ncell_selection = NormalizeData(cell_selection)\n\nRerun differential expression:\n\n#Compute differentiall expression\nDGE_cell_selection &lt;- FindMarkers(cell_selection, ident.1 = \"Covid\", ident.2 = \"Ctrl\",\n                       logfc.threshold = 0.2, test.use = \"wilcox\",  min.pct = 0.1,\n                       min.diff.pct = 0.2, assay = \"RNA\")\n\n# Define as Covid or Ctrl in the df and add a gene column\nDGE_cell_selection$direction = ifelse(DGE_cell_selection$avg_log2FC &gt; 0, \"Covid\", \"Ctrl\")\nDGE_cell_selection$gene = rownames(DGE_cell_selection)\n\n\nDGE_cell_selection %&gt;%\n    group_by(direction) %&gt;%\n    top_n(-5, p_val) %&gt;%\n    arrange(direction) -&gt; top5_cell_selection\n\nVlnPlot(cell_selection, features = as.character(unique(top5_cell_selection$gene)),\n        ncol = 5,group.by = \"type\",assay = \"RNA\", pt.size = .1)\n\n\n\n\n\n\n\n\nWe can also plot these genes across all clusters, but split by “type”, to check if the genes are also up/downregulated in other celltypes/clusters.\n\nVlnPlot(alldata, features = as.character(unique(top5_cell_selection$gene)),\n        ncol = 5, split.by = \"type\",assay = \"RNA\", pt.size = 0)"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#patient-batch-effects",
    "href": "labs/seurat/seurat_05_dge.html#patient-batch-effects",
    "title": " Differential gene expression",
    "section": "3 Patient Batch effects",
    "text": "3 Patient Batch effects\nWhen we are testing for Covid vs Control we are running a DGE test for 3 vs 3 individuals. That will be very sensitive to sample differences unless we find a way to control for it. So first, lets check how the top DGEs are expressed across the individuals:\n\nVlnPlot(cell_selection, group.by = \"orig.ident\", features =  as.character(unique(top5_cell_selection$gene)), ncol = 5, assay = \"RNA\", pt.size = 0)\n\n\n\n\n\n\n\n\nAs you can see, many of the genes detected as DGE in Covid are unique to one or 2 patients.\nWe can examine more genes with a DotPlot:\n\nDGE_cell_selection %&gt;%\n    group_by(direction) %&gt;%\n    top_n(-20, p_val) -&gt; top20_cell_selection\nDotPlot(cell_selection, features = rev(as.character(unique(top20_cell_selection$gene))), group.by = \"orig.ident\",    assay = \"RNA\") + coord_flip()\n\n\n\n\n\n\n\n\nAs you can see, most of the DGEs are driven by the covid_17 patient.\nBut it is also the sample with the highest number of cells:\n\ntable(cell_selection$orig.ident)\n\n\n covid_1 covid_15 covid_17  ctrl_13  ctrl_14   ctrl_5 \n      90       38      172       66       63      140"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#subsample",
    "href": "labs/seurat/seurat_05_dge.html#subsample",
    "title": " Differential gene expression",
    "section": "4 Subsample",
    "text": "4 Subsample\nSo one obvious thing to consider is an equal amount of cells per individual so that the DGE results are not dominated by a single sample.\nSo we will use the downsample option in the Seurat function WhichCells to select 30 cells per cluster:\n\ncell_selection &lt;- SetIdent(cell_selection, value = \"orig.ident\")\nsub_data &lt;- subset(cell_selection, cells = WhichCells(cell_selection, downsample = 30))\n\ntable(sub_data$orig.ident)\n\n\n covid_1 covid_15 covid_17  ctrl_13  ctrl_14   ctrl_5 \n      30       30       30       30       30       30 \n\n\nAnd now we run DGE analysis again:\n\nsub_data &lt;- SetIdent(sub_data, value = \"type\")\n\n#Compute differentiall expression\nDGE_sub &lt;- FindMarkers(sub_data, ident.1 = \"Covid\", ident.2 = \"Ctrl\",\n                       logfc.threshold = 0.2, test.use = \"wilcox\",  min.pct = 0.1,\n                       min.diff.pct = 0.2, assay = \"RNA\")\n\n# Define as Covid or Ctrl in the df and add a gene column\nDGE_sub$direction = ifelse(DGE_sub$avg_log2FC &gt; 0, \"Covid\", \"Ctrl\")\nDGE_sub$gene = rownames(DGE_sub)\n\n\nDGE_sub %&gt;%\n    group_by(direction) %&gt;%\n    top_n(-5, p_val) %&gt;%\n    arrange(direction) -&gt; top5_sub\n\nVlnPlot(sub_data, features = as.character(unique(top5_sub$gene)),\n        ncol = 5,group.by = \"type\",assay = \"RNA\", pt.size = .1)\n\n\n\n\n\n\n\n\nPlot as dotplot, but in the full dataset:\n\nDGE_sub %&gt;%\n    group_by(direction) %&gt;%\n    top_n(-20, p_val) -&gt; top20_sub\nDotPlot(cell_selection, features = rev(as.character(unique(top20_sub$gene))), group.by = \"orig.ident\", assay = \"RNA\") +\n  coord_flip()\n\n\n\n\n\n\n\n\nIt looks much better now. But if we look per patient you can see that we still have some genes that are dominated by a single patient.\nWhy do you think this is?"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#pseudobulk",
    "href": "labs/seurat/seurat_05_dge.html#pseudobulk",
    "title": " Differential gene expression",
    "section": "5 Pseudobulk",
    "text": "5 Pseudobulk\nOne option is to treat the samples as pseudobulks and do differential expression for the 3 patients vs 3 controls. You do lose some information about cell variability within each patient, but instead you gain the advantage of mainly looking for effects that are seen in multiple patients.\nHowever, having only 3 patients is probably too low, with many more patients it will work better to run pseudobulk analysis.\nFor a fair comparison we should have equal number of cells per sample when we create the pseudobulk, so we will use the subsampled object.\n\n# get the count matrix for all cells\nDGE_DATA &lt;- sub_data@assays$RNA@counts\n\n# Compute pseudobulk\nmm &lt;- Matrix::sparse.model.matrix(~0 + sub_data$orig.ident)\npseudobulk &lt;- DGE_DATA %*% mm\n\nThen run edgeR:\n\n# define the groups\nbulk.labels = c(\"Covid\", \"Covid\", \"Covid\", \"Ctrl\", \"Ctrl\", \"Ctrl\")\n\ndge.list &lt;- DGEList(counts = pseudobulk, group = factor(bulk.labels))\nkeep &lt;- filterByExpr(dge.list)\ndge.list &lt;- dge.list[keep, , keep.lib.sizes = FALSE]\n\ndge.list &lt;- calcNormFactors(dge.list)\ndesign = model.matrix(~bulk.labels)\n\ndge.list &lt;- estimateDisp(dge.list, design)\n\nfit &lt;- glmQLFit(dge.list, design)\nqlf &lt;- glmQLFTest(fit, coef = 2)\ntopTags(qlf)\n\nCoefficient:  bulk.labelsCtrl \n           logFC    logCPM        F       PValue         FDR\nS100A9 -3.498029  7.553305 42.63147 6.198241e-06 0.006783959\nS100A8 -4.207836  7.288831 41.11483 7.704667e-06 0.006783959\nIGHA1  -3.838099  6.413437 29.34410 5.264686e-05 0.030903706\nAREG   -1.832454  6.717829 17.81616 6.199740e-04 0.272932981\nCD69   -1.845790 10.696022 16.19704 9.402281e-04 0.272932981\nJCHAIN  1.615055  7.102567 16.06508 9.736488e-04 0.272932981\nAHNAK   1.162623  8.053008 15.65996 1.084912e-03 0.272932981\nCCND3  -1.136665  7.929824 13.90824 1.763560e-03 0.317304552\nNDUFS7 -1.479698  6.849707 13.72267 1.860071e-03 0.317304552\nADPGK   1.240460  7.412317 13.54525 1.957945e-03 0.317304552\n\n\nAs you can see, we have very few significant genes, actually only 2 with FDR &lt; 0.1. Since we only have 3 vs 3 samples, we should not expect too many genes with this method.\nAgain as dotplot including all genes with FDR &lt; 1:\n\nres.edgeR &lt;- topTags(qlf, 100)$table\nres.edgeR$dir = ifelse(res.edgeR$logFC &gt; 0, \"Covid\", \"Ctrl\")\nres.edgeR$gene = rownames(res.edgeR)\n\nres.edgeR %&gt;%\n    group_by(dir) %&gt;%\n    top_n(-10, PValue) %&gt;%\n    arrange(dir) -&gt; top.edgeR\n\nDotPlot(cell_selection, features = as.character(unique(top.edgeR$gene)), group.by = \"orig.ident\",\n    assay = \"RNA\") + coord_flip() + ggtitle(\"EdgeR pseudobulk\") + RotatedAxis()\n\n\n\n\n\n\n\n\nAs you can see, even if we get few genes detected the seem to make sense across all the patients."
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#mast-random-effect",
    "href": "labs/seurat/seurat_05_dge.html#mast-random-effect",
    "title": " Differential gene expression",
    "section": "6 MAST random effect",
    "text": "6 MAST random effect\nMAST has the option to add a random effect for the patient when running DGE analysis. It is quite slow, even with this small dataset, so it may not be practical for a larger dataset unless you have access to a compute cluster.\nWe will run MAST with and without patient info as random effect and compare the results\nFirst, filter genes in part to speed up the process but also to avoid too many warnings in the model fitting step of MAST. We will keep genes that are expressed with at least 2 reads in 2 covid patients or 2 controls.\n\n# select genes that are expressed in at least 2 patients or 2 ctrls with &gt; 2 reads.\nnPatient = sapply(unique(cell_selection$orig.ident), function(x) rowSums(cell_selection@assays$RNA@counts[, cell_selection$orig.ident\n== x] &gt; 2))\nnCovid = rowSums(nPatient[,1:3]&gt;2)\nnCtrl = rowSums(nPatient[,4:6]&gt;2)\n\nsel = nCovid &gt;= 2 | nCtrl &gt;= 2\ncell_selection_sub = cell_selection[sel, ]\n\nSet up the MAST object.\n\n# create the feature data\nfData &lt;- data.frame(primerid = rownames(cell_selection_sub))\nm = cell_selection_sub@meta.data\nm$wellKey = rownames(m)\n\n# make sure type and orig.ident are factors\nm$orig.ident = factor(m$orig.ident)\nm$type = factor(m$type)\n\nsca &lt;- MAST::FromMatrix(exprsArray = as.matrix(x = cell_selection_sub@assays$RNA@data),\n    check_sanity = FALSE, cData = m, fData = fData)\n\nFirst, run the regular MAST analysis without random effects\n\n# takes a while to run, so save a file to tmpdir in case you have to rerun the code\ntmpdir = \"tmp_dge\"\ndir.create(tmpdir, showWarnings = F)\n\ntmpfile1 = file.path(tmpdir, \"mast_bayesglm_cl1.Rds\")\nif (file.exists(tmpfile1)) {\n    fcHurdle1 = readRDS(tmpfile1)\n} else {\n    zlmCond &lt;- suppressMessages(MAST::zlm(~type, sca, method = \"bayesglm\", ebayes = T))\n    summaryCond &lt;- suppressMessages(MAST::summary(zlmCond, doLRT = \"typeCtrl\"))\n    summaryDt &lt;- summaryCond$datatable\n    fcHurdle &lt;- merge(summaryDt[summaryDt$contrast == \"typeCtrl\" & summaryDt$component ==\n        \"logFC\", c(1, 7, 5, 6, 8)], summaryDt[summaryDt$contrast == \"typeCtrl\" &\n        summaryDt$component == \"H\", c(1, 4)], by = \"primerid\")\n    fcHurdle1 &lt;- stats::na.omit(as.data.frame(fcHurdle))\n    saveRDS(fcHurdle1, tmpfile1)\n}\n\nThen run MAST with glmer and random effect.\n\nlibrary(lme4)\n\ntmpfile2 = file.path(tmpdir, \"mast_glme_cl1.Rds\")\nif (file.exists(tmpfile2)) {\n    fcHurdle2 = readRDS(tmpfile2)\n} else {\n    zlmCond &lt;- suppressMessages(MAST::zlm(~type + (1 | orig.ident), sca, method = \"glmer\",\n        ebayes = F, strictConvergence = FALSE))\n\n    summaryCond &lt;- suppressMessages(MAST::summary(zlmCond, doLRT = \"typeCtrl\"))\n    summaryDt &lt;- summaryCond$datatable\n    fcHurdle &lt;- merge(summaryDt[summaryDt$contrast == \"typeCtrl\" & summaryDt$component ==\n        \"logFC\", c(1, 7, 5, 6, 8)], summaryDt[summaryDt$contrast == \"typeCtrl\" &\n        summaryDt$component == \"H\", c(1, 4)], by = \"primerid\")\n    fcHurdle2 &lt;- stats::na.omit(as.data.frame(fcHurdle))\n    saveRDS(fcHurdle2, tmpfile2)\n}\n\nTop genes with normal MAST:\n\ntop1 = head(fcHurdle1[order(fcHurdle1$`Pr(&gt;Chisq)`), ], 10)\ntop1\n\nfcHurdle1$pval = fcHurdle1$`Pr(&gt;Chisq)`\nfcHurdle1$dir = ifelse(fcHurdle1$z &gt; 0, \"up\", \"down\")\nfcHurdle1 %&gt;%\n    group_by(dir) %&gt;%\n    top_n(-10, pval) %&gt;%\n    arrange(z) -&gt; mastN\n\nmastN = mastN$primerid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprimerid\ncoef\nci.hi\nci.lo\nz\nPr(&gt;Chisq)\n\n\n\n\n354\nHLA-DRB5\n-0.7446061\n-0.5675697\n-0.9216426\n-8.243506\n0\n\n\n719\nRPS26\n1.2235900\n1.3827962\n1.0643838\n15.063434\n0\n\n\n137\nCD74\n0.5082660\n0.5691480\n0.4473840\n16.362522\n0\n\n\n135\nCD69\n-1.2957525\n-1.1074692\n-1.4840358\n-13.488336\n0\n\n\n407\nISG20\n-0.8246052\n-0.6759190\n-0.9732914\n-10.869847\n0\n\n\n502\nNFKBIA\n-0.7186872\n-0.5705235\n-0.8668508\n-9.507062\n0\n\n\n444\nLY6E\n-0.7355879\n-0.5983015\n-0.8728742\n-10.501595\n0\n\n\n239\nEEF1A1\n0.4471516\n0.5227196\n0.3715837\n11.597519\n0\n\n\n691\nRPL4\n0.6175210\n0.7342439\n0.5007982\n10.369168\n0\n\n\n742\nS100A9\n-0.5951318\n-0.4823484\n-0.7079152\n-10.342274\n0\n\n\n\n\n\n\nTop genes with random effect:\n\ntop2 = head(fcHurdle2[order(fcHurdle2$`Pr(&gt;Chisq)`), ], 10)\ntop2\n\nfcHurdle2$pval = fcHurdle2$`Pr(&gt;Chisq)`\nfcHurdle2$dir = ifelse(fcHurdle2$z &gt; 0, \"up\", \"down\")\nfcHurdle2 %&gt;%\n    group_by(dir) %&gt;%\n    top_n(-10, pval) %&gt;%\n    arrange(z) -&gt; mastR\n\nmastR = mastR$primerid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprimerid\ncoef\nci.hi\nci.lo\nz\nPr(&gt;Chisq)\n\n\n\n\n742\nS100A9\n-0.5982102\n-0.4844424\n-0.7119780\n-10.305817\n0.0000642\n\n\n352\nHLA-DRA\n0.3709825\n0.4704648\n0.2715002\n7.308965\n0.0000712\n\n\n741\nS100A8\n-0.5208571\n-0.3588862\n-0.6828281\n-6.302742\n0.0000772\n\n\n551\nPHACTR1\n-0.4797035\n-0.3439641\n-0.6154430\n-6.926516\n0.0000998\n\n\n349\nHLA-DPB1\n0.3623810\n0.4678909\n0.2568711\n6.731630\n0.0001384\n\n\n760\nSF1\n0.5052604\n0.7601909\n0.2503299\n3.884557\n0.0002655\n\n\n413\nJCHAIN\n0.2814208\n0.3974764\n0.1653651\n4.752674\n0.0002772\n\n\n538\nPCBP2\n0.2774759\n0.4023045\n0.1526474\n4.356718\n0.0004184\n\n\n954\nZFAS1\n0.2846779\n0.4178066\n0.1515491\n4.191118\n0.0007799\n\n\n348\nHLA-DPA1\n0.2942377\n0.4170246\n0.1714508\n4.696716\n0.0007928\n\n\n\n\n\n\nAs you can see, we have lower significance for the genes with the random effect added.\nDotplot for top10 genes in each direction:\n\np1 = DotPlot(cell_selection, features = mastN, group.by = \"orig.ident\", assay = \"RNA\") +\n    coord_flip() + RotatedAxis() + ggtitle(\"Regular MAST\")\n\np2 = DotPlot(cell_selection, features = mastR, group.by = \"orig.ident\", assay = \"RNA\") +\n    coord_flip() + RotatedAxis() + ggtitle(\"With random effect\")\n\np1 + p2"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#meta-dge_gsa",
    "href": "labs/seurat/seurat_05_dge.html#meta-dge_gsa",
    "title": " Differential gene expression",
    "section": "7 Gene Set Analysis (GSA)",
    "text": "7 Gene Set Analysis (GSA)\n\n7.1 Hypergeometric enrichment test\nHaving a defined list of differentially expressed genes, you can now look for their combined function using hypergeometric test.\n\n# Load additional packages\nlibrary(enrichR)\n\n# Check available databases to perform enrichment (then choose one)\nenrichR::listEnrichrDbs()\n\n# Perform enrichment\nenrich_results &lt;- enrichr(\n genes     = DGE_cell_selection$gene[DGE_cell_selection$avg_log2FC &gt; 0],\n databases = \"GO_Biological_Process_2017b\" )[[1]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeneCoverage\ngenesPerTerm\nlibraryName\nlink\nnumTerms\nappyter\ncategoryId\n\n\n\n\n13362\n275\nGenome_Browser_PWMs\nhttp://hgdownload.cse.ucsc.edu/goldenPath/hg18/database/\n615\nea115789fcbf12797fd692cec6df0ab4dbc79c6a\n1\n\n\n27884\n1284\nTRANSFAC_and_JASPAR_PWMs\nhttp://jaspar.genereg.net/html/DOWNLOAD/\n326\n7d42eb43a64a4e3b20d721fc7148f685b53b6b30\n1\n\n\n6002\n77\nTranscription_Factor_PPIs\n\n290\n849f222220618e2599d925b6b51868cf1dab3763\n1\n\n\n47172\n1370\nChEA_2013\nhttp://amp.pharm.mssm.edu/lib/cheadownload.jsp\n353\n7ebe772afb55b63b41b79dd8d06ea0fdd9fa2630\n7\n\n\n47107\n509\nDrug_Perturbations_from_GEO_2014\nhttp://www.ncbi.nlm.nih.gov/geo/\n701\nad270a6876534b7cb063e004289dcd4d3164f342\n7\n\n\n21493\n3713\nENCODE_TF_ChIP-seq_2014\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n498\n497787ebc418d308045efb63b8586f10c526af51\n7\n\n\n1295\n18\nBioCarta_2013\nhttps://cgap.nci.nih.gov/Pathways/BioCarta_Pathways\n249\n4a293326037a5229aedb1ad7b2867283573d8bcd\n7\n\n\n3185\n73\nReactome_2013\nhttp://www.reactome.org/download/index.html\n78\nb343994a1b68483b0122b08650201c9b313d5c66\n7\n\n\n2854\n34\nWikiPathways_2013\nhttp://www.wikipathways.org/index.php/Download_Pathways\n199\n5c307674c8b97e098f8399c92f451c0ff21cbf68\n7\n\n\n15057\n300\nDisease_Signatures_from_GEO_up_2014\nhttp://www.ncbi.nlm.nih.gov/geo/\n142\n248c4ed8ea28352795190214713c86a39fd7afab\n7\n\n\n4128\n48\nKEGG_2013\nhttp://www.kegg.jp/kegg/download/\n200\neb26f55d3904cb0ea471998b6a932a9bf65d8e50\n7\n\n\n34061\n641\nTF-LOF_Expression_from_GEO\nhttp://www.ncbi.nlm.nih.gov/geo/\n269\n\n1\n\n\n7504\n155\nTargetScan_microRNA\nhttp://www.targetscan.org/cgi-bin/targetscan/data_download.cgi?db=vert_61\n222\nf4029bf6a62c91ab29401348e51df23b8c44c90f\n7\n\n\n16399\n247\nPPI_Hub_Proteins\nhttp://amp.pharm.mssm.edu/X2K\n385\n69c0cfe07d86f230a7ef01b365abcc7f6e52f138\n2\n\n\n12753\n57\nGO_Molecular_Function_2015\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n1136\nf531ac2b6acdf7587a54b79b465a5f4aab8f00f9\n7\n\n\n23726\n127\nGeneSigDB\nhttps://pubmed.ncbi.nlm.nih.gov/22110038/\n2139\n6d655e0aa3408a7accb3311fbda9b108681a8486\n4\n\n\n32740\n85\nChromosome_Location\nhttp://software.broadinstitute.org/gsea/msigdb/index.jsp\n386\n8dab0f96078977223646ff63eb6187e0813f1433\n7\n\n\n13373\n258\nHuman_Gene_Atlas\nhttp://biogps.org/downloads/\n84\n0741451470203d7c40a06274442f25f74b345c9c\n5\n\n\n19270\n388\nMouse_Gene_Atlas\nhttp://biogps.org/downloads/\n96\n31191bfadded5f96983f93b2a113cf2110ff5ddb\n5\n\n\n13236\n82\nGO_Cellular_Component_2015\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n641\ne1d004d5797cbd2363ef54b1c3b361adb68795c6\n7\n\n\n14264\n58\nGO_Biological_Process_2015\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n5192\nbf120b6e11242b1a64c80910d8e89f87e618e235\n7\n\n\n3096\n31\nHuman_Phenotype_Ontology\nhttp://www.human-phenotype-ontology.org/\n1779\n17a138b0b70aa0e143fe63c14f82afb70bc3ed0a\n3\n\n\n22288\n4368\nEpigenomics_Roadmap_HM_ChIP-seq\nhttp://www.roadmapepigenomics.org/\n383\ne1bc8a398e9b21f9675fb11bef18087eda21b1bf\n1\n\n\n4533\n37\nKEA_2013\nhttp://amp.pharm.mssm.edu/lib/keacommandline.jsp\n474\n462045609440fa1e628a75716b81a1baa5bd9145\n7\n\n\n10231\n158\nNURSA_Human_Endogenous_Complexome\nhttps://www.nursa.org/nursa/index.jsf\n1796\n7d3566b12ebc23dd23d9ca9bb97650f826377b16\n2\n\n\n2741\n5\nCORUM\nhttp://mips.helmholtz-muenchen.de/genre/proj/corum/\n1658\nd047f6ead7831b00566d5da7a3b027ed9196e104\n2\n\n\n5655\n342\nSILAC_Phosphoproteomics\nhttp://amp.pharm.mssm.edu/lib/keacommandline.jsp\n84\n54dcd9438b33301deb219866e162b0f9da7e63a0\n2\n\n\n10406\n715\nMGI_Mammalian_Phenotype_Level_3\nhttp://www.informatics.jax.org/\n71\nc3bfc90796cfca8f60cba830642a728e23a53565\n7\n\n\n10493\n200\nMGI_Mammalian_Phenotype_Level_4\nhttp://www.informatics.jax.org/\n476\n0b09a9a1aa0af4fc7ea22d34a9ae644d45864bd6\n7\n\n\n11251\n100\nOld_CMAP_up\nhttp://www.broadinstitute.org/cmap/\n6100\n9041f90cccbc18479138330228b336265e09021c\n7\n\n\n8695\n100\nOld_CMAP_down\nhttp://www.broadinstitute.org/cmap/\n6100\nebc0d905b3b3142f936d400c5f2a4ff926c81c37\n7\n\n\n1759\n25\nOMIM_Disease\nhttp://www.omim.org/downloads\n90\ncb2b92578a91e023d0498a334923ee84add34eca\n4\n\n\n2178\n89\nOMIM_Expanded\nhttp://www.omim.org/downloads\n187\n27eca242904d8e12a38cf8881395bc50d57a03e1\n4\n\n\n851\n15\nVirusMINT\nhttp://mint.bio.uniroma2.it/download.html\n85\n5abad1fc36216222b0420cadcd9be805a0dda63e\n4\n\n\n10061\n106\nMSigDB_Computational\nhttp://www.broadinstitute.org/gsea/msigdb/collections.jsp\n858\ne4cdcc7e259788fdf9b25586cce3403255637064\n4\n\n\n11250\n166\nMSigDB_Oncogenic_Signatures\nhttp://www.broadinstitute.org/gsea/msigdb/collections.jsp\n189\nc76f5319c33c4833c71db86a30d7e33cd63ff8cf\n4\n\n\n15406\n300\nDisease_Signatures_from_GEO_down_2014\nhttp://www.ncbi.nlm.nih.gov/geo/\n142\naabdf7017ae55ae75a004270924bcd336653b986\n7\n\n\n17711\n300\nVirus_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n323\n45268b7fc680d05dd9a29743c2f2b2840a7620bf\n4\n\n\n17576\n300\nVirus_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n323\n5f531580ccd168ee4acc18b02c6bdf8200e19d08\n4\n\n\n15797\n176\nCancer_Cell_Line_Encyclopedia\nhttps://portals.broadinstitute.org/ccle/home\n967\neb38dbc3fb20adafa9d6f9f0b0e36f378e75284f\n5\n\n\n12232\n343\nNCI-60_Cancer_Cell_Lines\nhttp://biogps.org/downloads/\n93\n75c81676d8d6d99d262c9660edc024b78cfb07c9\n5\n\n\n13572\n301\nTissue_Protein_Expression_from_ProteomicsDB\nhttps://www.proteomicsdb.org/\n207\n\n7\n\n\n6454\n301\nTissue_Protein_Expression_from_Human_Proteome_Map\nhttp://www.humanproteomemap.org/index.php\n30\n49351dc989f9e6ca97c55f8aca7778aa3bfb84b9\n5\n\n\n3723\n47\nHMDB_Metabolites\nhttp://www.hmdb.ca/downloads\n3906\n1905132115d22e4119bce543bdacaab074edb363\n6\n\n\n7588\n35\nPfam_InterPro_Domains\nftp://ftp.ebi.ac.uk/pub/databases/interpro/\n311\ne2b4912cfb799b70d87977808c54501544e4cdc9\n6\n\n\n7682\n78\nGO_Biological_Process_2013\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n941\n5216d1ade194ffa5a6c00f105e2b1899f64f45fe\n7\n\n\n7324\n172\nGO_Cellular_Component_2013\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n205\nfd1332a42395e0bc1dba82868b39be7983a48cc5\n7\n\n\n8469\n122\nGO_Molecular_Function_2013\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n402\n7e3e99e5aae02437f80b0697b197113ce3209ab0\n7\n\n\n13121\n305\nAllen_Brain_Atlas_up\nhttp://www.brain-map.org/\n2192\n3804715a63a308570e47aa1a7877f01147ca6202\n5\n\n\n26382\n1811\nENCODE_TF_ChIP-seq_2015\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n816\n56b6adb4dc8a2f540357ef992d6cd93dfa2907e5\n1\n\n\n29065\n2123\nENCODE_Histone_Modifications_2015\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n412\n55b56cd8cf2ff04b26a09b9f92904008b82f3a6f\n1\n\n\n280\n9\nPhosphatase_Substrates_from_DEPOD\nhttp://www.koehn.embl.de/depod/\n59\nd40701e21092b999f4720d1d2b644dd0257b6259\n2\n\n\n13877\n304\nAllen_Brain_Atlas_down\nhttp://www.brain-map.org/\n2192\nea67371adec290599ddf484ced2658cfae259304\n5\n\n\n15852\n912\nENCODE_Histone_Modifications_2013\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n109\nc209ae527bc8e98e4ccd27a668d36cd2c80b35b4\n7\n\n\n4320\n129\nAchilles_fitness_increase\nhttp://www.broadinstitute.org/achilles\n216\n98366496a75f163164106e72439fb2bf2f77de4e\n4\n\n\n4271\n128\nAchilles_fitness_decrease\nhttp://www.broadinstitute.org/achilles\n216\n83a710c1ff67fd6b8af0d80fa6148c40dbd9bc64\n4\n\n\n10496\n201\nMGI_Mammalian_Phenotype_2013\nhttp://www.informatics.jax.org/\n476\na4c6e217a81a4a58ff5a1c9fc102b70beab298e9\n7\n\n\n1678\n21\nBioCarta_2015\nhttps://cgap.nci.nih.gov/Pathways/BioCarta_Pathways\n239\n70e4eb538daa7688691acfe5d9c3c19022be832b\n7\n\n\n756\n12\nHumanCyc_2015\nhttp://humancyc.org/\n125\n711f0c02b23f5e02a01207174943cfeee9d3ea9c\n7\n\n\n3800\n48\nKEGG_2015\nhttp://www.kegg.jp/kegg/download/\n179\ne80d25c56de53c704791ddfdc6ab5eec28ae7243\n7\n\n\n2541\n39\nNCI-Nature_2015\nhttp://pid.nci.nih.gov/\n209\n47edfc012bcbb368a10b717d8dca103f7814b5a4\n7\n\n\n1918\n39\nPanther_2015\nhttp://www.pantherdb.org/\n104\nab824aeeff0712bab61f372e43aebb870d1677a9\n7\n\n\n5863\n51\nWikiPathways_2015\nhttp://www.wikipathways.org/index.php/Download_Pathways\n404\n1f7eea2f339f37856522c1f1c70ec74c7b25325f\n7\n\n\n6768\n47\nReactome_2015\nhttp://www.reactome.org/download/index.html\n1389\n36e541bee015eddb8d53827579549e30fe7a3286\n7\n\n\n25651\n807\nESCAPE\nhttp://www.maayanlab.net/ESCAPE/\n315\na7acc741440264717ff77751a7e5fed723307835\n5\n\n\n19129\n1594\nHomoloGene\nhttp://www.ncbi.nlm.nih.gov/homologene\n12\n663b665b75a804ef98add689f838b68e612f0d2a\n6\n\n\n23939\n293\nDisease_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n839\n0f412e0802d76efa0374504c2c9f5e0624ff7f09\n8\n\n\n23561\n307\nDisease_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n839\n9ddc3902fb01fb9eaf1a2a7c2ff3acacbb48d37e\n8\n\n\n23877\n302\nDrug_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n906\n068623a05ecef3e4a5e0b4f8db64bb8faa3c897f\n8\n\n\n15886\n9\nGenes_Associated_with_NIH_Grants\nhttps://grants.nih.gov/grants/oer.htm\n32876\n76fc5ec6735130e287e62bae6770a3c5ee068645\n6\n\n\n24350\n299\nDrug_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n906\nc9c2155b5ac81ac496854fa61ba566dcae06cc80\n8\n\n\n3102\n25\nKEA_2015\nhttp://amp.pharm.mssm.edu/Enrichr\n428\n18a081774e6e0aaf60b1a4be7fd20afcf9e08399\n2\n\n\n31132\n298\nGene_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n2460\n53dedc29ce3100930d68e506f941ef59de05dc6b\n8\n\n\n30832\n302\nGene_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n2460\n499882af09c62dd6da545c15cb51c1dc5e234f78\n8\n\n\n48230\n1429\nChEA_2015\nhttp://amp.pharm.mssm.edu/Enrichr\n395\n712eb7b6edab04658df153605ec6079fa89fb5c7\n7\n\n\n5613\n36\ndbGaP\nhttp://www.ncbi.nlm.nih.gov/gap\n345\n010f1267055b1a1cb036e560ea525911c007a666\n4\n\n\n9559\n73\nLINCS_L1000_Chem_Pert_up\nhttps://clue.io/\n33132\n5e678b3debe8d8ea95187d0cd35c914017af5eb3\n7\n\n\n9448\n63\nLINCS_L1000_Chem_Pert_down\nhttps://clue.io/\n33132\nfedbf5e221f45ee60ebd944f92569b5eda7f2330\n7\n\n\n16725\n1443\nGTEx_Tissue_Expression_Down\nhttp://www.gtexportal.org/\n2918\n74b818bd299a9c42c1750ffe43616aa9f7929f02\n5\n\n\n19249\n1443\nGTEx_Tissue_Expression_Up\nhttp://www.gtexportal.org/\n2918\n103738763d89cae894bec9f145ac28167a90e611\n5\n\n\n15090\n282\nLigand_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n261\n1eb3c0426140340527155fd0ef67029db2a72191\n8\n\n\n16129\n292\nAging_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n286\ncd95fe1b505ba6f28cd722cfba50fdea979d3b4c\n8\n\n\n15309\n308\nAging_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n286\n74c4f0a0447777005b2a5c00c9882a56dfc62d7c\n8\n\n\n15103\n318\nLigand_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n261\n31baa39da2931ddd5f7aedf2d0bbba77d2ba7b46\n8\n\n\n15022\n290\nMCF7_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n401\n555f68aef0a29a67b614a0d7e20b6303df9069c6\n8\n\n\n15676\n310\nMCF7_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n401\n1bc2ba607f1ff0dda44e2a15f32a2c04767da18c\n8\n\n\n15854\n279\nMicrobe_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n312\n9e613dba78ef7e60676b13493a9dc49ccd3c8b3f\n8\n\n\n15015\n321\nMicrobe_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n312\nd0c3e2a68e8c611c669098df2c87b530cec3e132\n8\n\n\n3788\n159\nLINCS_L1000_Ligand_Perturbations_down\nhttps://clue.io/\n96\n957846cb05ef31fc8514120516b73cc65af7980e\n7\n\n\n3357\n153\nLINCS_L1000_Ligand_Perturbations_up\nhttps://clue.io/\n96\n3bd494146c98d8189898a947f5ef5710f1b7c4b2\n7\n\n\n12668\n300\nL1000_Kinase_and_GPCR_Perturbations_down\nhttps://clue.io/\n3644\n1ccc5bce553e0c2279f8e3f4ddcfbabcf566623b\n7\n\n\n12638\n300\nL1000_Kinase_and_GPCR_Perturbations_up\nhttps://clue.io/\n3644\nb54a0d4ba525eac4055c7314ca9d9312adcb220c\n7\n\n\n8973\n64\nReactome_2016\nhttp://www.reactome.org/download/index.html\n1530\n1f54638e8f45075fb79489f0e0ef906594cb0678\n7\n\n\n7010\n87\nKEGG_2016\nhttp://www.kegg.jp/kegg/download/\n293\n43f56da7540195ba3c94eb6e34c522a699b36da9\n7\n\n\n5966\n51\nWikiPathways_2016\nhttp://www.wikipathways.org/index.php/Download_Pathways\n437\n340be98b444cad50bb974df69018fd598e23e5e1\n7\n\n\n15562\n887\nENCODE_and_ChEA_Consensus_TFs_from_ChIP-X\n\n104\n5426f7747965c23ef32cff46fabf906e2cd76bfa\n1\n\n\n17850\n300\nKinase_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n285\nbb9682d78b8fc43be842455e076166fcd02cefc3\n2\n\n\n17660\n300\nKinase_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n285\n78618915009cac3a0663d6f99d359e39a31b6660\n2\n\n\n1348\n19\nBioCarta_2016\nhttp://cgap.nci.nih.gov/Pathways/BioCarta_Pathways\n237\n13d9ab18921d5314a5b2b366f6142b78ab0ff6aa\n2\n\n\n934\n13\nHumanCyc_2016\nhttp://humancyc.org/\n152\nd6a502ef9b4c789ed5e73ca5a8de372796e5c72a\n2\n\n\n2541\n39\nNCI-Nature_2016\nhttp://pid.nci.nih.gov/\n209\n3c1e1f7d1a651d9aaa198e73704030716fc09431\n2\n\n\n2041\n42\nPanther_2016\nhttp://www.pantherdb.org/pathway/\n112\nca5f6abf7f75d9baae03396e84d07300bf1fd051\n2\n\n\n5209\n300\nDrugMatrix\nhttps://ntp.niehs.nih.gov/drugmatrix/\n7876\n255c3db820d612f34310f22a6985dad50e9fe1fe\n4\n\n\n49238\n1550\nChEA_2016\nhttp://amp.pharm.mssm.edu/Enrichr\n645\naf271913344aa08e6a755af1d433ef15768d749a\n7\n\n\n2243\n19\nhuMAP\nhttp://proteincomplexes.org/\n995\n249247d2f686d3eb4b9e4eb976c51159fac80a89\n2\n\n\n19586\n545\nJensen_TISSUES\nhttp://tissues.jensenlab.org/\n1842\ne8879ab9534794721614d78fe2883e9e564d7759\n3\n\n\n22440\n505\nRNA-Seq_Disease_Gene_and_Drug_Signatures_from_GEO\nhttp://www.ncbi.nlm.nih.gov/geo/\n1302\nf0752e4d7f5198f86446678966b260c530d19d78\n8\n\n\n8184\n24\nMGI_Mammalian_Phenotype_2017\nhttp://www.informatics.jax.org/\n5231\n0705e59bff98deda6e9cbe00cfcdd871c85e7d04\n7\n\n\n18329\n161\nJensen_COMPARTMENTS\nhttp://compartments.jensenlab.org/\n2283\n56ec68c32d4e83edc2ee83bea0e9f6a3829b2279\n3\n\n\n15755\n28\nJensen_DISEASES\nhttp://diseases.jensenlab.org/\n1811\n3045dff8181367c1421627bb8e4c5a32c6d67f98\n3\n\n\n10271\n22\nBioPlex_2017\nhttp://bioplex.hms.harvard.edu/\n3915\nb8620b1a9d0d271d1a2747d8cfc63589dba39991\n2\n\n\n10427\n38\nGO_Cellular_Component_2017\nhttp://www.geneontology.org/\n636\n8fed21d22dfcc3015c05b31d942fdfc851cc8e04\n7\n\n\n10601\n25\nGO_Molecular_Function_2017\nhttp://www.geneontology.org/\n972\nb4018906e0a8b4e81a1b1afc51e0a2e7655403eb\n7\n\n\n13822\n21\nGO_Biological_Process_2017\nhttp://www.geneontology.org/\n3166\nd9da4dba4a3eb84d4a28a3835c06dfbbe5811f92\n7\n\n\n8002\n143\nGO_Cellular_Component_2017b\nhttp://www.geneontology.org/\n816\necf39c41fa5bc7deb625a2b5761a708676e9db7c\n7\n\n\n10089\n45\nGO_Molecular_Function_2017b\nhttp://www.geneontology.org/\n3271\n8d8340361dd36a458f1f0a401f1a3141de1f3200\n7\n\n\n13247\n49\nGO_Biological_Process_2017b\nhttp://www.geneontology.org/\n10125\n6404c38bffc2b3732de4e3fbe417b5043009fe34\n7\n\n\n21809\n2316\nARCHS4_Tissues\nhttp://amp.pharm.mssm.edu/archs4\n108\n4126374338235650ab158ba2c61cd2e2383b70df\n5\n\n\n23601\n2395\nARCHS4_Cell-lines\nhttp://amp.pharm.mssm.edu/archs4\n125\n5496ef9c9ae9429184d0b9485c23ba468ee522a8\n5\n\n\n20883\n299\nARCHS4_IDG_Coexp\nhttp://amp.pharm.mssm.edu/archs4\n352\nce60be284fdd5a9fc6240a355421a9e12b1ee84a\n4\n\n\n19612\n299\nARCHS4_Kinases_Coexp\nhttp://amp.pharm.mssm.edu/archs4\n498\n6721c5ed97b7772e4a19fdc3f797110df0164b75\n2\n\n\n25983\n299\nARCHS4_TFs_Coexp\nhttp://amp.pharm.mssm.edu/archs4\n1724\n8a468c3ae29fa68724f744cbef018f4f3b61c5ab\n1\n\n\n19500\n137\nSysMyo_Muscle_Gene_Sets\nhttp://sys-myo.rhcloud.com/\n1135\n\n8\n\n\n14893\n128\nmiRTarBase_2017\nhttp://mirtarbase.mbc.nctu.edu.tw/\n3240\n6b7c7fe2a97b19aecbfba12d8644af6875ad99c4\n1\n\n\n17598\n1208\nTargetScan_microRNA_2017\nhttp://www.targetscan.org/\n683\n79d13fb03d2fa6403f9be45c90eeda0f6822e269\n1\n\n\n5902\n109\nEnrichr_Libraries_Most_Popular_Genes\nhttp://amp.pharm.mssm.edu/Enrichr\n121\ne9b7d8ee237d0a690bd79d970a23a9fa849901ed\n6\n\n\n12486\n299\nEnrichr_Submissions_TF-Gene_Coocurrence\nhttp://amp.pharm.mssm.edu/Enrichr\n1722\nbe2ca8ef5a8c8e17d7e7bd290e7cbfe0951396c0\n1\n\n\n1073\n100\nData_Acquisition_Method_Most_Popular_Genes\nhttp://amp.pharm.mssm.edu/Enrichr\n12\n17ce5192b9eba7d109b6d228772ea8ab222e01ef\n6\n\n\n19513\n117\nDSigDB\nhttp://tanlab.ucdenver.edu/DSigDB/DSigDBv1.0/\n4026\n287476538ab98337dbe727b3985a436feb6d192a\n4\n\n\n14433\n36\nGO_Biological_Process_2018\nhttp://www.geneontology.org/\n5103\nb5b77681c46ac58cd050e60bcd4ad5041a9ab0a9\n7\n\n\n8655\n61\nGO_Cellular_Component_2018\nhttp://www.geneontology.org/\n446\ne9ebe46188efacbe1056d82987ff1c70218fa7ae\n7\n\n\n11459\n39\nGO_Molecular_Function_2018\nhttp://www.geneontology.org/\n1151\n79ff80ae9a69dd00796e52569e41422466fa0bee\n7\n\n\n19741\n270\nTF_Perturbations_Followed_by_Expression\nhttp://www.ncbi.nlm.nih.gov/geo/\n1958\n34d08a4878c19584aaf180377f2ea96faa6a6eb1\n1\n\n\n27360\n802\nChromosome_Location_hg19\nhttp://hgdownload.cse.ucsc.edu/downloads.html\n36\nfdab39c467ba6b0fb0288df1176d7dfddd7196d5\n6\n\n\n13072\n26\nNIH_Funded_PIs_2017_Human_GeneRIF\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n5687\n859b100fac3ca774ad84450b1fbb65a78fcc6b12\n6\n\n\n13464\n45\nNIH_Funded_PIs_2017_Human_AutoRIF\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n12558\nfc5bf033b932cf173633e783fc8c6228114211f8\n6\n\n\n13787\n200\nRare_Diseases_AutoRIF_ARCHS4_Predictions\nhttps://amp.pharm.mssm.edu/geneshot/\n3725\n375ff8cdd64275a916fa24707a67968a910329bb\n4\n\n\n13929\n200\nRare_Diseases_GeneRIF_ARCHS4_Predictions\nhttps://www.ncbi.nlm.nih.gov/gene/about-generif\n2244\n0f7fb7f347534779ecc6c87498e96b5460a8d652\n4\n\n\n16964\n200\nNIH_Funded_PIs_2017_AutoRIF_ARCHS4_Predictions\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n12558\nf77de51aaf0979dd6f56381cf67ba399b4640d28\n6\n\n\n17258\n200\nNIH_Funded_PIs_2017_GeneRIF_ARCHS4_Predictions\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n5684\n25fa899b715cd6a9137f6656499f89cd25144029\n6\n\n\n10352\n58\nRare_Diseases_GeneRIF_Gene_Lists\nhttps://www.ncbi.nlm.nih.gov/gene/about-generif\n2244\n0fb9ac92dbe52024661c088f71a1134f00567a8b\n4\n\n\n10471\n76\nRare_Diseases_AutoRIF_Gene_Lists\nhttps://amp.pharm.mssm.edu/geneshot/\n3725\nee3adbac2da389959410260b280e7df1fd3730df\n4\n\n\n12419\n491\nSubCell_BarCode\nhttp://www.subcellbarcode.org/\n104\nb50bb9480d8a77103fb75b331fd9dd927246939a\n2\n\n\n19378\n37\nGWAS_Catalog_2019\nhttps://www.ebi.ac.uk/gwas\n1737\nfef3864bcb5dd9e60cee27357eff30226116c49b\n7\n\n\n6201\n45\nWikiPathways_2019_Human\nhttps://www.wikipathways.org/\n472\nb0c9e9ebb9014f14561e896008087725a2db24b7\n7\n\n\n4558\n54\nWikiPathways_2019_Mouse\nhttps://www.wikipathways.org/\n176\ne7750958da20f585c8b6d5bc4451a5a4305514ba\n7\n\n\n3264\n22\nTRRUST_Transcription_Factors_2019\nhttps://www.grnpedia.org/trrust/\n571\n5f8cf93e193d2bcefa5a37ccdf0eefac576861b0\n1\n\n\n7802\n92\nKEGG_2019_Human\nhttps://www.kegg.jp/\n308\n3477bc578c4ea5d851dcb934fe2a41e9fd789bb4\n7\n\n\n8551\n98\nKEGG_2019_Mouse\nhttps://www.kegg.jp/\n303\n187eb44b2d6fa154ebf628eba1f18537f64e797c\n7\n\n\n12444\n23\nInterPro_Domains_2019\nhttps://www.ebi.ac.uk/interpro/\n1071\n18dd5ec520fdf589a93d6a7911289c205e1ddf22\n6\n\n\n9000\n20\nPfam_Domains_2019\nhttps://pfam.xfam.org/\n608\na6325ed264f9ac9e6518796076c46a1d885cca7a\n6\n\n\n7744\n363\nDepMap_WG_CRISPR_Screens_Broad_CellLines_2019\nhttps://depmap.org/\n558\n0b08b32b20854ac8a738458728a9ea50c2e04800\n7\n\n\n6204\n387\nDepMap_WG_CRISPR_Screens_Sanger_CellLines_2019\nhttps://depmap.org/\n325\nb7c4ead26d0eb64f1697c030d31682b581c8bb56\n4\n\n\n13420\n32\nMGI_Mammalian_Phenotype_Level_4_2019\nhttp://www.informatics.jax.org/\n5261\nf1bed632e89ebc054da44236c4815cdce03ef5ee\n7\n\n\n14148\n122\nUK_Biobank_GWAS_v1\nhttps://www.ukbiobank.ac.uk/tag/gwas/\n857\n958fb52e6215626673a5acf6e9289a1b84d11b4a\n4\n\n\n9813\n49\nBioPlanet_2019\nhttps://tripod.nih.gov/bioplanet/\n1510\ne110851dfc763d30946f2abedcc2cd571ac357a0\n2\n\n\n1397\n13\nClinVar_2019\nhttps://www.ncbi.nlm.nih.gov/clinvar/\n182\n0a95303f8059bec08836ecfe02ce3da951150547\n4\n\n\n9116\n22\nPheWeb_2019\nhttp://pheweb.sph.umich.edu/\n1161\n6a7c7321b6b72c5285b722f7902d26a2611117cb\n4\n\n\n17464\n63\nDisGeNET\nhttps://www.disgenet.org\n9828\n3c261626478ce9e6bf2c7f0a8014c5e901d43dc0\n4\n\n\n394\n73\nHMS_LINCS_KinomeScan\nhttp://lincs.hms.harvard.edu/kinomescan/\n148\n47ba06cdc92469ac79400fc57acd84ba343ba616\n2\n\n\n11851\n586\nCCLE_Proteomics_2020\nhttps://portals.broadinstitute.org/ccle\n378\n7094b097ae2301a1d6a5bd856a193b084cca993d\n5\n\n\n8189\n421\nProteomicsDB_2020\nhttps://www.proteomicsdb.org/\n913\n8c87c8346167bac2ba68195a32458aba9b1acfd1\n5\n\n\n18704\n100\nlncHUB_lncRNA_Co-Expression\nhttps://amp.pharm.mssm.edu/lnchub/\n3729\n45b597d7efa5693b7e4172b09c0ed2dda3305582\n1\n\n\n5605\n39\nVirus-Host_PPI_P-HIPSTer_2020\nhttp://phipster.org/\n6715\na592eed13e8e9496aedbab63003b965574e46a65\n2\n\n\n5718\n31\nElsevier_Pathway_Collection\nhttp://www.transgene.ru/disease-pathways/\n1721\n9196c760e3bcae9c9de1e3f87ad81f96bde24325\n2\n\n\n14156\n40\nTable_Mining_of_CRISPR_Studies\n\n802\nad580f3864fa8ff69eaca11f6d2e7f9b86378d08\n6\n\n\n16979\n295\nCOVID-19_Related_Gene_Sets\nhttps://amp.pharm.mssm.edu/covid19\n205\n72b0346849570f66a77a6856722601e711596cb4\n7\n\n\n4383\n146\nMSigDB_Hallmark_2020\nhttps://www.gsea-msigdb.org/gsea/msigdb/collections.jsp\n50\n6952efda94663d4bd8db09bf6eeb4e67d21ef58c\n2\n\n\n54974\n483\nEnrichr_Users_Contributed_Lists_2020\nhttps://maayanlab.cloud/Enrichr\n1482\n8dc362703b38b30ac3b68b6401a9b20a58e7d3ef\n6\n\n\n12118\n448\nTG_GATES_2020\nhttps://toxico.nibiohn.go.jp/english/\n1190\n9e32560437b11b4628b00ccf3d584360f7f7daee\n4\n\n\n12361\n124\nAllen_Brain_Atlas_10x_scRNA_2021\nhttps://portal.brain-map.org/\n766\n46f8235cb585829331799a71aec3f7c082170219\n5\n\n\n9763\n139\nDescartes_Cell_Types_and_Tissue_2021\nhttps://descartes.brotmanbaty.org/bbi/human-gene-expression-during-development/\n172\n\n5\n\n\n8078\n102\nKEGG_2021_Human\nhttps://www.kegg.jp/\n320\n\n2\n\n\n7173\n43\nWikiPathway_2021_Human\nhttps://www.wikipathways.org/\n622\n\n7\n\n\n5833\n100\nHuBMAP_ASCT_plus_B_augmented_w_RNAseq_Coexpression\nhttps://hubmapconsortium.github.io/ccf-asct-reporter/\n344\n\n5\n\n\n14937\n33\nGO_Biological_Process_2021\nhttp://www.geneontology.org/\n6036\n\n7\n\n\n11497\n80\nGO_Cellular_Component_2021\nhttp://www.geneontology.org/\n511\n\n7\n\n\n11936\n34\nGO_Molecular_Function_2021\nhttp://www.geneontology.org/\n1274\n\n7\n\n\n9767\n33\nMGI_Mammalian_Phenotype_Level_4_2021\nhttp://www.informatics.jax.org/\n4601\n\n3\n\n\n14167\n80\nCellMarker_Augmented_2021\nhttp://biocc.hrbmu.edu.cn/CellMarker/\n1097\n\n5\n\n\n17851\n102\nOrphanet_Augmented_2021\nhttp://www.orphadata.org/\n3774\n\n4\n\n\n16853\n360\nCOVID-19_Related_Gene_Sets_2021\nhttps://maayanlab.cloud/covid19/\n478\n\n4\n\n\n6654\n136\nPanglaoDB_Augmented_2021\nhttps://panglaodb.se/\n178\n\n5\n\n\n1683\n10\nAzimuth_Cell_Types_2021\nhttps://azimuth.hubmapconsortium.org/\n341\n\n5\n\n\n20414\n112\nPhenGenI_Association_2021\nhttps://www.ncbi.nlm.nih.gov/gap/phegeni\n950\n\n4\n\n\n26076\n250\nRNAseq_Automatic_GEO_Signatures_Human_Down\nhttps://maayanlab.cloud/archs4/\n4269\n\n8\n\n\n26338\n250\nRNAseq_Automatic_GEO_Signatures_Human_Up\nhttps://maayanlab.cloud/archs4/\n4269\n\n8\n\n\n25381\n250\nRNAseq_Automatic_GEO_Signatures_Mouse_Down\nhttps://maayanlab.cloud/archs4/\n4216\n\n8\n\n\n25409\n250\nRNAseq_Automatic_GEO_Signatures_Mouse_Up\nhttps://maayanlab.cloud/archs4/\n4216\n\n8\n\n\n11980\n250\nGTEx_Aging_Signatures_2021\nhttps://gtexportal.org/\n270\n\n4\n\n\n31158\n805\nHDSigDB_Human_2021\nhttps://www.hdinhd.org/\n2564\n\n4\n\n\n30006\n815\nHDSigDB_Mouse_2021\nhttps://www.hdinhd.org/\n2579\n\n4\n\n\n13370\n103\nHuBMAP_ASCTplusB_augmented_2022\nhttps://hubmapconsortium.github.io/ccf-asct-reporter/\n777\n\n5\n\n\n13697\n343\nFANTOM6_lncRNA_KD_DEGs\nhttps://fantom.gsc.riken.jp/6/\n350\n\n1\n\n\n2183\n18\nMAGMA_Drugs_and_Diseases\nhttps://github.com/nybell/drugsets/tree/main/DATA/GENESETS\n1395\n\n4\n\n\n12765\n13\nPFOCR_Pathways\nhttps://pfocr.wikipathways.org/\n17326\n\n7\n\n\n1509\n100\nTabula_Sapiens\nhttps://tabula-sapiens-portal.ds.czbiohub.org/\n469\n\n5\n\n\n18365\n1214\nChEA_2022\nhttps://maayanlab.cloud/chea3/\n757\n\n1\n\n\n13525\n175\nDiabetes_Perturbations_GEO_2022\nhttps://appyters.maayanlab.cloud/#/Gene_Expression_T2D_Signatures\n601\n\n4\n\n\n9525\n245\nLINCS_L1000_Chem_Pert_Consensus_Sigs\nhttps://maayanlab.cloud/sigcom-lincs/#/Download\n10850\n\n4\n\n\n9440\n245\nLINCS_L1000_CRISPR_KO_Consensus_Sigs\nhttps://maayanlab.cloud/sigcom-lincs/#/Download\n10424\n\n4\n\n\n3857\n80\nTabula_Muris\nhttps://tabula-muris.ds.czbiohub.org/\n106\n\n5\n\n\n10489\n61\nReactome_2022\nhttps://reactome.org/download-data\n1818\n\n2\n\n\n1198\n23\nSynGO_2022\nhttps://www.syngoportal.org/\n118\n\n3\n\n\n1882\n47\nGlyGen_Glycosylated_Proteins_2022\nhttps://www.glygen.org/\n338\n\n2\n\n\n1552\n16\nIDG_Drug_Targets_2022\nhttps://drugcentral.org/\n888\n\n4\n\n\n6713\n68\nKOMP2_Mouse_Phenotypes_2022\nhttps://www.mousephenotype.org/\n529\n\n3\n\n\n936\n15\nMetabolomics_Workbench_Metabolites_2022\nhttps://www.metabolomicsworkbench.org/\n233\n\n2\n\n\n8220\n146\nProteomics_Drug_Atlas_2023\nhttps://www.nature.com/articles/s41587-022-01539-0\n1748\n\n4\n\n\n9021\n793\nThe_Kinase_Library_2023\nhttps://kinase-library.phosphosite.org/site\n303\n\n2\n\n\n8076\n96\nGTEx_Tissues_V8_2023\nhttps://gtexportal.org/home/\n511\n\n5\n\n\n14698\n33\nGO_Biological_Process_2023\nhttp://www.geneontology.org/\n5407\n\n3\n\n\n10972\n85\nGO_Cellular_Component_2023\nhttp://www.geneontology.org/\n474\n\n3\n\n\n12126\n38\nGO_Molecular_Function_2023\nhttp://www.geneontology.org/\n1147\n\n3\n\n\n13662\n12\nPFOCR_Pathways_2023\nhttps://pfocr.wikipathways.org/\n21845\n\n2\n\n\n18290\n34\nGWAS_Catalog_2023\nhttps://www.ebi.ac.uk/gwas\n5271\n\n4\n\n\n12081\n50\nGeDiPNet_2023\nhttp://gedipnet.bicnirrh.res.in/\n2388\n\n4\n\n\n12853\n485\nMAGNET_2023\nhttps://magnet-winterlab.herokuapp.com/\n72\n\n5\n\n\n3712\n9\nAzimuth_2023\nhttps://azimuth.hubmapconsortium.org/\n1425\n\n5\n\n\n19178\n218\nRummagene_kinases\nhttps://rummagene.com/\n3810\n\n2\n\n\n19434\n369\nRummagene_signatures\nhttps://rummagene.com/\n11130\n\n8\n\n\n19379\n250\nRummagene_transcription_factors\nhttps://rummagene.com/\n7244\n\n1\n\n\n10428\n115\nMoTrPAC_2023\nhttps://motrpac-data.org/\n225\n\n5\n\n\n8044\n42\nWikiPathway_2023_Human\nhttps://www.wikipathways.org/\n801\n\n2\n\n\n9711\n414\nDepMap_CRISPR_GeneDependency_CellLines_2023\nhttps://depmap.org/\n1093\n\n4\n\n\n\n\n\n\nUploading data to Enrichr... Done.\n  Querying GO_Biological_Process_2017b... Done.\nParsing results... Done.\n\n\nSome databases of interest:\nGO_Biological_Process_2017bKEGG_2019_HumanKEGG_2019_MouseWikiPathways_2019_HumanWikiPathways_2019_Mouse\nYou visualize your results using a simple barplot, for example:\n\npar(mfrow=c(1,1),mar = c(3, 25, 2, 1))\nbarplot( height    = -log10(enrich_results$P.value)[10:1],\n        names.arg = enrich_results$Term[10:1],\n        horiz     = TRUE,\n        las       = 1,\n        border    = FALSE,\n        cex.names = .6 )\nabline(v = c(-log10(0.05)), lty = 2)\nabline(v = 0, lty = 1)"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#meta-dge_gsea",
    "href": "labs/seurat/seurat_05_dge.html#meta-dge_gsea",
    "title": " Differential gene expression",
    "section": "8 Gene Set Enrichment Analysis (GSEA)",
    "text": "8 Gene Set Enrichment Analysis (GSEA)\nBesides the enrichment using hypergeometric test, we can also perform gene set enrichment analysis (GSEA), which scores ranked genes list (usually based on fold changes) and computes permutation test to check if a particular gene set is more present in the Up-regulated genes, among the DOWN_regulated genes or not differentially regulated.\n\ncell_selection = SetIdent(cell_selection, value = \"type\")\n\nDGE_cell_selection2 &lt;- FindMarkers(\n    cell_selection,\n    ident.1 = \"Covid\",\n    log2FC.threshold = -Inf,\n    test.use = \"wilcox\",\n    min.pct = 0.1,\n    min.diff.pct = 0,\n    only.pos = FALSE,\n    max.cells.per.ident = 50,\n    assay = \"RNA\"\n)\n\n# Create a gene rank based on the gene expression fold change\ngene_rank &lt;- setNames( DGE_cell_selection2$avg_log2FC, casefold(rownames(DGE_cell_selection2),upper=T) )\n\nOnce our list of genes are sorted, we can proceed with the enrichment itself. We can use the package to get gene set from the Molecular Signature Database (MSigDB) and select KEGG pathways as an example.\n\nlibrary(msigdbr)\n\n#Download gene sets\nmsigdbgmt &lt;- msigdbr::msigdbr(\"Homo sapiens\")\nmsigdbgmt &lt;- as.data.frame(msigdbgmt)\n\n#List available gene sets\nunique(msigdbgmt$gs_subcat)\n\n#Subset which gene set you want to use.\nmsigdbgmt_subset &lt;- msigdbgmt[msigdbgmt$gs_subcat == \"CP:WIKIPATHWAYS\",]\ngmt &lt;- lapply( unique(msigdbgmt_subset$gs_name),function(x){msigdbgmt_subset [msigdbgmt_subset$gs_name == x ,\"gene_symbol\"]} )\nnames(gmt) &lt;- unique(paste0(msigdbgmt_subset$gs_name,\"_\",msigdbgmt_subset$gs_exact_source))\n\n [1] \"MIR:MIR_Legacy\"  \"TFT:TFT_Legacy\"  \"CGP\"             \"TFT:GTRD\"       \n [5] \"\"                \"VAX\"             \"CP:BIOCARTA\"     \"CGN\"            \n [9] \"GO:BP\"           \"GO:CC\"           \"IMMUNESIGDB\"     \"GO:MF\"          \n[13] \"HPO\"             \"CP:KEGG\"         \"MIR:MIRDB\"       \"CM\"             \n[17] \"CP\"              \"CP:PID\"          \"CP:REACTOME\"     \"CP:WIKIPATHWAYS\"\n\n\nNext, we will be using the GSEA. This will result in a table containing information for several pathways. We can then sort and filter those pathways to visualize only the top ones. You can select/filter them by either p-value or normalized enrichment score (NES).\n\nlibrary(fgsea)\n\n# Perform enrichemnt analysis\nfgseaRes &lt;- fgsea( pathways=gmt, stats=gene_rank, minSize=15, maxSize=500)\nfgseaRes &lt;- fgseaRes[ order(fgseaRes$pval, decreasing = T) ,]\n\n# Filter the results table to show only the top 10 UP or DOWN regulated processes (optional)\ntop10_UP &lt;- fgseaRes$pathway [1:10]\n\n# Nice summary table (shown as a plot)\nplotGseaTable(gmt[top10_UP], gene_rank, fgseaRes, gseaParam = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nWhich KEGG pathways are upregulated in this cluster?Which KEGG pathways are dowregulated in this cluster?\nChange the pathway source to another gene set (e.g. “CP:WIKIPATHWAYS” or “CP:REACTOME” or “CP:BIOCARTA” or “GO:BP”) and check the if you get similar results?\n\n\nFinally, lets save the integrated data for further analysis.\n\n# saveRDS(alldata, \"data/3pbmc_qc_dr_int_cl_dge.rds\")\n# save the list of DGE results to a file.\nwrite.csv(markers_genes, file = \"data/3pbmc_qc_dr_int_cl_dge.csv\")"
  },
  {
    "objectID": "labs/seurat/seurat_05_dge.html#meta-session",
    "href": "labs/seurat/seurat_05_dge.html#meta-session",
    "title": " Differential gene expression",
    "section": "9 Session info",
    "text": "9 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] fgsea_1.24.0                msigdbr_7.5.1              \n [3] lme4_1.1-33                 MAST_1.24.1                \n [5] SingleCellExperiment_1.20.1 SummarizedExperiment_1.28.0\n [7] Biobase_2.58.0              GenomicRanges_1.50.2       \n [9] GenomeInfoDb_1.34.9         IRanges_2.32.0             \n[11] S4Vectors_0.36.2            BiocGenerics_0.44.0        \n[13] MatrixGenerics_1.10.0       matrixStats_1.0.0          \n[15] edgeR_3.40.2                limma_3.54.2               \n[17] Matrix_1.6-0                rafalib_1.0.0              \n[19] enrichR_3.2                 pheatmap_1.0.12            \n[21] ggplot2_3.4.2               cowplot_1.1.1              \n[23] dplyr_1.1.1                 SeuratObject_4.1.3         \n[25] Seurat_4.3.0.1             \n\nloaded via a namespace (and not attached):\n  [1] fastmatch_1.1-3        plyr_1.8.8             igraph_1.5.0          \n  [4] lazyeval_0.2.2         sp_2.0-0               splines_4.2.3         \n  [7] BiocParallel_1.32.6    listenv_0.9.0          scattermore_1.2       \n [10] digest_0.6.33          htmltools_0.5.5        fansi_1.0.4           \n [13] magrittr_2.0.3         tensor_1.5             cluster_2.1.4         \n [16] ROCR_1.0-11            globals_0.16.2         spatstat.sparse_3.0-2 \n [19] prettyunits_1.1.1      colorspace_2.1-0       ggrepel_0.9.3         \n [22] WriteXLS_6.4.0         xfun_0.39              crayon_1.5.2          \n [25] RCurl_1.98-1.12        jsonlite_1.8.7         progressr_0.13.0      \n [28] spatstat.data_3.0-1    survival_3.5-3         zoo_1.8-12            \n [31] glue_1.6.2             polyclip_1.10-4        gtable_0.3.3          \n [34] zlibbioc_1.44.0        XVector_0.38.0         leiden_0.4.3          \n [37] DelayedArray_0.24.0    future.apply_1.11.0    abind_1.4-5           \n [40] scales_1.2.1           spatstat.random_3.1-5  miniUI_0.1.1.1        \n [43] Rcpp_1.0.10            progress_1.2.2         viridisLite_0.4.2     \n [46] xtable_1.8-4           reticulate_1.30        htmlwidgets_1.6.2     \n [49] httr_1.4.6             RColorBrewer_1.1-3     ellipsis_0.3.2        \n [52] ica_1.0-3              pkgconfig_2.0.3        farver_2.1.1          \n [55] uwot_0.1.16            deldir_1.0-9           locfit_1.5-9.8        \n [58] utf8_1.2.3             tidyselect_1.2.0       labeling_0.4.2        \n [61] rlang_1.1.1            reshape2_1.4.4         later_1.3.1           \n [64] munsell_0.5.0          tools_4.2.3            cli_3.6.1             \n [67] generics_0.1.3         ggridges_0.5.4         evaluate_0.21         \n [70] stringr_1.5.0          fastmap_1.1.1          yaml_2.3.7            \n [73] goftest_1.2-3          babelgene_22.9         knitr_1.43            \n [76] fitdistrplus_1.1-11    purrr_1.0.1            RANN_2.6.1            \n [79] pbapply_1.7-2          future_1.33.0          nlme_3.1-162          \n [82] mime_0.12              ggrastr_1.0.2          compiler_4.2.3        \n [85] rstudioapi_0.14        beeswarm_0.4.0         plotly_4.10.2         \n [88] curl_5.0.1             png_0.1-8              spatstat.utils_3.0-3  \n [91] tibble_3.2.1           stringi_1.7.12         lattice_0.20-45       \n [94] nloptr_2.0.3           vctrs_0.6.3            pillar_1.9.0          \n [97] lifecycle_1.0.3        spatstat.geom_3.2-1    lmtest_0.9-40         \n[100] RcppAnnoy_0.0.21       data.table_1.14.8      bitops_1.0-7          \n[103] irlba_2.3.5.1          httpuv_1.6.11          patchwork_1.1.2       \n[106] R6_2.5.1               promises_1.2.0.1       KernSmooth_2.23-20    \n[109] gridExtra_2.3          vipor_0.4.5            parallelly_1.36.0     \n[112] codetools_0.2-19       boot_1.3-28.1          MASS_7.3-58.2         \n[115] rjson_0.2.21           withr_2.5.0            sctransform_0.3.5     \n[118] GenomeInfoDbData_1.2.9 hms_1.1.3              parallel_4.2.3        \n[121] grid_4.2.3             minqa_1.2.5            tidyr_1.3.0           \n[124] rmarkdown_2.21         Rtsne_0.16             spatstat.explore_3.2-1\n[127] shiny_1.7.4            ggbeeswarm_0.7.2"
  },
  {
    "objectID": "labs/bioc/bioc_04_clustering.html",
    "href": "labs/bioc/bioc_04_clustering.html",
    "title": " Clustering",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nIn this tutorial we will continue the analysis of the integrated dataset. We will use the integrated PCA to perform the clustering. First we will construct a \\(k\\)-nearest neighbor graph in order to perform a clustering on the graph. We will also show how to perform hierarchical clustering and k-means clustering on PCA space.\nLet’s first load all necessary libraries and also the integrated dataset from the previous step.\nsuppressPackageStartupMessages({\n  library(scater)\n  library(scran)\n  library(cowplot)\n  library(ggplot2)\n  library(rafalib)\n  library(pheatmap)\n  library(igraph)\n})\n\nsce &lt;- readRDS(\"data/results/covid_qc_dr_int.rds\")"
  },
  {
    "objectID": "labs/bioc/bioc_04_clustering.html#meta-clust_graphclust",
    "href": "labs/bioc/bioc_04_clustering.html#meta-clust_graphclust",
    "title": " Clustering",
    "section": "1 Graph clustering",
    "text": "1 Graph clustering\nThe procedure of clustering on a Graph can be generalized as 3 main steps: 1) Build a kNN graph from the data 2) Prune spurious connections from kNN graph (optional step). This is a SNN graph. 3) Find groups of cells that maximizes the connections within the group compared other groups.\n\n1.1 Building kNN / SNN graph\nThe first step into graph clustering is to construct a k-nn graph, in case you don’t have one. For this, we will use the PCA space. Thus, as done for dimensionality reduction, we will use ony the top N PCA dimensions for this purpose (the same used for computing UMAP / tSNE).\n\n#These 2 lines are for demonstration purposes only\ng &lt;- buildKNNGraph(sce,k=30,use.dimred=\"MNN\")\nreducedDim(sce,\"KNN\") &lt;- igraph::as_adjacency_matrix(g)\n\n#These 2 lines are the most recommended\ng &lt;- buildSNNGraph(sce,k=30,use.dimred=\"MNN\")\nreducedDim(sce,\"SNN\")  &lt;- as_adjacency_matrix(g, attr = \"weight\")\n\nWe can take a look at the kNN graph. It is a matrix where every connection between cells is represented as \\(1\\)s. This is called a unweighted graph (default in Seurat). Some cell connections can however have more importance than others, in that case the scale of the graph from \\(0\\) to a maximum distance. Usually, the smaller the distance, the closer two points are, and stronger is their connection. This is called a weighted graph. Both weighted and unweighted graphs are suitable for clustering, but clustering on unweighted graphs is faster for large datasets (&gt; 100k cells).\n\n#plot the KNN graph\npheatmap(reducedDim(sce,\"KNN\")[1:200,1:200],\n         col=c(\"white\",\"black\"),border_color = \"grey90\",\n         legend = F,cluster_rows = F,cluster_cols = F,fontsize = 2)\n\n\n\n\n\n\n\n#or the SNN graph\npheatmap(reducedDim(sce,\"SNN\")[1:200,1:200],\n        col = colorRampPalette(c(\"white\",\"yellow\",\"red\",\"black\"))(20),\n        border_color = \"grey90\",\n         legend = T,cluster_rows = F,cluster_cols = F,fontsize = 2)\n\n\n\n\n\n\n\n\nAs you can see, the way Scran computes the SNN graph is different to Seurat. It gives edges to all cells that shares a neighbor, but weights the edges by how similar the neighbors are. Hence, the SNN graph has more edges than the KNN graph.\n\n\n1.2 Clustering on a graph\nOnce the graph is built, we can now perform graph clustering. The clustering is done respective to a resolution which can be interpreted as how coarse you want your cluster to be. Higher resolution means higher number of clusters.\n\ng &lt;- buildSNNGraph(sce,k=5,use.dimred=\"MNN\")\nsce$louvain_SNNk5 &lt;- factor( cluster_louvain(g)$membership )\n\ng &lt;- buildSNNGraph(sce,k=10,use.dimred=\"MNN\")\nsce$louvain_SNNk10 &lt;- factor( cluster_louvain(g)$membership )\n\ng &lt;- buildSNNGraph(sce,k=15,use.dimred=\"MNN\")\nsce$louvain_SNNk15 &lt;- factor( cluster_louvain(g)$membership )\n\nplot_grid(ncol = 3,\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"louvain_SNNk5\")+\n    ggplot2::ggtitle(label =\"louvain_SNNk5\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"louvain_SNNk10\")+\n    ggplot2::ggtitle(label =\"louvain_SNNk10\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"louvain_SNNk15\")+\n    ggplot2::ggtitle(label =\"louvain_SNNk15\")\n)\n\n\n\n\n\n\n\n\nWe can now use the clustree package to visualize how cells are distributed between clusters depending on resolution.\n\nsuppressPackageStartupMessages(library(clustree))\nclustree(sce, prefix = \"louvain_SNNk\")"
  },
  {
    "objectID": "labs/bioc/bioc_04_clustering.html#meta-clust_kmean",
    "href": "labs/bioc/bioc_04_clustering.html#meta-clust_kmean",
    "title": " Clustering",
    "section": "2 K-means clustering",
    "text": "2 K-means clustering\nK-means is a generic clustering algorithm that has been used in many application areas. In R, it can be applied via the kmeans function. Typically, it is applied to a reduced dimension representation of the expression data (most often PCA, because of the interpretability of the low-dimensional distances). We need to define the number of clusters in advance. Since the results depend on the initialization of the cluster centers, it is typically recommended to run K-means with multiple starting configurations (via the nstart argument).\n\nsce$kmeans_5 &lt;- factor( kmeans(x = reducedDim(sce,\"MNN\"),centers = 5)$cluster )\nsce$kmeans_10 &lt;- factor(kmeans(x = reducedDim(sce,\"MNN\"),centers = 10)$cluster)\nsce$kmeans_15 &lt;- factor(kmeans(x = reducedDim(sce,\"MNN\"),centers = 15)$cluster)\n\nplot_grid(ncol = 3,\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"kmeans_5\")+\n    ggplot2::ggtitle(label =\"KMeans5\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"kmeans_10\")+\n    ggplot2::ggtitle(label =\"KMeans10\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"kmeans_15\")+\n    ggplot2::ggtitle(label =\"KMeans15\")\n)\n\n\n\n\n\n\n\n\n\nclustree(sce, prefix = \"kmeans_\")"
  },
  {
    "objectID": "labs/bioc/bioc_04_clustering.html#meta-clust_hier",
    "href": "labs/bioc/bioc_04_clustering.html#meta-clust_hier",
    "title": " Clustering",
    "section": "3 Hierarchical clustering",
    "text": "3 Hierarchical clustering\n\n3.1 Defining distance between cells\nThe base R stats package already contains a function dist that calculates distances between all pairs of samples. Since we want to compute distances between samples, rather than among genes, we need to transpose the data before applying it to the dist function. This can be done by simply adding the transpose function t() to the data. The distance methods available in dist are: ‘euclidean’, ‘maximum’, ‘manhattan’, ‘canberra’, ‘binary’ or ‘minkowski’.\n\nd &lt;- dist( reducedDim(sce,\"MNN\"),  method=\"euclidean\")\n\nAs you might have realized, correlation is not a method implemented in the dist() function. However, we can create our own distances and transform them to a distance object. We can first compute sample correlations using the cor function.\nAs you already know, correlation range from -1 to 1, where 1 indicates that two samples are closest, -1 indicates that two samples are the furthest and 0 is somewhat in between. This, however, creates a problem in defining distances because a distance of 0 indicates that two samples are closest, 1 indicates that two samples are the furthest and distance of -1 is not meaningful. We thus need to transform the correlations to a positive scale (a.k.a. adjacency):\n[adj = ]\nOnce we transformed the correlations to a 0-1 scale, we can simply convert it to a distance object using as.dist function. The transformation does not need to have a maximum of 1, but it is more intuitive to have it at 1, rather than at any other number.\n\n#Compute sample correlations\nsample_cor &lt;- cor( Matrix::t(reducedDim(sce,\"MNN\")) )\n\n#Transform the scale from correlations\nsample_cor &lt;- (1 - sample_cor) / 2\n\n#Convert it to a distance object\nd2 &lt;- as.dist(sample_cor)\n\n\n\n3.2 Clustering cells\nAfter having calculated the distances between samples calculated, we can now proceed with the hierarchical clustering per-se. We will use the function hclust for this purpose, in which we can simply run it with the distance objects created above. The methods available are: ‘ward.D’, ‘ward.D2’, ‘single’, ‘complete’, ‘average’, ‘mcquitty’, ‘median’ or ‘centroid’. It is possible to plot the dendrogram for all cells, but this is very time consuming and we will omit for this tutorial.\n\n#euclidean\nh_euclidean &lt;- hclust(d, method=\"ward.D2\")\n\n#correlation\nh_correlation &lt;- hclust(d2, method=\"ward.D2\")\n\nOnce your dendrogram is created, the next step is to define which samples belong to a particular cluster. After identifying the dendrogram, we can now literally cut the tree at a fixed threshold (with cutree) at different levels to define the clusters. We can either define the number of clusters or decide on a height. We can simply try different clustering levels.\n\n#euclidean distance\nsce$hc_euclidean_5 &lt;- factor( cutree(h_euclidean,k = 5) )\nsce$hc_euclidean_10 &lt;- factor( cutree(h_euclidean,k = 10) )\nsce$hc_euclidean_15 &lt;- factor( cutree(h_euclidean,k = 15) )\n\n#correlation distance\nsce$hc_corelation_5 &lt;- factor( cutree(h_correlation,k = 5) )\nsce$hc_corelation_10 &lt;- factor( cutree(h_correlation,k = 10) )\nsce$hc_corelation_15 &lt;- factor( cutree(h_correlation,k = 15) )\n\n\nplot_grid(ncol = 3,\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"hc_euclidean_5\")+\n    ggplot2::ggtitle(label =\"HC_euclidean_5\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"hc_euclidean_10\")+\n    ggplot2::ggtitle(label =\"HC_euclidean_10\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"hc_euclidean_15\")+\n    ggplot2::ggtitle(label =\"HC_euclidean_15\"),\n\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"hc_corelation_5\")+\n    ggplot2::ggtitle(label =\"HC_correlation_5\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"hc_corelation_10\")+\n    ggplot2::ggtitle(label =\"HC_correlation_10\"),\n  plotReducedDim(sce,dimred = \"UMAP_on_MNN\",colour_by = \"hc_corelation_15\")+\n    ggplot2::ggtitle(label =\"HC_correlation_15\")\n)\n\n\n\n\n\n\n\n\nFinally, lets save the clustered data for further analysis.\n\nsaveRDS(sce,\"data/results/covid_qc_dr_int_cl.rds\")\n\n\n\n\n\n\n\nDiscuss\n\n\n\nBy now you should know how to plot different features onto your data. Take the QC metrics that were calculated in the first exercise, that should be stored in your data object, and plot it as violin plots per cluster using the clustering method of your choice. For example, plot number of UMIS, detected genes, percent mitochondrial reads. Then, check carefully if there is any bias in how your data is separated due to quality metrics. Could it be explained biologically, or could you have technical bias there?"
  },
  {
    "objectID": "labs/bioc/bioc_04_clustering.html#meta-session",
    "href": "labs/bioc/bioc_04_clustering.html#meta-session",
    "title": " Clustering",
    "section": "4 Session info",
    "text": "4 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] clustree_0.5.0              ggraph_2.1.0               \n [3] igraph_1.5.0                pheatmap_1.0.12            \n [5] rafalib_1.0.0               cowplot_1.1.1              \n [7] scran_1.26.2                scater_1.26.1              \n [9] ggplot2_3.4.2               scuttle_1.8.4              \n[11] SingleCellExperiment_1.20.1 SummarizedExperiment_1.28.0\n[13] Biobase_2.58.0              GenomicRanges_1.50.2       \n[15] GenomeInfoDb_1.34.9         IRanges_2.32.0             \n[17] S4Vectors_0.36.2            BiocGenerics_0.44.0        \n[19] MatrixGenerics_1.10.0       matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n [1] bitops_1.0-7              RColorBrewer_1.1-3       \n [3] backports_1.4.1           tools_4.2.3              \n [5] utf8_1.2.3                R6_2.5.1                 \n [7] irlba_2.3.5.1             vipor_0.4.5              \n [9] colorspace_2.1-0          withr_2.5.0              \n[11] tidyselect_1.2.0          gridExtra_2.3            \n[13] compiler_4.2.3            cli_3.6.1                \n[15] BiocNeighbors_1.16.0      DelayedArray_0.24.0      \n[17] labeling_0.4.2            checkmate_2.2.0          \n[19] scales_1.2.1              digest_0.6.33            \n[21] rmarkdown_2.21            XVector_0.38.0           \n[23] pkgconfig_2.0.3           htmltools_0.5.5          \n[25] sparseMatrixStats_1.10.0  fastmap_1.1.1            \n[27] limma_3.54.2              htmlwidgets_1.6.2        \n[29] rlang_1.1.1               rstudioapi_0.14          \n[31] DelayedMatrixStats_1.20.0 generics_0.1.3           \n[33] farver_2.1.1              jsonlite_1.8.7           \n[35] BiocParallel_1.32.6       dplyr_1.1.1              \n[37] RCurl_1.98-1.12           magrittr_2.0.3           \n[39] BiocSingular_1.14.0       GenomeInfoDbData_1.2.9   \n[41] Matrix_1.6-0              Rcpp_1.0.10              \n[43] ggbeeswarm_0.7.2          munsell_0.5.0            \n[45] fansi_1.0.4               viridis_0.6.3            \n[47] lifecycle_1.0.3           yaml_2.3.7               \n[49] edgeR_3.40.2              MASS_7.3-58.2            \n[51] zlibbioc_1.44.0           grid_4.2.3               \n[53] parallel_4.2.3            ggrepel_0.9.3            \n[55] dqrng_0.3.0               lattice_0.20-45          \n[57] graphlayouts_1.0.0        beachmat_2.14.2          \n[59] locfit_1.5-9.8            metapod_1.6.0            \n[61] knitr_1.43                pillar_1.9.0             \n[63] codetools_0.2-19          ScaledMatrix_1.6.0       \n[65] glue_1.6.2                evaluate_0.21            \n[67] tweenr_2.0.2              vctrs_0.6.3              \n[69] gtable_0.3.3              purrr_1.0.1              \n[71] polyclip_1.10-4           tidyr_1.3.0              \n[73] xfun_0.39                 ggforce_0.4.1            \n[75] rsvd_1.0.5                tidygraph_1.2.3          \n[77] viridisLite_0.4.2         tibble_3.2.1             \n[79] beeswarm_0.4.0            cluster_2.1.4            \n[81] bluster_1.8.0             statmod_1.5.0"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html",
    "href": "labs/scanpy/scanpy_05_dge.html",
    "title": " Differential gene expression",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run Python commands unless it starts with %%bash, in which case, those chunks run shell commands.\nIn this tutorial we will cover about Differetial gene expression, which comprises an extensive range of topics and methods. In single cell, differential expresison can have multiple functionalities such as of identifying marker genes for cell populations, as well as differentially regulated genes across conditions (healthy vs control). We will also exercise on how to account the batch information in your test.\nDifferential expression is performed with the function rank_genes_group. The default method to compute differential expression is the t-test_overestim_var. Other implemented methods are: logreg, t-test and wilcoxon.\nBy default, the .raw attribute of AnnData is used in case it has been initialized, it can be changed by setting use_raw=False.\nThe clustering with resolution 0.6 seems to give a reasonable number of clusters, so we will use that clustering for all DE tests.\nFirst, let’s import libraries and fetch the clustered data from the previous lab.\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport gseapy\nimport matplotlib.pyplot as plt\n\n # verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 2\n\nsc.settings.set_figure_params(dpi=80)\nRead in the clustered data object.\nadata = sc.read_h5ad('./data/results/scanpy_clustered_covid.h5ad')\n\nprint(adata.X.shape)\nprint(adata.raw.X.shape)\nprint(adata.raw.X[:10,:10])\n\n(5646, 3090)\n(5646, 18752)\n  (0, 1)    0.9043687482537638\n  (0, 6)    0.9043687482537638\n  (1, 6)    0.9678402572038912\n  (2, 6)    0.5124039238100646\nAs you can see, the X matrix only contains the variable genes, while the raw matrix contains all genes.\nPrinting a few of the values in adata.raw.X shows that the raw matrix is not normalized.\nFor DGE analysis we would like to run with all genes, but on normalized values, so we will have to revert back to the raw matrix and renormalize.\nadata = adata.raw.to_adata()\nsc.pp.normalize_per_cell(adata, counts_per_cell_after=1e4)\nsc.pp.log1p(adata)\nNow lets look at the clustering of the object we loaded in the umap. We will use louvain_0.6 clustering in this exercise.\nsc.pl.umap(adata, color='louvain_0.6')"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#t-test",
    "href": "labs/scanpy/scanpy_05_dge.html#t-test",
    "title": " Differential gene expression",
    "section": "1 T-test",
    "text": "1 T-test\n\nsc.tl.rank_genes_groups(adata, 'louvain_0.6', method='t-test', key_added = \"t-test\")\nsc.pl.rank_genes_groups(adata, n_genes=25, sharey=False, key = \"t-test\")\n\n# results are stored in the adata.uns[\"t-test\"] slot\nadata\n\n\n\n\n\n\n\n\nAnnData object with n_obs × n_vars = 5646 × 18752\n    obs: 'type', 'sample', 'batch', 'percent_mt2', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_hb', 'pct_counts_hb', 'n_genes', 'percent_chrY', 'XIST-counts', 'S_score', 'G2M_score', 'phase', 'doublet_scores', 'predicted_doublets', 'doublet_info', 'leiden_1.0', 'leiden_0.6', 'leiden_0.4', 'leiden_1.4', 'louvain_1.0', 'louvain_0.6', 'louvain_0.4', 'louvain_1.4', 'kmeans5', 'kmeans10', 'kmeans15', 'hclust_5', 'hclust_10', 'hclust_15'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'hb', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells'\n    uns: 'dendrogram_leiden_0.6', 'dendrogram_louvain_0.6', 'doublet_info_colors', 'hclust_10_colors', 'hclust_15_colors', 'hclust_5_colors', 'hvg', 'kmeans10_colors', 'kmeans15_colors', 'kmeans5_colors', 'leiden', 'leiden_0.4_colors', 'leiden_0.6_colors', 'leiden_1.0_colors', 'leiden_1.4_colors', 'log1p', 'louvain', 'louvain_0.4_colors', 'louvain_0.6_colors', 'louvain_1.0_colors', 'louvain_1.4_colors', 'neighbors', 'pca', 'sample_colors', 'umap', 't-test'\n    obsm: 'Scanorama', 'X_pca', 'X_tsne', 'X_umap'\n    obsp: 'connectivities', 'distances'"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#t-test-overestimated_variance",
    "href": "labs/scanpy/scanpy_05_dge.html#t-test-overestimated_variance",
    "title": " Differential gene expression",
    "section": "2 T-test overestimated_variance",
    "text": "2 T-test overestimated_variance\n\nsc.tl.rank_genes_groups(adata, 'louvain_0.6', method='t-test_overestim_var', key_added = \"t-test_ov\")\nsc.pl.rank_genes_groups(adata, n_genes=25, sharey=False, key = \"t-test_ov\")"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#wilcoxon-rank-sum",
    "href": "labs/scanpy/scanpy_05_dge.html#wilcoxon-rank-sum",
    "title": " Differential gene expression",
    "section": "3 Wilcoxon rank-sum",
    "text": "3 Wilcoxon rank-sum\nThe result of a Wilcoxon rank-sum (Mann-Whitney-U) test is very similar. We recommend using the latter in publications, see e.g., Sonison & Robinson (2018). You might also consider much more powerful differential testing packages like MAST, limma, DESeq2 and, for python, the recent diffxpy.\n\nsc.tl.rank_genes_groups(adata, 'louvain_0.6', method='wilcoxon', key_added = \"wilcoxon\")\nsc.pl.rank_genes_groups(adata, n_genes=25, sharey=False, key=\"wilcoxon\")"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#logistic-regression-test",
    "href": "labs/scanpy/scanpy_05_dge.html#logistic-regression-test",
    "title": " Differential gene expression",
    "section": "4 Logistic regression test",
    "text": "4 Logistic regression test\nAs an alternative, let us rank genes using logistic regression. For instance, this has been suggested by Natranos et al. (2018). The essential difference is that here, we use a multi-variate appraoch whereas conventional differential tests are uni-variate. Clark et al. (2014) has more details.\n\nsc.tl.rank_genes_groups(adata, 'louvain_0.6', method='logreg',key_added = \"logreg\")\nsc.pl.rank_genes_groups(adata, n_genes=25, sharey=False, key = \"logreg\")"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#compare-genes",
    "href": "labs/scanpy/scanpy_05_dge.html#compare-genes",
    "title": " Differential gene expression",
    "section": "5 Compare genes",
    "text": "5 Compare genes\nTake all significant DE genes for cluster0 with each test and compare the overlap.\n\n#compare cluster1 genes, only stores top 100 by default\n\nwc = sc.get.rank_genes_groups_df(adata, group='0', key='wilcoxon', pval_cutoff=0.01, log2fc_min=0)['names']\ntt = sc.get.rank_genes_groups_df(adata, group='0', key='t-test', pval_cutoff=0.01, log2fc_min=0)['names']\ntt_ov = sc.get.rank_genes_groups_df(adata, group='0', key='t-test_ov', pval_cutoff=0.01, log2fc_min=0)['names']\n\nfrom matplotlib_venn import venn3\n\nvenn3([set(wc),set(tt),set(tt_ov)], ('Wilcox','T-test','T-test_ov') )\nplt.show()\n\n\n\n\n\n\n\n\nAs you can see, the Wilcoxon test and the T-test with overestimated variance gives very similar result. Also the regular T-test has good overlap, while the Logistic regression gives quite different genes."
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#visualization",
    "href": "labs/scanpy/scanpy_05_dge.html#visualization",
    "title": " Differential gene expression",
    "section": "6 Visualization",
    "text": "6 Visualization\nThere are several ways to visualize the expression of top DE genes. Here we will plot top 5 genes per cluster from Wilcoxon test as heatmap, dotplot, violin plot or matrix.\n\nsc.pl.rank_genes_groups_heatmap(adata, n_genes=5, key=\"wilcoxon\", groupby=\"louvain_0.6\", show_gene_labels=True)\nsc.pl.rank_genes_groups_dotplot(adata, n_genes=5, key=\"wilcoxon\", groupby=\"louvain_0.6\")\nsc.pl.rank_genes_groups_stacked_violin(adata, n_genes=5, key=\"wilcoxon\", groupby=\"louvain_0.6\")\nsc.pl.rank_genes_groups_matrixplot(adata, n_genes=5, key=\"wilcoxon\", groupby=\"louvain_0.6\")"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#compare-specific-clusters",
    "href": "labs/scanpy/scanpy_05_dge.html#compare-specific-clusters",
    "title": " Differential gene expression",
    "section": "7 Compare specific clusters",
    "text": "7 Compare specific clusters\nWe can also do pairwise comparisons of individual clusters on one vs many clusters. For instance, clusters 1 & 2 have very similar expression profiles.\n\nsc.tl.rank_genes_groups(adata, 'louvain_0.6', groups=['1'], reference='2', method='wilcoxon')\nsc.pl.rank_genes_groups(adata, groups=['1'], n_genes=20)\n\n\n\n\n\n\n\n\nPlot as violins for those two groups.\n\nsc.pl.rank_genes_groups_violin(adata, groups='1', n_genes=10)\n\n# plot the same genes as violins across all the datasets.\n\n# convert numpy.recarray to list\nmynames = [x[0] for x in adata.uns['rank_genes_groups']['names'][:10]]\nsc.pl.stacked_violin(adata, mynames, groupby = 'louvain_0.6')"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#meta-dge_cond",
    "href": "labs/scanpy/scanpy_05_dge.html#meta-dge_cond",
    "title": " Differential gene expression",
    "section": "8 DGE across conditions",
    "text": "8 DGE across conditions\nThe second way of computing differential expression is to answer which genes are differentially expressed within a cluster. For example, in our case we have libraries comming from patients and controls and we would like to know which genes are influenced the most in a particular cell type. For this end, we will first subset our data for the desired cell cluster, then change the cell identities to the variable of comparison (which now in our case is the “type”, e.g. Covid/Ctrl).\n\ncl1 = adata[adata.obs['louvain_0.6'] == '4',:]\ncl1.obs['type'].value_counts()\n\nsc.tl.rank_genes_groups(cl1, 'type', method='wilcoxon', key_added = \"wilcoxon\")\nsc.pl.rank_genes_groups(cl1, n_genes=25, sharey=False, key=\"wilcoxon\")\n\n\n\n\n\n\n\n\n\nsc.pl.rank_genes_groups_violin(cl1, n_genes=10, key=\"wilcoxon\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also plot these genes across all clusters, but split by “type”, to check if the genes are also up/downregulated in other celltypes.\n\nimport seaborn as sns\n\ngenes1 = sc.get.rank_genes_groups_df(cl1, group='Covid', key='wilcoxon')['names'][:5]\ngenes2 = sc.get.rank_genes_groups_df(cl1, group='Ctrl', key='wilcoxon')['names'][:5]\ngenes = genes1.tolist() +  genes2.tolist() \ndf = sc.get.obs_df(adata, genes + ['louvain_0.6','type'], use_raw=False)\ndf2 = df.melt(id_vars=[\"louvain_0.6\",'type'], value_vars=genes)\n\nsns.catplot(x = \"louvain_0.6\", y = \"value\", hue = \"type\", kind = 'violin', col = \"variable\", data = df2, col_wrap=4, inner=None)\n\n\n\n\n\n\n\n\nAs you can see, we have many sex chromosome related genes among the top DE genes. And if you remember from the QC lab, we have inbalanced sex distribution among our subjects, so this may not be related to covid at all.\n\n8.1 Remove sex chromosome genes\nTo remove some of the bias due to inbalanced sex in the subjects we can remove the sex chromosome related genes.\n\nannot = sc.queries.biomart_annotations(\n        \"hsapiens\",\n        [\"ensembl_gene_id\", \"external_gene_name\", \"start_position\", \"end_position\", \"chromosome_name\"],\n    ).set_index(\"external_gene_name\")\n\nchrY_genes = adata.var_names.intersection(annot.index[annot.chromosome_name == \"Y\"])\nchrX_genes = adata.var_names.intersection(annot.index[annot.chromosome_name == \"X\"])\n\nsex_genes = chrY_genes.union(chrX_genes)\nprint(len(sex_genes))\nall_genes = cl1.var.index.tolist()\nprint(len(all_genes))\n\nkeep_genes = [x for x in all_genes if x not in sex_genes]\nprint(len(keep_genes))\n\ncl1 = cl1[:,keep_genes]\n\n536\n18752\n18216\n\n\nRerun differential expression.\n\nsc.tl.rank_genes_groups(cl1, 'type', method='wilcoxon', key_added = \"wilcoxon\")\nsc.pl.rank_genes_groups(cl1, n_genes=25, sharey=False, key=\"wilcoxon\")\n\n\n\n\n\n\n\n\n\n\n8.2 Patient batch effects\nWhen we are testing for Covid vs Control we are running a DGE test for 3 vs 3 individuals. That will be very sensitive to sample differences unless we find a way to control for it. So first, lets check how the top DGEs are expressed across the individuals:\n\ngenes1 = sc.get.rank_genes_groups_df(cl1, group='Covid', key='wilcoxon')['names'][:5]\ngenes2 = sc.get.rank_genes_groups_df(cl1, group='Ctrl', key='wilcoxon')['names'][:5]\ngenes = genes1.tolist() +  genes2.tolist() \n\nsc.pl.violin(cl1, genes1, groupby='sample')\nsc.pl.violin(cl1, genes2, groupby='sample')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs you can see, many of the genes detected as DGE in Covid are unique to one or 2 patients.\nWe can examine more genes with a DotPlot:\nWe can also plot the top Covid and top Ctrl genes as a dotplot:\n\ngenes1 = sc.get.rank_genes_groups_df(cl1, group='Covid', key='wilcoxon')['names'][:20]\ngenes2 = sc.get.rank_genes_groups_df(cl1, group='Ctrl', key='wilcoxon')['names'][:20]\ngenes = genes1.tolist() +  genes2.tolist() \n\nsc.pl.dotplot(cl1,genes, groupby='sample')\n\n\n\n\n\n\n\n\nClearly many of the top Covid genes are only high in the covid_17 sample, and not a general feature of covid patients.\nThis is also the patient with the highest number of cells in this cluster:\n\ncl1.obs['sample'].value_counts()\n\nctrl_13     232\nctrl_14     164\nctrl_5       58\ncovid_1      48\ncovid_17     26\ncovid_15     13\nName: sample, dtype: int64\n\n\n\n\n8.3 Subsample\nSo one obvious thing to consider is an equal amount of cells per individual so that the DGE results are not dominated by a single sample.\nSo we will downsample to an equal number of cells per sample.\n\ncl1.obs['sample'].value_counts()\n\nctrl_13     232\nctrl_14     164\nctrl_5       58\ncovid_1      48\ncovid_17     26\ncovid_15     13\nName: sample, dtype: int64\n\n\n\ntarget_cells = 50\n\ntmp = [cl1[cl1.obs['sample'] == s] for s in cl1.obs['sample'].cat.categories]\n\nfor dat in tmp:\n    if dat.n_obs &gt; target_cells:\n            sc.pp.subsample(dat, n_obs=target_cells)\n\ncl1_sub = tmp[0].concatenate(*tmp[1:])\n\ncl1_sub.obs['sample'].value_counts()\n\nctrl_5      50\nctrl_13     50\nctrl_14     50\ncovid_1     48\ncovid_17    26\ncovid_15    13\nName: sample, dtype: int64\n\n\n\nsc.tl.rank_genes_groups(cl1_sub, 'type', method='wilcoxon', key_added = \"wilcoxon\")\nsc.pl.rank_genes_groups(cl1_sub, n_genes=25, sharey=False, key=\"wilcoxon\")\n\n\n\n\n\n\n\n\n\ngenes1 = sc.get.rank_genes_groups_df(cl1_sub, group='Covid', key='wilcoxon')['names'][:20]\ngenes2 = sc.get.rank_genes_groups_df(cl1_sub, group='Ctrl', key='wilcoxon')['names'][:20]\ngenes = genes1.tolist() +  genes2.tolist() \n\nsc.pl.dotplot(cl1,genes, groupby='sample')\n\n\n\n\n\n\n\n\nIt looks much better now. But if we look per patient you can see that we still have some genes that are dominated by a single patient. Still, it is often a good idea to control the number of cells from each sample when doing differential expression.\nWhy do you think this is?\nThere are many different ways to try and resolve the issue of patient batch effects, however most of them require R packages. These can be run via rpy2 as is demonstraded in this compendium: https://www.sc-best-practices.org/conditions/differential_gene_expression.html\nHowever, we have not included it here as of now. So please have a look at the patient batch effect section in the seurat DGE tutorial where we run EdgeR on pseudobulk and MAST with random effect."
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#meta-dge_gsa",
    "href": "labs/scanpy/scanpy_05_dge.html#meta-dge_gsa",
    "title": " Differential gene expression",
    "section": "9 Gene Set Analysis (GSA)",
    "text": "9 Gene Set Analysis (GSA)\n\n9.1 Hypergeometric enrichment test\nHaving a defined list of differentially expressed genes, you can now look for their combined function using hypergeometric test.\n\n#Available databases : ‘Human’, ‘Mouse’, ‘Yeast’, ‘Fly’, ‘Fish’, ‘Worm’ \ngene_set_names = gseapy.get_library_name(organism='Human')\nprint(gene_set_names)\n\n['ARCHS4_Cell-lines', 'ARCHS4_IDG_Coexp', 'ARCHS4_Kinases_Coexp', 'ARCHS4_TFs_Coexp', 'ARCHS4_Tissues', 'Achilles_fitness_decrease', 'Achilles_fitness_increase', 'Aging_Perturbations_from_GEO_down', 'Aging_Perturbations_from_GEO_up', 'Allen_Brain_Atlas_10x_scRNA_2021', 'Allen_Brain_Atlas_down', 'Allen_Brain_Atlas_up', 'Azimuth_2023', 'Azimuth_Cell_Types_2021', 'BioCarta_2013', 'BioCarta_2015', 'BioCarta_2016', 'BioPlanet_2019', 'BioPlex_2017', 'CCLE_Proteomics_2020', 'CORUM', 'COVID-19_Related_Gene_Sets', 'COVID-19_Related_Gene_Sets_2021', 'Cancer_Cell_Line_Encyclopedia', 'CellMarker_Augmented_2021', 'ChEA_2013', 'ChEA_2015', 'ChEA_2016', 'ChEA_2022', 'Chromosome_Location', 'Chromosome_Location_hg19', 'ClinVar_2019', 'DSigDB', 'Data_Acquisition_Method_Most_Popular_Genes', 'DepMap_CRISPR_GeneDependency_CellLines_2023', 'DepMap_WG_CRISPR_Screens_Broad_CellLines_2019', 'DepMap_WG_CRISPR_Screens_Sanger_CellLines_2019', 'Descartes_Cell_Types_and_Tissue_2021', 'Diabetes_Perturbations_GEO_2022', 'DisGeNET', 'Disease_Perturbations_from_GEO_down', 'Disease_Perturbations_from_GEO_up', 'Disease_Signatures_from_GEO_down_2014', 'Disease_Signatures_from_GEO_up_2014', 'DrugMatrix', 'Drug_Perturbations_from_GEO_2014', 'Drug_Perturbations_from_GEO_down', 'Drug_Perturbations_from_GEO_up', 'ENCODE_Histone_Modifications_2013', 'ENCODE_Histone_Modifications_2015', 'ENCODE_TF_ChIP-seq_2014', 'ENCODE_TF_ChIP-seq_2015', 'ENCODE_and_ChEA_Consensus_TFs_from_ChIP-X', 'ESCAPE', 'Elsevier_Pathway_Collection', 'Enrichr_Libraries_Most_Popular_Genes', 'Enrichr_Submissions_TF-Gene_Coocurrence', 'Enrichr_Users_Contributed_Lists_2020', 'Epigenomics_Roadmap_HM_ChIP-seq', 'FANTOM6_lncRNA_KD_DEGs', 'GO_Biological_Process_2013', 'GO_Biological_Process_2015', 'GO_Biological_Process_2017', 'GO_Biological_Process_2017b', 'GO_Biological_Process_2018', 'GO_Biological_Process_2021', 'GO_Biological_Process_2023', 'GO_Cellular_Component_2013', 'GO_Cellular_Component_2015', 'GO_Cellular_Component_2017', 'GO_Cellular_Component_2017b', 'GO_Cellular_Component_2018', 'GO_Cellular_Component_2021', 'GO_Cellular_Component_2023', 'GO_Molecular_Function_2013', 'GO_Molecular_Function_2015', 'GO_Molecular_Function_2017', 'GO_Molecular_Function_2017b', 'GO_Molecular_Function_2018', 'GO_Molecular_Function_2021', 'GO_Molecular_Function_2023', 'GTEx_Aging_Signatures_2021', 'GTEx_Tissue_Expression_Down', 'GTEx_Tissue_Expression_Up', 'GTEx_Tissues_V8_2023', 'GWAS_Catalog_2019', 'GWAS_Catalog_2023', 'GeDiPNet_2023', 'GeneSigDB', 'Gene_Perturbations_from_GEO_down', 'Gene_Perturbations_from_GEO_up', 'Genes_Associated_with_NIH_Grants', 'Genome_Browser_PWMs', 'GlyGen_Glycosylated_Proteins_2022', 'HDSigDB_Human_2021', 'HDSigDB_Mouse_2021', 'HMDB_Metabolites', 'HMS_LINCS_KinomeScan', 'HomoloGene', 'HuBMAP_ASCT_plus_B_augmented_w_RNAseq_Coexpression', 'HuBMAP_ASCTplusB_augmented_2022', 'HumanCyc_2015', 'HumanCyc_2016', 'Human_Gene_Atlas', 'Human_Phenotype_Ontology', 'IDG_Drug_Targets_2022', 'InterPro_Domains_2019', 'Jensen_COMPARTMENTS', 'Jensen_DISEASES', 'Jensen_TISSUES', 'KEA_2013', 'KEA_2015', 'KEGG_2013', 'KEGG_2015', 'KEGG_2016', 'KEGG_2019_Human', 'KEGG_2019_Mouse', 'KEGG_2021_Human', 'KOMP2_Mouse_Phenotypes_2022', 'Kinase_Perturbations_from_GEO_down', 'Kinase_Perturbations_from_GEO_up', 'L1000_Kinase_and_GPCR_Perturbations_down', 'L1000_Kinase_and_GPCR_Perturbations_up', 'LINCS_L1000_CRISPR_KO_Consensus_Sigs', 'LINCS_L1000_Chem_Pert_Consensus_Sigs', 'LINCS_L1000_Chem_Pert_down', 'LINCS_L1000_Chem_Pert_up', 'LINCS_L1000_Ligand_Perturbations_down', 'LINCS_L1000_Ligand_Perturbations_up', 'Ligand_Perturbations_from_GEO_down', 'Ligand_Perturbations_from_GEO_up', 'MAGMA_Drugs_and_Diseases', 'MAGNET_2023', 'MCF7_Perturbations_from_GEO_down', 'MCF7_Perturbations_from_GEO_up', 'MGI_Mammalian_Phenotype_2013', 'MGI_Mammalian_Phenotype_2017', 'MGI_Mammalian_Phenotype_Level_3', 'MGI_Mammalian_Phenotype_Level_4', 'MGI_Mammalian_Phenotype_Level_4_2019', 'MGI_Mammalian_Phenotype_Level_4_2021', 'MSigDB_Computational', 'MSigDB_Hallmark_2020', 'MSigDB_Oncogenic_Signatures', 'Metabolomics_Workbench_Metabolites_2022', 'Microbe_Perturbations_from_GEO_down', 'Microbe_Perturbations_from_GEO_up', 'MoTrPAC_2023', 'Mouse_Gene_Atlas', 'NCI-60_Cancer_Cell_Lines', 'NCI-Nature_2015', 'NCI-Nature_2016', 'NIH_Funded_PIs_2017_AutoRIF_ARCHS4_Predictions', 'NIH_Funded_PIs_2017_GeneRIF_ARCHS4_Predictions', 'NIH_Funded_PIs_2017_Human_AutoRIF', 'NIH_Funded_PIs_2017_Human_GeneRIF', 'NURSA_Human_Endogenous_Complexome', 'OMIM_Disease', 'OMIM_Expanded', 'Old_CMAP_down', 'Old_CMAP_up', 'Orphanet_Augmented_2021', 'PFOCR_Pathways', 'PFOCR_Pathways_2023', 'PPI_Hub_Proteins', 'PanglaoDB_Augmented_2021', 'Panther_2015', 'Panther_2016', 'Pfam_Domains_2019', 'Pfam_InterPro_Domains', 'PheWeb_2019', 'PhenGenI_Association_2021', 'Phosphatase_Substrates_from_DEPOD', 'ProteomicsDB_2020', 'Proteomics_Drug_Atlas_2023', 'RNA-Seq_Disease_Gene_and_Drug_Signatures_from_GEO', 'RNAseq_Automatic_GEO_Signatures_Human_Down', 'RNAseq_Automatic_GEO_Signatures_Human_Up', 'RNAseq_Automatic_GEO_Signatures_Mouse_Down', 'RNAseq_Automatic_GEO_Signatures_Mouse_Up', 'Rare_Diseases_AutoRIF_ARCHS4_Predictions', 'Rare_Diseases_AutoRIF_Gene_Lists', 'Rare_Diseases_GeneRIF_ARCHS4_Predictions', 'Rare_Diseases_GeneRIF_Gene_Lists', 'Reactome_2013', 'Reactome_2015', 'Reactome_2016', 'Reactome_2022', 'Rummagene_kinases', 'Rummagene_signatures', 'Rummagene_transcription_factors', 'SILAC_Phosphoproteomics', 'SubCell_BarCode', 'SynGO_2022', 'SysMyo_Muscle_Gene_Sets', 'TF-LOF_Expression_from_GEO', 'TF_Perturbations_Followed_by_Expression', 'TG_GATES_2020', 'TRANSFAC_and_JASPAR_PWMs', 'TRRUST_Transcription_Factors_2019', 'Table_Mining_of_CRISPR_Studies', 'Tabula_Muris', 'Tabula_Sapiens', 'TargetScan_microRNA', 'TargetScan_microRNA_2017', 'The_Kinase_Library_2023', 'Tissue_Protein_Expression_from_Human_Proteome_Map', 'Tissue_Protein_Expression_from_ProteomicsDB', 'Transcription_Factor_PPIs', 'UK_Biobank_GWAS_v1', 'Virus-Host_PPI_P-HIPSTer_2020', 'VirusMINT', 'Virus_Perturbations_from_GEO_down', 'Virus_Perturbations_from_GEO_up', 'WikiPathway_2021_Human', 'WikiPathway_2023_Human', 'WikiPathways_2013', 'WikiPathways_2015', 'WikiPathways_2016', 'WikiPathways_2019_Human', 'WikiPathways_2019_Mouse', 'dbGaP', 'huMAP', 'lncHUB_lncRNA_Co-Expression', 'miRTarBase_2017']\n\n\nGet the significant DEGs for the Covid patients.\n\n#?gseapy.enrichr\nglist = sc.get.rank_genes_groups_df(cl1_sub, group='Covid', key='wilcoxon', log2fc_min=0.25, pval_cutoff=0.05)['names'].squeeze().str.strip().tolist()\nprint(len(glist))\n\n281\n\n\n\nenr_res = gseapy.enrichr(gene_list=glist, organism='Human', gene_sets='GO_Biological_Process_2018', cutoff = 0.5)\nenr_res.results.head()\n\n\n\n\n\n\n\n\nGene_set\nTerm\nOverlap\nP-value\nAdjusted P-value\nOld P-value\nOld Adjusted P-value\nOdds Ratio\nCombined Score\nGenes\n\n\n\n\n0\nGO_Biological_Process_2018\nneutrophil degranulation (GO:0043312)\n35/479\n1.325372e-15\n1.502220e-12\n0\n0\n6.176527\n211.589805\nCD63;PSMD11;MGST1;FPR1;PYGL;PLAC8;PYCARD;HK3;G...\n\n\n1\nGO_Biological_Process_2018\nneutrophil activation involved in immune respo...\n35/483\n1.706660e-15\n1.502220e-12\n0\n0\n6.120109\n208.109652\nCD63;PSMD11;MGST1;FPR1;PYGL;PLAC8;PYCARD;HK3;G...\n\n\n2\nGO_Biological_Process_2018\nneutrophil mediated immunity (GO:0002446)\n35/487\n2.191955e-15\n1.502220e-12\n0\n0\n6.064690\n204.707437\nCD63;PSMD11;MGST1;FPR1;PYGL;PLAC8;PYCARD;HK3;G...\n\n\n3\nGO_Biological_Process_2018\ncytokine-mediated signaling pathway (GO:0019221)\n36/633\n1.002075e-12\n5.150664e-10\n0\n0\n4.706471\n130.034848\nIFITM3;IFITM1;CDKN1A;IFITM2;PSMD11;CXCL8;FPR1;...\n\n\n4\nGO_Biological_Process_2018\ncellular response to type I interferon (GO:007...\n12/65\n9.717995e-11\n3.330033e-08\n0\n0\n16.552711\n381.613757\nIFITM3;ISG20;EGR1;IFITM1;IFITM2;OAS1;IFI27;MX2...\n\n\n\n\n\n\n\nSome databases of interest:\nGO_Biological_Process_2017bKEGG_2019_HumanKEGG_2019_MouseWikiPathways_2019_HumanWikiPathways_2019_Mouse\nYou visualize your results using a simple barplot, for example:\n\ngseapy.barplot(enr_res.res2d,title='GO_Biological_Process_2018')\n\n&lt;AxesSubplot: title={'center': 'GO_Biological_Process_2018'}, xlabel='$- \\\\log_{10}$ (Adjusted P-value)'&gt;"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#meta-dge_gsea",
    "href": "labs/scanpy/scanpy_05_dge.html#meta-dge_gsea",
    "title": " Differential gene expression",
    "section": "10 Gene Set Enrichment Analysis (GSEA)",
    "text": "10 Gene Set Enrichment Analysis (GSEA)\nBesides the enrichment using hypergeometric test, we can also perform gene set enrichment analysis (GSEA), which scores ranked genes list (usually based on fold changes) and computes permutation test to check if a particular gene set is more present in the Up-regulated genes, among the DOWN_regulated genes or not differentially regulated.\nWe need a table with all DEGs and their log foldchanges. However, many lowly expressed genes will have high foldchanges and just contribue noise, so also filter for expression in enough cells.\n\ngene_rank = sc.get.rank_genes_groups_df(cl1_sub, group='Covid', key='wilcoxon')[['names','logfoldchanges']]\ngene_rank.sort_values(by=['logfoldchanges'], inplace=True, ascending=False)\n\n# calculate_qc_metrics will calculate number of cells per gene\nsc.pp.calculate_qc_metrics(cl1, percent_top=None, log1p=False, inplace=True)\n\n# filter for genes expressed in at least 30 cells.\ngene_rank = gene_rank[gene_rank['names'].isin(cl1.var_names[cl1.var.n_cells_by_counts&gt;30])]\n\ngene_rank\n\n\n\n\n\n\n\n\nnames\nlogfoldchanges\n\n\n\n\n234\nUSP18\n4.887529\n\n\n104\nIGHA1\n3.949443\n\n\n348\nANKRD22\n3.885875\n\n\n373\nIGLC2\n3.848717\n\n\n442\nST20\n3.815957\n\n\n...\n...\n...\n\n\n16711\nTRBC2\n-3.788429\n\n\n17513\nFCER1A\n-4.609855\n\n\n16648\nTMEM8B\n-25.670713\n\n\n16790\nGZMB\n-26.336149\n\n\n18067\nAC004556.1\n-28.746210\n\n\n\n\n8439 rows × 2 columns\n\n\n\nOnce our list of genes are sorted, we can proceed with the enrichment itself. We can use the package to get gene set from the Molecular Signature Database (MSigDB) and select KEGG pathways as an example.\n\n#Available databases : ‘Human’, ‘Mouse’, ‘Yeast’, ‘Fly’, ‘Fish’, ‘Worm’ \ngene_set_names = gseapy.get_library_name(organism='Human')\nprint(gene_set_names)\n\n['ARCHS4_Cell-lines', 'ARCHS4_IDG_Coexp', 'ARCHS4_Kinases_Coexp', 'ARCHS4_TFs_Coexp', 'ARCHS4_Tissues', 'Achilles_fitness_decrease', 'Achilles_fitness_increase', 'Aging_Perturbations_from_GEO_down', 'Aging_Perturbations_from_GEO_up', 'Allen_Brain_Atlas_10x_scRNA_2021', 'Allen_Brain_Atlas_down', 'Allen_Brain_Atlas_up', 'Azimuth_2023', 'Azimuth_Cell_Types_2021', 'BioCarta_2013', 'BioCarta_2015', 'BioCarta_2016', 'BioPlanet_2019', 'BioPlex_2017', 'CCLE_Proteomics_2020', 'CORUM', 'COVID-19_Related_Gene_Sets', 'COVID-19_Related_Gene_Sets_2021', 'Cancer_Cell_Line_Encyclopedia', 'CellMarker_Augmented_2021', 'ChEA_2013', 'ChEA_2015', 'ChEA_2016', 'ChEA_2022', 'Chromosome_Location', 'Chromosome_Location_hg19', 'ClinVar_2019', 'DSigDB', 'Data_Acquisition_Method_Most_Popular_Genes', 'DepMap_CRISPR_GeneDependency_CellLines_2023', 'DepMap_WG_CRISPR_Screens_Broad_CellLines_2019', 'DepMap_WG_CRISPR_Screens_Sanger_CellLines_2019', 'Descartes_Cell_Types_and_Tissue_2021', 'Diabetes_Perturbations_GEO_2022', 'DisGeNET', 'Disease_Perturbations_from_GEO_down', 'Disease_Perturbations_from_GEO_up', 'Disease_Signatures_from_GEO_down_2014', 'Disease_Signatures_from_GEO_up_2014', 'DrugMatrix', 'Drug_Perturbations_from_GEO_2014', 'Drug_Perturbations_from_GEO_down', 'Drug_Perturbations_from_GEO_up', 'ENCODE_Histone_Modifications_2013', 'ENCODE_Histone_Modifications_2015', 'ENCODE_TF_ChIP-seq_2014', 'ENCODE_TF_ChIP-seq_2015', 'ENCODE_and_ChEA_Consensus_TFs_from_ChIP-X', 'ESCAPE', 'Elsevier_Pathway_Collection', 'Enrichr_Libraries_Most_Popular_Genes', 'Enrichr_Submissions_TF-Gene_Coocurrence', 'Enrichr_Users_Contributed_Lists_2020', 'Epigenomics_Roadmap_HM_ChIP-seq', 'FANTOM6_lncRNA_KD_DEGs', 'GO_Biological_Process_2013', 'GO_Biological_Process_2015', 'GO_Biological_Process_2017', 'GO_Biological_Process_2017b', 'GO_Biological_Process_2018', 'GO_Biological_Process_2021', 'GO_Biological_Process_2023', 'GO_Cellular_Component_2013', 'GO_Cellular_Component_2015', 'GO_Cellular_Component_2017', 'GO_Cellular_Component_2017b', 'GO_Cellular_Component_2018', 'GO_Cellular_Component_2021', 'GO_Cellular_Component_2023', 'GO_Molecular_Function_2013', 'GO_Molecular_Function_2015', 'GO_Molecular_Function_2017', 'GO_Molecular_Function_2017b', 'GO_Molecular_Function_2018', 'GO_Molecular_Function_2021', 'GO_Molecular_Function_2023', 'GTEx_Aging_Signatures_2021', 'GTEx_Tissue_Expression_Down', 'GTEx_Tissue_Expression_Up', 'GTEx_Tissues_V8_2023', 'GWAS_Catalog_2019', 'GWAS_Catalog_2023', 'GeDiPNet_2023', 'GeneSigDB', 'Gene_Perturbations_from_GEO_down', 'Gene_Perturbations_from_GEO_up', 'Genes_Associated_with_NIH_Grants', 'Genome_Browser_PWMs', 'GlyGen_Glycosylated_Proteins_2022', 'HDSigDB_Human_2021', 'HDSigDB_Mouse_2021', 'HMDB_Metabolites', 'HMS_LINCS_KinomeScan', 'HomoloGene', 'HuBMAP_ASCT_plus_B_augmented_w_RNAseq_Coexpression', 'HuBMAP_ASCTplusB_augmented_2022', 'HumanCyc_2015', 'HumanCyc_2016', 'Human_Gene_Atlas', 'Human_Phenotype_Ontology', 'IDG_Drug_Targets_2022', 'InterPro_Domains_2019', 'Jensen_COMPARTMENTS', 'Jensen_DISEASES', 'Jensen_TISSUES', 'KEA_2013', 'KEA_2015', 'KEGG_2013', 'KEGG_2015', 'KEGG_2016', 'KEGG_2019_Human', 'KEGG_2019_Mouse', 'KEGG_2021_Human', 'KOMP2_Mouse_Phenotypes_2022', 'Kinase_Perturbations_from_GEO_down', 'Kinase_Perturbations_from_GEO_up', 'L1000_Kinase_and_GPCR_Perturbations_down', 'L1000_Kinase_and_GPCR_Perturbations_up', 'LINCS_L1000_CRISPR_KO_Consensus_Sigs', 'LINCS_L1000_Chem_Pert_Consensus_Sigs', 'LINCS_L1000_Chem_Pert_down', 'LINCS_L1000_Chem_Pert_up', 'LINCS_L1000_Ligand_Perturbations_down', 'LINCS_L1000_Ligand_Perturbations_up', 'Ligand_Perturbations_from_GEO_down', 'Ligand_Perturbations_from_GEO_up', 'MAGMA_Drugs_and_Diseases', 'MAGNET_2023', 'MCF7_Perturbations_from_GEO_down', 'MCF7_Perturbations_from_GEO_up', 'MGI_Mammalian_Phenotype_2013', 'MGI_Mammalian_Phenotype_2017', 'MGI_Mammalian_Phenotype_Level_3', 'MGI_Mammalian_Phenotype_Level_4', 'MGI_Mammalian_Phenotype_Level_4_2019', 'MGI_Mammalian_Phenotype_Level_4_2021', 'MSigDB_Computational', 'MSigDB_Hallmark_2020', 'MSigDB_Oncogenic_Signatures', 'Metabolomics_Workbench_Metabolites_2022', 'Microbe_Perturbations_from_GEO_down', 'Microbe_Perturbations_from_GEO_up', 'MoTrPAC_2023', 'Mouse_Gene_Atlas', 'NCI-60_Cancer_Cell_Lines', 'NCI-Nature_2015', 'NCI-Nature_2016', 'NIH_Funded_PIs_2017_AutoRIF_ARCHS4_Predictions', 'NIH_Funded_PIs_2017_GeneRIF_ARCHS4_Predictions', 'NIH_Funded_PIs_2017_Human_AutoRIF', 'NIH_Funded_PIs_2017_Human_GeneRIF', 'NURSA_Human_Endogenous_Complexome', 'OMIM_Disease', 'OMIM_Expanded', 'Old_CMAP_down', 'Old_CMAP_up', 'Orphanet_Augmented_2021', 'PFOCR_Pathways', 'PFOCR_Pathways_2023', 'PPI_Hub_Proteins', 'PanglaoDB_Augmented_2021', 'Panther_2015', 'Panther_2016', 'Pfam_Domains_2019', 'Pfam_InterPro_Domains', 'PheWeb_2019', 'PhenGenI_Association_2021', 'Phosphatase_Substrates_from_DEPOD', 'ProteomicsDB_2020', 'Proteomics_Drug_Atlas_2023', 'RNA-Seq_Disease_Gene_and_Drug_Signatures_from_GEO', 'RNAseq_Automatic_GEO_Signatures_Human_Down', 'RNAseq_Automatic_GEO_Signatures_Human_Up', 'RNAseq_Automatic_GEO_Signatures_Mouse_Down', 'RNAseq_Automatic_GEO_Signatures_Mouse_Up', 'Rare_Diseases_AutoRIF_ARCHS4_Predictions', 'Rare_Diseases_AutoRIF_Gene_Lists', 'Rare_Diseases_GeneRIF_ARCHS4_Predictions', 'Rare_Diseases_GeneRIF_Gene_Lists', 'Reactome_2013', 'Reactome_2015', 'Reactome_2016', 'Reactome_2022', 'Rummagene_kinases', 'Rummagene_signatures', 'Rummagene_transcription_factors', 'SILAC_Phosphoproteomics', 'SubCell_BarCode', 'SynGO_2022', 'SysMyo_Muscle_Gene_Sets', 'TF-LOF_Expression_from_GEO', 'TF_Perturbations_Followed_by_Expression', 'TG_GATES_2020', 'TRANSFAC_and_JASPAR_PWMs', 'TRRUST_Transcription_Factors_2019', 'Table_Mining_of_CRISPR_Studies', 'Tabula_Muris', 'Tabula_Sapiens', 'TargetScan_microRNA', 'TargetScan_microRNA_2017', 'The_Kinase_Library_2023', 'Tissue_Protein_Expression_from_Human_Proteome_Map', 'Tissue_Protein_Expression_from_ProteomicsDB', 'Transcription_Factor_PPIs', 'UK_Biobank_GWAS_v1', 'Virus-Host_PPI_P-HIPSTer_2020', 'VirusMINT', 'Virus_Perturbations_from_GEO_down', 'Virus_Perturbations_from_GEO_up', 'WikiPathway_2021_Human', 'WikiPathway_2023_Human', 'WikiPathways_2013', 'WikiPathways_2015', 'WikiPathways_2016', 'WikiPathways_2019_Human', 'WikiPathways_2019_Mouse', 'dbGaP', 'huMAP', 'lncHUB_lncRNA_Co-Expression', 'miRTarBase_2017']\n\n\nNext, we will be using the GSEA. This will result in a table containing information for several pathways. We can then sort and filter those pathways to visualize only the top ones. You can select/filter them by either p-value or normalized enrichment score (NES).\n\nres = gseapy.prerank(rnk=gene_rank, gene_sets='KEGG_2021_Human')\n\nterms = res.res2d.Term\nterms[:10]\n\n0                           Autoimmune thyroid disease\n1                                  Allograft rejection\n2                            Graft-versus-host disease\n3                             Type I diabetes mellitus\n4            Natural killer cell mediated cytotoxicity\n5           Valine, leucine and isoleucine degradation\n6                  Complement and coagulation cascades\n7                               Fatty acid degradation\n8                                               Asthma\n9    Viral protein interaction with cytokine and cy...\nName: Term, dtype: object\n\n\n\ngseapy.gseaplot(rank_metric=res.ranking, term=terms[0], **res.results[terms[0]])\n\n[&lt;Axes: xlabel='Gene Rank', ylabel='Ranked metric'&gt;,\n &lt;Axes: &gt;,\n &lt;Axes: &gt;,\n &lt;Axes: ylabel='Enrichment Score'&gt;]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nWhich KEGG pathways are upregulated in this cluster?Which KEGG pathways are dowregulated in this cluster?\nChange the pathway source to another gene set (e.g. “CP:WIKIPATHWAYS” or “CP:REACTOME” or “CP:BIOCARTA” or “GO:BP”) and check the if you get similar results?\n\n\nFinally, lets save the integrated data for further analysis.\n\nadata.write_h5ad('./data/results/scanpy_DGE_covid.h5ad')"
  },
  {
    "objectID": "labs/scanpy/scanpy_05_dge.html#meta-session",
    "href": "labs/scanpy/scanpy_05_dge.html#meta-session",
    "title": " Differential gene expression",
    "section": "11 Session info",
    "text": "11 Session info\n\nsc.logging.print_versions()\n\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfqdn                        NA\nfuture                      0.18.3\nget_version                 3.5.4\ngseapy                      1.0.6\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nipykernel                   6.25.2\nipywidgets                  8.1.1\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmatplotlib_venn             0.11.9\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npatsy                       0.5.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npybiomart                   0.2.0\npycparser                   2.21\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrequests_cache              0.4.13\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanpy                      1.7.2\nscipy                       1.10.1\nseaborn                     0.12.2\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nstack_data                  0.6.2\nstatsmodels                 0.14.0\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntraitlets                   5.11.2\ntyping_extensions           NA\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-10 19:24"
  },
  {
    "objectID": "labs/scanpy/scanpy_06_celltyping.html",
    "href": "labs/scanpy/scanpy_06_celltyping.html",
    "title": " Celltype prediction",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run Python commands unless it starts with %%bash, in which case, those chunks run shell commands.\nCelltype prediction can either be performed on indiviudal cells where each cell gets a predicted celltype label, or on the level of clusters. All methods are based on similarity to other datasets, single cell or sorted bulk RNAseq, or uses known marker genes for each celltype.\nWe will select one sample from the Covid data, ctrl_13 and predict celltype by cell on that sample.\nSome methods will predict a celltype to each cell based on what it is most similar to even if the celltype of that cell is not included in the reference. Other methods include an uncertainty so that cells with low similarity scores will be unclassified.\nThere are multiple different methods to predict celltypes, here we will just cover a few of those.\nHere we will use a reference PBMC dataset that we get from scanpy datasets and classify celltypes based on two methods:\nFirst, lets load required libraries\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 2             \nsc.settings.set_figure_params(dpi=80)\nLet’s read in the saved Covid-19 data object from the clustering step.\nadata = sc.read_h5ad('./data/results/scanpy_clustered_covid.h5ad')\nadata.uns['log1p']['base']=None\n\nprint(adata.shape)\nprint(adata.raw.shape)\n\n(5646, 3090)\n(5646, 18752)\nSubset one patient.\nadata = adata[adata.obs[\"sample\"] == \"ctrl_13\",:]\nprint(adata.shape)\n\n(1132, 3090)\nsc.pl.umap(\n    adata, color=[\"louvain_0.6\"], palette=sc.pl.palettes.default_20\n)"
  },
  {
    "objectID": "labs/scanpy/scanpy_06_celltyping.html#meta-ct_ref",
    "href": "labs/scanpy/scanpy_06_celltyping.html#meta-ct_ref",
    "title": " Celltype prediction",
    "section": "1 Reference data",
    "text": "1 Reference data\nLoad the reference data from scanpy.datasets. It is the annotated and processed pbmc3k dataset from 10x.\n\nadata_ref = sc.datasets.pbmc3k_processed() \n\nadata_ref.obs['sample']='pbmc3k'\n\nprint(adata_ref.shape)\nadata_ref.obs\n\n(2638, 1838)\n\n\n\n\n\n\n\n\n\nn_genes\npercent_mito\nn_counts\nlouvain\nsample\n\n\nindex\n\n\n\n\n\n\n\n\n\nAAACATACAACCAC-1\n781\n0.030178\n2419.0\nCD4 T cells\npbmc3k\n\n\nAAACATTGAGCTAC-1\n1352\n0.037936\n4903.0\nB cells\npbmc3k\n\n\nAAACATTGATCAGC-1\n1131\n0.008897\n3147.0\nCD4 T cells\npbmc3k\n\n\nAAACCGTGCTTCCG-1\n960\n0.017431\n2639.0\nCD14+ Monocytes\npbmc3k\n\n\nAAACCGTGTATGCG-1\n522\n0.012245\n980.0\nNK cells\npbmc3k\n\n\n...\n...\n...\n...\n...\n...\n\n\nTTTCGAACTCTCAT-1\n1155\n0.021104\n3459.0\nCD14+ Monocytes\npbmc3k\n\n\nTTTCTACTGAGGCA-1\n1227\n0.009294\n3443.0\nB cells\npbmc3k\n\n\nTTTCTACTTCCTCG-1\n622\n0.021971\n1684.0\nB cells\npbmc3k\n\n\nTTTGCATGAGAGGC-1\n454\n0.020548\n1022.0\nB cells\npbmc3k\n\n\nTTTGCATGCCTCAC-1\n724\n0.008065\n1984.0\nCD4 T cells\npbmc3k\n\n\n\n\n2638 rows × 5 columns\n\n\n\n\nsc.pl.umap(adata_ref, color='louvain')\n\n\n\n\n\n\n\n\nMake sure we have the same genes in both datset by taking the intersection\n\nprint(adata_ref.shape[1])\nprint(adata.shape[1])\nvar_names = adata_ref.var_names.intersection(adata.var_names)\nprint(len(var_names))\n\nadata_ref = adata_ref[:, var_names]\nadata = adata[:, var_names]\n\n1838\n3090\n476\n\n\nFirst we need to rerun pca and umap with the same gene set for both datasets.\n\nsc.pp.pca(adata_ref)\nsc.pp.neighbors(adata_ref)\nsc.tl.umap(adata_ref)\nsc.pl.umap(adata_ref, color='louvain')\n\n\n\n\n\n\n\n\n\nsc.pp.pca(adata)\nsc.pp.neighbors(adata)\nsc.tl.umap(adata)\nsc.pl.umap(adata, color='louvain_0.6')"
  },
  {
    "objectID": "labs/scanpy/scanpy_06_celltyping.html#integrate-with-scanorama",
    "href": "labs/scanpy/scanpy_06_celltyping.html#integrate-with-scanorama",
    "title": " Celltype prediction",
    "section": "2 Integrate with scanorama",
    "text": "2 Integrate with scanorama\n\nimport scanorama\n\n#subset the individual dataset to the same variable genes as in MNN-correct.\nalldata = dict()\nalldata['ctrl']=adata\nalldata['ref']=adata_ref\n\n#convert to list of AnnData objects\nadatas = list(alldata.values())\n\n# run scanorama.integrate\nscanorama.integrate_scanpy(adatas, dimred = 50)\n\nFound 476 genes among all datasets\n[[0.         0.96378092]\n [0.         0.        ]]\nProcessing datasets (0, 1)\n\n\n\n# add in sample info\nadata_ref.obs['sample']='pbmc3k'\n\n# create a merged scanpy object and add in the scanorama \nadata_merged = alldata['ctrl'].concatenate(alldata['ref'], batch_key='sample', batch_categories=['ctrl','pbmc3k'])\n\nembedding = np.concatenate([ad.obsm['X_scanorama'] for ad in adatas], axis=0)\nadata_merged.obsm['Scanorama'] = embedding\n\n\n#run  umap.\nsc.pp.neighbors(adata_merged, n_pcs =50, use_rep = \"Scanorama\")\nsc.tl.umap(adata_merged)\n\n\nsc.pl.umap(adata_merged, color=[\"sample\",\"louvain\"])\n\n\n\n\n\n\n\n\n\n2.1 Label transfer\nUsing the function in the Spatial tutorial at the scanpy website we will calculate normalized cosine distances between the two datasets and tranfer labels to the celltype with the highest scores.\n\nfrom sklearn.metrics.pairwise import cosine_distances\n\ndistances = 1 - cosine_distances(\n    adata_merged[adata_merged.obs['sample'] == \"pbmc3k\"].obsm[\"Scanorama\"],\n    adata_merged[adata_merged.obs['sample'] == \"ctrl\"].obsm[\"Scanorama\"],\n)\n\ndef label_transfer(dist, labels, index):\n    lab = pd.get_dummies(labels)\n    class_prob = lab.to_numpy().T @ dist\n    norm = np.linalg.norm(class_prob, 2, axis=0)\n    class_prob = class_prob / norm\n    class_prob = (class_prob.T - class_prob.min(1)) / class_prob.ptp(1)\n    # convert to df\n    cp_df = pd.DataFrame(\n        class_prob, columns=lab.columns\n    )\n    cp_df.index = index\n    # classify as max score\n    m = cp_df.idxmax(axis=1)\n    \n    return m\n\nclass_def = label_transfer(distances, adata_ref.obs.louvain, adata.obs.index)\n\n# add to obs section of the original object\nadata.obs['predicted'] = class_def\n\nsc.pl.umap(adata, color=\"predicted\")\n\n\n\n\n\n\n\n\n\n# add to merged object.\nadata_merged.obs['predicted'] = class_def.append(adata_ref.obs['louvain']).tolist()\n\nsc.pl.umap(adata_merged, color=[\"sample\",\"louvain\",'predicted'])\n#plot only ctrl cells.\nsc.pl.umap(adata_merged[adata_merged.obs['sample']=='ctrl'], color='predicted')"
  },
  {
    "objectID": "labs/scanpy/scanpy_06_celltyping.html#ingest",
    "href": "labs/scanpy/scanpy_06_celltyping.html#ingest",
    "title": " Celltype prediction",
    "section": "3 Ingest",
    "text": "3 Ingest\nAnother method for celltype prediction is Ingest, for more information, please look at https://scanpy-tutorials.readthedocs.io/en/latest/integrating-data-using-ingest.html\n\nsc.tl.ingest(adata, adata_ref, obs='louvain')\nsc.pl.umap(adata, color=['louvain','louvain_0.6'], wspace=0.5)"
  },
  {
    "objectID": "labs/scanpy/scanpy_06_celltyping.html#compare-results",
    "href": "labs/scanpy/scanpy_06_celltyping.html#compare-results",
    "title": " Celltype prediction",
    "section": "4 Compare results",
    "text": "4 Compare results\nThe predictions from ingest is stored in the column ‘louvain’ while we named the label transfer with scanorama as ‘predicted’\n\nsc.pl.umap(adata, color=['louvain','predicted'], wspace=0.5)\n\n\n\n\n\n\n\n\nAs you can see, the main celltypes are the same, but dendritic cells are mainly predicted to cluster 8 by ingest and the proportions of the different celltypes are different.\nThe only way to make sure which method you trust is to look at what genes the different celltypes express and use your biological knowledge to make decisions."
  },
  {
    "objectID": "labs/scanpy/scanpy_06_celltyping.html#gene-set-analysis",
    "href": "labs/scanpy/scanpy_06_celltyping.html#gene-set-analysis",
    "title": " Celltype prediction",
    "section": "5 Gene set analysis",
    "text": "5 Gene set analysis\nAnother way of predicting celltypes is to use the differentially expressed genes per cluster and compare to lists of known cell marker genes. This requires a list of genes that you trust and that is relevant for the tissue you are working on.\nYou can either run it with a marker list from the ontology or a list of your choice as in the example below.\n\ndf = pd.read_table('./data/cellmarker/Human_cell_markers.txt')\ndf\n\n\n\n\n\n\n\n\nspeciesType\ntissueType\nUberonOntologyID\ncancerType\ncellType\ncellName\nCellOntologyID\ncellMarker\ngeneSymbol\ngeneID\nproteinName\nproteinID\nmarkerResource\nPMID\nCompany\n\n\n\n\n0\nHuman\nKidney\nUBERON_0002113\nNormal\nNormal cell\nProximal tubular cell\nNaN\nIntestinal Alkaline Phosphatase\nALPI\n248\nPPBI\nP09923\nExperiment\n9263997\nNaN\n\n\n1\nHuman\nLiver\nUBERON_0002107\nNormal\nNormal cell\nIto cell (hepatic stellate cell)\nCL_0000632\nSynaptophysin\nSYP\n6855\nSYPH\nP08247\nExperiment\n10595912\nNaN\n\n\n2\nHuman\nEndometrium\nUBERON_0001295\nNormal\nNormal cell\nTrophoblast cell\nCL_0000351\nCEACAM1\nCEACAM1\n634\nCEAM1\nP13688\nExperiment\n10751340\nNaN\n\n\n3\nHuman\nGerm\nUBERON_0000923\nNormal\nNormal cell\nPrimordial germ cell\nCL_0000670\nVASA\nDDX4\n54514\nDDX4\nQ9NQI0\nExperiment\n10920202\nNaN\n\n\n4\nHuman\nCorneal epithelium\nUBERON_0001772\nNormal\nNormal cell\nEpithelial cell\nCL_0000066\nKLF6\nKLF6\n1316\nKLF6\nQ99612\nExperiment\n12407152\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2863\nHuman\nEmbryo\nUBERON_0000922\nNormal\nNormal cell\n1-cell stage cell (Blastomere)\nCL_0000353\nACCSL, ACVR1B, ARHGEF16, ASF1B, BCL2L10, BLCAP...\nACCSL, ACVR1B, ARHGEF16, ASF1B, BCL2L10, BLCAP...\n390110, 91, 27237, 55723, 10017, 10904, 662, 7...\n1A1L2, ACV1B, ARHGG, ASF1B, B2L10, BLCAP, SEC2...\nQ4AC99, P36896, Q5VV41, Q9NVP2, Q9HD36, P62952...\nSingle-cell sequencing\n23892778\nNaN\n\n\n2864\nHuman\nEmbryo\nUBERON_0000922\nNormal\nNormal cell\n4-cell stage cell (Blastomere)\nCL_0000353\nADPGK, AIM1, AIMP2, ARG2, ARHGAP17, ARIH1, CDC...\nADPGK, CRYBG1, AIMP2, ARG2, ARHGAP17, ARIH1, C...\n83440, 202, 7965, 384, 55114, 25820, 55536, 24...\nADPGK, CRBG1, AIMP2, ARGI2, RHG17, ARI1, CDA7L...\nQ9BRR6, Q9Y4K1, Q13155, P78540, Q68EM7, Q9Y4X5...\nSingle-cell sequencing\n23892778\nNaN\n\n\n2865\nHuman\nEmbryo\nUBERON_0000922\nNormal\nNormal cell\n8-cell stage cell (Blastomere)\nCL_0000353\nC11orf48, C19orf53, DHX9, DIABLO, EIF1AD, EIF4...\nLBHD1, C19orf53, DHX9, DIABLO, EIF1AD, EIF4G1,...\n79081, 28974, 1660, 56616, 84285, 1981, 26017,...\nLBHD1, L10K, DHX9, DBLOH, EIF1A, IF4G1, FA32A,...\nQ9BQE6, Q9UNZ5, Q08211, Q9NR28, Q8N9N8, Q04637...\nSingle-cell sequencing\n23892778\nNaN\n\n\n2866\nHuman\nEmbryo\nUBERON_0000922\nNormal\nNormal cell\nMorula cell (Blastomere)\nCL_0000360\nADCK1, AGL, AIMP1, AKAP12, ARPC3, ATP1B3, ATP5...\nADCK1, AGL, AIMP1, AKAP12, ARPC3, ATP1B3, NA, ...\n57143, 178, 9255, 9590, 10094, 483, NA, 586, 9...\nADCK1, GDE, AIMP1, AKA12, ARPC3, AT1B3, AT5F1,...\nQ86TW2, P35573, Q12904, Q02952, O15145, P54709...\nSingle-cell sequencing\n23892778\nNaN\n\n\n2867\nHuman\nBrain\nUBERON_0000955\noligodendroglioma\nCancer cell\nCancer stem cell\nNaN\nASCL1, BOC, CCND2, CD24, CHD7, EGFR, NFIB, SOX...\nASCL1, BOC, CCND2, CD24, CHD7, EGFR, NFIB, SOX...\n429, 91653, 894, 100133941, 55636, 1956, 4781,...\nASCL1, BOC, CCND2, CD24, CHD7, EGFR, NFIB, SOX...\nP50553, Q9BWV1, P30279, P25063, Q9P2D1, P00533...\nSingle-cell sequencing\n27806376\nNaN\n\n\n\n\n2868 rows × 15 columns\n\n\n\n\n# Filter for number of genes per celltype\nprint(df.shape)\n\n(2868, 15)\n\n\n\ndf['nG'] = df.geneSymbol.str.split(\",\").str.len()\n\ndf = df[df['nG'] &gt; 5]\ndf = df[df['nG'] &lt; 100]\nd = df[df['cancerType'] == \"Normal\"]\nprint(df.shape)\n\n(445, 16)\n\n\n\ndf.index = df.cellName\ngene_dict = df.geneSymbol.str.split(\",\").to_dict()\n\n# run differential expression per cluster\nsc.tl.rank_genes_groups(adata, 'louvain_0.6', method='wilcoxon', key_added = \"wilcoxon\")\n\n\n# do gene set overlap to the groups in the gene list and top 300 DEGs.\n\nimport gseapy\n\ngsea_res = dict()\npred = dict()\n\nfor cl in adata.obs['louvain_0.6'].cat.categories.tolist():\n    print(cl)\n    glist = sc.get.rank_genes_groups_df(adata, group=cl, key='wilcoxon')['names'].squeeze().str.strip().tolist()    \n    enr_res = gseapy.enrichr(gene_list=glist[:300],\n                      organism='Human',\n                      gene_sets=gene_dict,\n                      background = adata.raw.shape[1],    \n                      cutoff = 1)\n    if enr_res.results.shape[0] == 0:\n        pred[cl] = \"Unass\"\n    else:\n        enr_res.results.sort_values(by=\"P-value\",axis=0, ascending=True, inplace=True)\n        print(enr_res.results.head(2))\n        gsea_res[cl]=enr_res\n        pred[cl] = enr_res.results[\"Term\"][0]\n\n0\n    Gene_set                      Term Overlap   P-value  Adjusted P-value  \\\n1   gs_ind_0     Cancer stem-like cell     1/6  0.092243          0.201556   \n20  gs_ind_0  Spermatogonial stem cell     1/6  0.092243          0.201556   \n\n    Odds Ratio  Combined Score  Genes  \n1    14.444459       34.425848  ANPEP  \n20   14.444459       34.425848   BCL6  \n1\n   Gene_set                    Term Overlap   P-value  Adjusted P-value  \\\n2  gs_ind_0  Effector memory T cell     1/7  0.106771          0.213541   \n5  gs_ind_0                Monocyte     1/7  0.106771          0.213541   \n\n   Odds Ratio  Combined Score Genes  \n2   12.517863        28.00338  IL7R  \n5   12.517863        28.00338  CD52  \n2\n   Gene_set                      Term Overlap   P-value  Adjusted P-value  \\\n5  gs_ind_0  Parietal progenitor cell     1/7  0.106771          0.264036   \n0  gs_ind_0     CD8+ cytotoxic T cell    1/11  0.162599          0.264036   \n\n   Odds Ratio  Combined Score  Genes  \n5   12.517863       28.003380  ANXA1  \n0    8.162082       14.826179  LAMP1  \n3\n   Gene_set                    Term Overlap   P-value  Adjusted P-value  \\\n6  gs_ind_0  Effector memory T cell     1/7  0.106771          0.234106   \n8  gs_ind_0            Naive T cell     1/7  0.106771          0.234106   \n\n   Odds Ratio  Combined Score Genes  \n6   12.517863        28.00338  IL7R  \n8   12.517863        28.00338  CCR7  \n4\n   Gene_set                   Term Overlap   P-value  Adjusted P-value  \\\n0  gs_ind_0  Cancer stem-like cell     1/6  0.092243          0.186848   \n5  gs_ind_0             Macrophage     1/6  0.092243          0.186848   \n\n   Odds Ratio  Combined Score  Genes  \n0   14.444459       34.425848  ANPEP  \n5   14.444459       34.425848   AIF1  \n5\n   Gene_set              Term Overlap   P-value  Adjusted P-value  Odds Ratio  \\\n0  gs_ind_0  CD4-CD28+ T cell     1/8  0.121066          0.121066   11.044584   \n1  gs_ind_0  CD4-CD28- T cell     1/8  0.121066          0.121066   11.044584   \n\n   Combined Score Genes  \n0        23.31975  BCL2  \n1        23.31975  BCL2  \n6\n   Gene_set                             Term Overlap   P-value  \\\n2  gs_ind_0                       Macrophage     1/6  0.092243   \n3  gs_ind_0  Monocyte derived dendritic cell     1/8  0.121066   \n\n   Adjusted P-value  Odds Ratio  Combined Score  Genes  \n2          0.242132   14.444459       34.425848   AIF1  \n3          0.242132   11.044584       23.319750  ITGAX  \n7\n   Gene_set              Term Overlap   P-value  Adjusted P-value  Odds Ratio  \\\n0  gs_ind_0            B cell     1/6  0.092243          0.151332   14.444459   \n1  gs_ind_0  CD4-CD28+ T cell     1/8  0.121066          0.151332   11.044584   \n\n   Combined Score Genes  \n0       34.425848  CD19  \n1       23.319750  BCL2  \n8\n   Gene_set      Term Overlap   P-value  Adjusted P-value  Odds Ratio  \\\n4  gs_ind_0  Monocyte     1/7  0.106771          0.320312   12.517863   \n5  gs_ind_0  Myoblast     1/7  0.106771          0.320312   12.517863   \n\n   Combined Score  Genes  \n4        28.00338   CD52  \n5        28.00338  CDC20  \n\n\n\n# prediction per cluster\npred\n\n{'0': 'CD16+ dendritic cell',\n '1': 'CD4+ T cell',\n '2': 'CD8+ cytotoxic T cell',\n '3': 'Activated T cell',\n '4': 'Cancer stem-like cell',\n '5': 'CD4-CD28+ T cell',\n '6': 'Circulating fetal cell',\n '7': 'B cell',\n '8': 'Circulating fetal cell'}\n\n\n\nprediction = [pred[x] for x in adata.obs['louvain_0.6']]\nadata.obs[\"GS_overlap_pred\"] = prediction\n\nsc.pl.umap(adata, color='GS_overlap_pred')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nAs you can see, it agrees to some extent with the predictions from label transfer and ingest, but there are clear differences, which do you think looks better?"
  },
  {
    "objectID": "labs/scanpy/scanpy_06_celltyping.html#meta-session",
    "href": "labs/scanpy/scanpy_06_celltyping.html#meta-session",
    "title": " Celltype prediction",
    "section": "6 Session info",
    "text": "6 Session info\n\nsc.logging.print_versions()\n\n-----\nanndata     0.9.2\nscanpy      1.7.2\nsinfo       0.3.1\n-----\nPIL                         10.0.0\nanndata                     0.9.2\nannoy                       NA\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.1.0\nattrs                       23.1.0\nbabel                       2.12.1\nbackcall                    0.2.0\nbrotli                      1.0.9\ncertifi                     2023.07.22\ncffi                        1.16.0\ncharset_normalizer          3.2.0\ncolorama                    0.4.6\ncomm                        0.1.4\ncpuinfo                     NA\ncycler                      0.10.0\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\ndunamai                     1.18.0\nexceptiongroup              1.1.3\nexecuting                   1.2.0\nfastjsonschema              NA\nfbpca                       NA\nfqdn                        NA\nget_version                 3.5.4\ngseapy                      1.0.6\nh5py                        3.9.0\nidna                        3.4\nigraph                      0.11.2\nimportlib_resources         NA\nintervaltree                NA\nipykernel                   6.25.2\nipywidgets                  8.1.1\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.2\njoblib                      1.3.0\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.19.1\njsonschema_specifications   NA\njupyter_events              0.7.0\njupyter_server              2.7.3\njupyterlab_server           2.25.0\nkiwisolver                  1.4.5\nlegacy_api_wrap             0.0.0\nleidenalg                   0.10.1\nllvmlite                    0.40.1\nlouvain                     0.8.1\nmarkupsafe                  2.1.3\nmatplotlib                  3.6.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.9.2\nnumba                       0.57.1\nnumexpr                     2.8.4\nnumpy                       1.24.4\noverrides                   NA\npackaging                   23.1\npandas                      1.5.3\nparso                       0.8.3\npatsy                       0.5.3\npexpect                     4.8.0\npickleshare                 0.7.5\npkg_resources               NA\nplatformdirs                3.10.0\nprometheus_client           NA\nprompt_toolkit              3.0.39\npsutil                      5.9.5\nptyprocess                  0.7.0\npure_eval                   0.2.2\npycparser                   2.21\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.16.1\npynndescent                 0.5.10\npyparsing                   3.0.9\npythonjsonlogger            NA\npytz                        2023.3\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscanorama                   1.7.3\nscanpy                      1.7.2\nscipy                       1.10.1\nsend2trash                  NA\nsetuptools_scm              NA\nsinfo                       0.3.1\nsix                         1.16.0\nsklearn                     1.3.1\nsniffio                     1.3.0\nsocks                       1.7.1\nsortedcontainers            2.4.0\nstack_data                  0.6.2\nstatsmodels                 0.14.0\ntables                      3.8.0\ntexttable                   1.7.0\nthreadpoolctl               3.2.0\ntornado                     6.3.3\ntqdm                        4.65.0\ntraitlets                   5.11.2\ntyping_extensions           NA\numap                        0.5.4\nuri_template                NA\nurllib3                     2.0.4\nwcwidth                     0.2.8\nwebcolors                   1.13\nwebsocket                   1.6.4\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.1\n-----\nIPython             8.12.2\njupyter_client      8.3.1\njupyter_core        5.4.0\njupyterlab          4.0.6\nnotebook            7.0.4\n-----\nPython 3.8.18 | packaged by conda-forge | (default, Oct 10 2023, 15:44:36) [GCC 12.3.0]\nLinux-6.4.16-linuxkit-x86_64-with-glibc2.10\n11 logical CPU cores, x86_64\n-----\nSession information updated at 2023-11-10 19:21"
  },
  {
    "objectID": "labs/bioc/bioc_05_dge.html",
    "href": "labs/bioc/bioc_05_dge.html",
    "title": " Differential gene expression",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nIn this tutorial we will cover about Differetial gene expression, which comprises an extensive range of topics and methods. In single cell, differential expresison can have multiple functionalities such as of identifying marker genes for cell populations, as well as differentially regulated genes across conditions (healthy vs control). We will also exercise on how to account the batch information in your test.\nWe can first load the data from the clustering session. Moreover, we can already decide which clustering resolution to use. First let’s define using the louvain clustering to identifying differentially expressed genes.\nsuppressPackageStartupMessages({\n  library(scater)\n  library(scran)\n  #library(venn)\n  library(cowplot)\n  library(ggplot2)\n  # library(rafalib)\n  library(pheatmap)\n  library(igraph)\n  library(dplyr)\n})\n\nsce &lt;- readRDS(\"data/results/covid_qc_dr_int_cl.rds\")"
  },
  {
    "objectID": "labs/bioc/bioc_05_dge.html#meta-dge_cmg",
    "href": "labs/bioc/bioc_05_dge.html#meta-dge_cmg",
    "title": " Differential gene expression",
    "section": "1 Cell marker genes",
    "text": "1 Cell marker genes\nLet us first compute a ranking for the highly differential genes in each cluster. There are many different tests and parameters to be chosen that can be used to refine your results. When looking for marker genes, we want genes that are positivelly expressed in a cell type and possibly not expressed in the others.\n\n#Compute differentiall expression\nmarkers_genes &lt;- scran::findMarkers(\n  x = sce,\n  groups = as.character(sce$louvain_SNNk15),\n  lfc=.5,\n  pval.type = \"all\",\n  direction = \"up\"\n)\n\n#List of dataFrames with the results for each cluster\nmarkers_genes\n\n#Visualizing the expression of one\nmarkers_genes[[\"1\"]]\n\nList of length 8\nnames(8): 1 2 3 4 5 6 7 8\nDataFrame with 18121 rows and 10 columns\n                p.value          FDR summary.logFC     logFC.2     logFC.3\n              &lt;numeric&gt;    &lt;numeric&gt;     &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt;\nCD79A      2.77497e-302 5.02853e-298       3.33753     3.50589     3.49429\nMS4A1      9.99635e-243 9.05719e-239       2.34978     2.39242     2.36704\nIGHM       1.44386e-211 8.72137e-208       3.65361     3.81745     3.84194\nTNFRSF13C  3.31358e-200 1.50113e-196       2.05617     2.10380     2.03385\nLINC00926  1.37902e-160 4.99783e-157       1.87560     1.91168     1.91990\n...                 ...          ...           ...         ...         ...\nAC011043.1            1            1    0.00431173  0.00431173  0.00431173\nAC007325.4            1            1   -0.00941346 -0.00941346 -0.00357836\nAL354822.1            1            1    0.01462591  0.01462591  0.01092670\nAC233755.1            1            1    0.00406989  0.00406989  0.00406989\nAC240274.1            1            1    0.00776217  0.00988226  0.00776217\n                logFC.4     logFC.5     logFC.6     logFC.7      logFC.8\n              &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt;    &lt;numeric&gt;\nCD79A           3.33753     3.45170     3.42421     3.48315      3.48359\nMS4A1           2.37723     2.36387     2.37951     2.34978      2.38085\nIGHM            3.65361     3.81045     3.81275     3.83623      3.87014\nTNFRSF13C       2.05617     2.08974     2.08100     2.06490      2.08563\nLINC00926       1.87560     1.89477     1.91078     1.89873      1.91405\n...                 ...         ...         ...         ...          ...\nAC011043.1  0.002383834  0.00321665  0.00431173  0.00194903  0.004311732\nAC007325.4  0.000933549 -0.00514881 -0.01779150 -0.00336159 -0.001925524\nAL354822.1  0.015825367  0.01377059  0.01288129  0.01063976  0.000836352\nAC233755.1  0.004069886  0.00406989  0.00406989  0.00406989  0.004069886\nAC240274.1 -0.001620134  0.00676532  0.00682120  0.00866048  0.012727546\n\n\nWe can now select the top 25 up regulated genes for plotting.\n\n#Colect the top 25 genes for each cluster and put the into a single table\ntop25 &lt;- lapply( names(markers_genes), function(x) { temp &lt;- markers_genes[[x]][1:25, 1:2] ; temp$gene &lt;- rownames(markers_genes[[x]])[1:25] ; temp$cluster &lt;- x ; return(temp) } )\ntop25 &lt;- as_tibble(do.call(rbind, top25))\ntop25$p.value[top25$p.value==0] &lt;- 1e-300\ntop25\n\n\n\n\n\np.value\nFDR\ngene\ncluster\n\n\n\n\n0.0000000\n0.0000000\nCD79A\n1\n\n\n0.0000000\n0.0000000\nMS4A1\n1\n\n\n0.0000000\n0.0000000\nIGHM\n1\n\n\n0.0000000\n0.0000000\nTNFRSF13C\n1\n\n\n0.0000000\n0.0000000\nLINC00926\n1\n\n\n0.0000000\n0.0000000\nIGHD\n1\n\n\n0.0000000\n0.0000000\nBANK1\n1\n\n\n0.0000000\n0.0000000\nRALGPS2\n1\n\n\n0.0000000\n0.0000000\nJUND\n1\n\n\n0.0000000\n0.0000000\nCD74\n1\n\n\n0.0000000\n0.0000000\nCD22\n1\n\n\n0.0000000\n0.0000000\nCD83\n1\n\n\n0.0000000\n0.0000000\nHLA-DQB1\n1\n\n\n0.0000000\n0.0000000\nCD37\n1\n\n\n0.0000000\n0.0000000\nNFKBID\n1\n\n\n0.0000000\n0.0000000\nTCL1A\n1\n\n\n0.0000000\n0.0000000\nP2RX5\n1\n\n\n0.0000000\n0.0000000\nVPREB3\n1\n\n\n0.0000000\n0.0000000\nAFF3\n1\n\n\n0.0000000\n0.0000000\nBLK\n1\n\n\n0.0000000\n0.0000000\nCD79B\n1\n\n\n0.0000000\n0.0000000\nTCF4\n1\n\n\n0.0000000\n0.0000000\nFCER2\n1\n\n\n0.0000000\n0.0000000\nFAM129C\n1\n\n\n0.0000000\n0.0000000\nTAGAP\n1\n\n\n0.0000000\n0.0000000\nS100A8\n2\n\n\n0.0000000\n0.0000000\nS100A9\n2\n\n\n0.0000000\n0.0000000\nRETN\n2\n\n\n0.0000000\n0.0000000\nS100A12\n2\n\n\n0.0000000\n0.0000000\nHP\n2\n\n\n0.0000000\n0.0000000\nPLBD1\n2\n\n\n0.0000000\n0.0000000\nRNASE2\n2\n\n\n0.0000000\n0.0000000\nLGALS1\n2\n\n\n0.0000000\n0.0000000\nCTSD\n2\n\n\n0.0000000\n0.0000130\nSERPINB1\n2\n\n\n0.0000019\n0.0031295\nMCEMP1\n2\n\n\n0.0000095\n0.0143114\nCLU\n2\n\n\n0.0000133\n0.0185326\nGCA\n2\n\n\n0.0000184\n0.0238358\nSELL\n2\n\n\n0.0035895\n1.0000000\nIL1R2\n2\n\n\n0.0039734\n1.0000000\nPGD\n2\n\n\n0.0046663\n1.0000000\nPKM\n2\n\n\n0.0078729\n1.0000000\nHMGB2\n2\n\n\n0.0341719\n1.0000000\nH2AFJ\n2\n\n\n0.0425308\n1.0000000\nRFLNB\n2\n\n\n0.0637210\n1.0000000\nALOX5AP\n2\n\n\n0.0771007\n1.0000000\nGAPDH\n2\n\n\n0.1209206\n1.0000000\nSLC2A3\n2\n\n\n0.4239973\n1.0000000\nFOLR3\n2\n\n\n0.5689754\n1.0000000\nFPR1\n2\n\n\n0.0000000\n0.0000000\nIL7R\n3\n\n\n0.0000000\n0.0000000\nLDHB\n3\n\n\n0.0000000\n0.0000000\nSARAF\n3\n\n\n0.0000000\n0.0000000\nRCAN3\n3\n\n\n0.0000000\n0.0000000\nMAL\n3\n\n\n0.0000000\n0.0000000\nPIK3IP1\n3\n\n\n0.0000000\n0.0000000\nNOSIP\n3\n\n\n0.0000000\n0.0000002\nTCF7\n3\n\n\n0.0000001\n0.0002920\nTPT1\n3\n\n\n0.0000003\n0.0004894\nLEPROTL1\n3\n\n\n0.0006805\n1.0000000\nLEF1\n3\n\n\n0.0110294\n1.0000000\nPRKCA\n3\n\n\n0.0131640\n1.0000000\nAP3M2\n3\n\n\n0.0167191\n1.0000000\nLTB\n3\n\n\n0.0703562\n1.0000000\nRPS14\n3\n\n\n0.1026739\n1.0000000\nSERINC5\n3\n\n\n0.1180489\n1.0000000\nRPL4\n3\n\n\n0.1354960\n1.0000000\nTRABD2A\n3\n\n\n0.3279125\n1.0000000\nRPS4X\n3\n\n\n0.3933473\n1.0000000\nARHGAP15\n3\n\n\n0.4411495\n1.0000000\nIKZF1\n3\n\n\n0.5011297\n1.0000000\nAQP3\n3\n\n\n0.5790191\n1.0000000\nKLF2\n3\n\n\n0.6397415\n1.0000000\nEEF1A1\n3\n\n\n0.6397867\n1.0000000\nGIMAP7\n3\n\n\n0.0025797\n1.0000000\nPF4\n4\n\n\n0.0208670\n1.0000000\nPPBP\n4\n\n\n0.0263607\n1.0000000\nGNG11\n4\n\n\n0.0707196\n1.0000000\nOST4\n4\n\n\n0.1356108\n1.0000000\nHIST1H3H\n4\n\n\n0.1400806\n1.0000000\nTSC22D1\n4\n\n\n0.2546185\n1.0000000\nNRGN\n4\n\n\n0.2563725\n1.0000000\nMYL9\n4\n\n\n0.2631708\n1.0000000\nCAVIN2\n4\n\n\n0.3182634\n1.0000000\nCA2\n4\n\n\n0.3683659\n1.0000000\nGP9\n4\n\n\n0.3775990\n1.0000000\nHIST1H2AC\n4\n\n\n0.3892397\n1.0000000\nTAGLN2\n4\n\n\n0.4405272\n1.0000000\nTREML1\n4\n\n\n0.4465364\n1.0000000\nACRBP\n4\n\n\n0.5188172\n1.0000000\nRGS10\n4\n\n\n0.5437923\n1.0000000\nHIST1H4H\n4\n\n\n0.5558964\n1.0000000\nTUBB1\n4\n\n\n0.5760552\n1.0000000\nMTURN\n4\n\n\n0.5914217\n1.0000000\nPARVB\n4\n\n\n0.7479470\n1.0000000\nCMTM5\n4\n\n\n0.7501645\n1.0000000\nHIST1H2BJ\n4\n\n\n0.7514531\n1.0000000\nSNCA\n4\n\n\n0.7664000\n1.0000000\nCLEC1B\n4\n\n\n0.7788011\n1.0000000\nTPM1\n4\n\n\n0.0000000\n0.0000000\nIL1B\n5\n\n\n0.0000000\n0.0000264\nSGK1\n5\n\n\n0.0000000\n0.0000361\nG0S2\n5\n\n\n0.0000205\n0.0927508\nDUSP6\n5\n\n\n0.0000295\n0.1069927\nZFP36L1\n5\n\n\n0.0000808\n0.2440944\nLGALS2\n5\n\n\n0.0012316\n1.0000000\nMPEG1\n5\n\n\n0.0013093\n1.0000000\nIER3\n5\n\n\n0.0020201\n1.0000000\nICAM1\n5\n\n\n0.0026224\n1.0000000\nSOD2\n5\n\n\n0.0240125\n1.0000000\nZFP36\n5\n\n\n0.0257393\n1.0000000\nISG15\n5\n\n\n0.0916924\n1.0000000\nTNFAIP2\n5\n\n\n0.1580185\n1.0000000\nMARCKS\n5\n\n\n0.1833187\n1.0000000\nAPOBEC3A\n5\n\n\n0.1956765\n1.0000000\nIRF2BP2\n5\n\n\n0.2578054\n1.0000000\nDUSP1\n5\n\n\n0.2751841\n1.0000000\nCSF3R\n5\n\n\n0.3344057\n1.0000000\nCCR1\n5\n\n\n0.3463693\n1.0000000\nC15orf48\n5\n\n\n0.4117579\n1.0000000\nPIM3\n5\n\n\n0.5532601\n1.0000000\nPLEK\n5\n\n\n0.6154506\n1.0000000\nBACH1\n5\n\n\n0.6336881\n1.0000000\nNFKBIA\n5\n\n\n0.6394112\n1.0000000\nMAFB\n5\n\n\n0.0000000\n0.0000000\nLST1\n6\n\n\n0.0000000\n0.0000000\nCDKN1C\n6\n\n\n0.0000000\n0.0000000\nCOTL1\n6\n\n\n0.0000000\n0.0000000\nFCGR3A\n6\n\n\n0.0000000\n0.0000000\nSMIM25\n6\n\n\n0.0000000\n0.0000000\nMS4A7\n6\n\n\n0.0000000\n0.0000000\nCSF1R\n6\n\n\n0.0000000\n0.0000000\nRHOC\n6\n\n\n0.0000000\n0.0000000\nLRRC25\n6\n\n\n0.0000000\n0.0000000\nRRAS\n6\n\n\n0.0000000\n0.0000000\nAIF1\n6\n\n\n0.0000000\n0.0000000\nTCF7L2\n6\n\n\n0.0000000\n0.0000000\nDRAP1\n6\n\n\n0.0000000\n0.0000000\nPECAM1\n6\n\n\n0.0000000\n0.0000000\nCTSC\n6\n\n\n0.0000000\n0.0000000\nUNC119\n6\n\n\n0.0000000\n0.0000008\nRNASET2\n6\n\n\n0.0000000\n0.0000029\nHES4\n6\n\n\n0.0000000\n0.0000279\nSERPINA1\n6\n\n\n0.0000001\n0.0000547\nIFITM3\n6\n\n\n0.0000001\n0.0000619\nYBX1\n6\n\n\n0.0000001\n0.0000662\nMBD2\n6\n\n\n0.0000049\n0.0038506\nSLC25A5\n6\n\n\n0.0000099\n0.0074430\nSPI1\n6\n\n\n0.0000284\n0.0205789\nNAP1L1\n6\n\n\n0.0000000\n0.0000000\nCD8A\n7\n\n\n0.0000000\n0.0000000\nDUSP2\n7\n\n\n0.0000000\n0.0000000\nGZMK\n7\n\n\n0.0000000\n0.0000000\nTRGC2\n7\n\n\n0.0000000\n0.0000000\nLYAR\n7\n\n\n0.0000001\n0.0001701\nKLRG1\n7\n\n\n0.0000081\n0.0208860\nCD8B\n7\n\n\n0.0272811\n1.0000000\nCD3D\n7\n\n\n0.1113268\n1.0000000\nIL32\n7\n\n\n0.5025564\n1.0000000\nTNFAIP3\n7\n\n\n0.6329394\n1.0000000\nPIK3R1\n7\n\n\n0.7763089\n1.0000000\nCD3G\n7\n\n\n0.7834355\n1.0000000\nTUBA4A\n7\n\n\n0.9520772\n1.0000000\nSRSF7\n7\n\n\n0.9926060\n1.0000000\nCCL5\n7\n\n\n0.9996056\n1.0000000\nRPS26\n7\n\n\n0.9999532\n1.0000000\nLINC01871\n7\n\n\n0.9999742\n1.0000000\nPTPRC\n7\n\n\n0.9999993\n1.0000000\nCD2\n7\n\n\n0.9999997\n1.0000000\nCD3E\n7\n\n\n0.9999998\n1.0000000\nHSP90AA1\n7\n\n\n1.0000000\n1.0000000\nSUB1\n7\n\n\n1.0000000\n1.0000000\nSELENOK\n7\n\n\n1.0000000\n1.0000000\nCD99\n7\n\n\n1.0000000\n1.0000000\nTERF2IP\n7\n\n\n0.0000000\n0.0000000\nGNLY\n8\n\n\n0.0000000\n0.0000000\nKLRF1\n8\n\n\n0.0000000\n0.0000000\nGZMB\n8\n\n\n0.0000000\n0.0000000\nPRF1\n8\n\n\n0.0000000\n0.0000000\nSPON2\n8\n\n\n0.0000000\n0.0000000\nCD247\n8\n\n\n0.0000000\n0.0000000\nFGFBP2\n8\n\n\n0.0000000\n0.0000000\nCLIC3\n8\n\n\n0.0000000\n0.0000000\nTRDC\n8\n\n\n0.0000000\n0.0000000\nKLRD1\n8\n\n\n0.0000000\n0.0000000\nCTSW\n8\n\n\n0.0000000\n0.0000000\nMYOM2\n8\n\n\n0.0000000\n0.0000000\nNKG7\n8\n\n\n0.0000000\n0.0000062\nCD7\n8\n\n\n0.0000050\n0.0060187\nKLRB1\n8\n\n\n0.0015028\n1.0000000\nHOPX\n8\n\n\n0.0017417\n1.0000000\nIL2RB\n8\n\n\n0.0138458\n1.0000000\nAPMAP\n8\n\n\n0.0329783\n1.0000000\nABHD17A\n8\n\n\n0.0666017\n1.0000000\nPTGDS\n8\n\n\n0.1370017\n1.0000000\nGNPTAB\n8\n\n\n0.1623678\n1.0000000\nCST7\n8\n\n\n0.3111476\n1.0000000\nCEP78\n8\n\n\n0.4601102\n1.0000000\nPRSS23\n8\n\n\n0.4956085\n1.0000000\nSYNGR1\n8\n\n\n\n\n\n\n\npar(mfrow = c(1, 5), mar = c(4, 6, 3, 1))\nfor (i in unique(top25$cluster)) {\n    barplot(sort(setNames(-log10(top25$p.value), top25$gene)[top25$cluster == i], F),\n        horiz = T, las = 1, main = paste0(i, \" vs. rest\"), border = \"white\", yaxs = \"i\", xlab = \"-log10FC\"\n    )\n    abline(v = c(0, -log10(0.05)), lty = c(1, 2))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can visualize them as a heatmap. Here we are selecting the top 5.\n\nas_tibble(top25) %&gt;% group_by(cluster)  %&gt;% top_n(-5, p.value) -&gt; top5\n\nscater::plotHeatmap(sce[, order(sce$louvain_SNNk15)],\n    features = unique(top5$gene),\n    center = T, zlim = c(-3, 3),\n    colour_columns_by = \"louvain_SNNk15\",\n    show_colnames = F, cluster_cols = F,\n    fontsize_row = 6,\n    color = colorRampPalette(c(\"purple\", \"black\", \"yellow\"))(90)\n)\n\n\n\n\n\n\n\n\nWe can also plot a violin plot for each gene.\n\nscater::plotExpression(sce, features = unique(top5$gene), x = \"louvain_SNNk15\", ncol = 5, colour_by = \"louvain_SNNk15\", scales=\"free\")"
  },
  {
    "objectID": "labs/bioc/bioc_05_dge.html#meta-dge_cond",
    "href": "labs/bioc/bioc_05_dge.html#meta-dge_cond",
    "title": " Differential gene expression",
    "section": "2 DGE across conditions",
    "text": "2 DGE across conditions\nThe second way of computing differential expression is to answer which genes are differentially expressed within a cluster. For example, in our case we have libraries comming from patients and controls and we would like to know which genes are influenced the most in a particular cell type. For this end, we will first subset our data for the desired cell cluster, then change the cell identities to the variable of comparison (which now in our case is the “type”, e.g. Covid/Ctrl).\n\n# Filter cells from that cluster\ncell_selection &lt;- sce[, sce$louvain_SNNk15 == 8]\n\n# Compute differentiall expression\nDGE_cell_selection &lt;- findMarkers(\n    x = cell_selection,\n    groups = cell_selection@colData$type,\n    lfc = .25,\n    pval.type = \"all\",\n    direction = \"any\"\n)\ntop5_cell_selection &lt;- lapply(names(DGE_cell_selection), function(x) {\n    temp &lt;- DGE_cell_selection[[x]][1:5, 1:2]\n    temp$gene &lt;- rownames(DGE_cell_selection[[x]])[1:5]\n    temp$cluster &lt;- x\n    return(temp)\n})\ntop5_cell_selection &lt;- as_tibble(do.call(rbind, top5_cell_selection))\ntop5_cell_selection\n\n\n\n\n\np.value\nFDR\ngene\ncluster\n\n\n\n\n0\n0\nXIST\nControl\n\n\n0\n0\nISG20\nControl\n\n\n0\n0\nRPS4Y1\nControl\n\n\n0\n0\nXAF1\nControl\n\n\n0\n0\nJUN\nControl\n\n\n0\n0\nXIST\nCovid\n\n\n0\n0\nISG20\nCovid\n\n\n0\n0\nRPS4Y1\nCovid\n\n\n0\n0\nXAF1\nCovid\n\n\n0\n0\nJUN\nCovid\n\n\n\n\n\n\nWe can now plot the expression across the “type”.\n\nscater::plotExpression(cell_selection, features = unique(top5_cell_selection$gene), x = \"type\", ncol = 5, colour_by = \"type\")\n\n\n\n\n\n\n\n\n#DGE_ALL6.2:\n\nplotlist &lt;- list()\nfor (i in unique(top5_cell_selection$gene)) {\n    plotlist[[i]] &lt;- plotReducedDim(sce, dimred = \"UMAP_on_MNN\", colour_by = i, by_exprs_values = \"logcounts\") +\n        ggtitle(label = i) + theme(plot.title = element_text(size = 20))\n}\nplot_grid(ncol = 3, plotlist = plotlist)"
  },
  {
    "objectID": "labs/bioc/bioc_05_dge.html#meta-dge_gsa",
    "href": "labs/bioc/bioc_05_dge.html#meta-dge_gsa",
    "title": " Differential gene expression",
    "section": "3 Gene Set Analysis (GSA)",
    "text": "3 Gene Set Analysis (GSA)\n\n3.1 Hypergeometric enrichment test\nHaving a defined list of differentially expressed genes, you can now look for their combined function using hypergeometric test.\n\n# Load additional packages\nlibrary(enrichR)\n\n# Check available databases to perform enrichment (then choose one)\nenrichR::listEnrichrDbs()\n\n# Perform enrichment\ntop_DGE &lt;- DGE_cell_selection$Covid[ (DGE_cell_selection$Covid$p.value &lt; 0.01) & (abs(DGE_cell_selection$Covid[,grep(\"logFC.C\",colnames(DGE_cell_selection$Covid))])&gt;0.25), ]\n\nenrich_results &lt;- enrichr(\n genes     = rownames(top_DGE),\n databases = \"GO_Biological_Process_2017b\" )[[1]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeneCoverage\ngenesPerTerm\nlibraryName\nlink\nnumTerms\nappyter\ncategoryId\n\n\n\n\n13362\n275\nGenome_Browser_PWMs\nhttp://hgdownload.cse.ucsc.edu/goldenPath/hg18/database/\n615\nea115789fcbf12797fd692cec6df0ab4dbc79c6a\n1\n\n\n27884\n1284\nTRANSFAC_and_JASPAR_PWMs\nhttp://jaspar.genereg.net/html/DOWNLOAD/\n326\n7d42eb43a64a4e3b20d721fc7148f685b53b6b30\n1\n\n\n6002\n77\nTranscription_Factor_PPIs\n\n290\n849f222220618e2599d925b6b51868cf1dab3763\n1\n\n\n47172\n1370\nChEA_2013\nhttp://amp.pharm.mssm.edu/lib/cheadownload.jsp\n353\n7ebe772afb55b63b41b79dd8d06ea0fdd9fa2630\n7\n\n\n47107\n509\nDrug_Perturbations_from_GEO_2014\nhttp://www.ncbi.nlm.nih.gov/geo/\n701\nad270a6876534b7cb063e004289dcd4d3164f342\n7\n\n\n21493\n3713\nENCODE_TF_ChIP-seq_2014\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n498\n497787ebc418d308045efb63b8586f10c526af51\n7\n\n\n1295\n18\nBioCarta_2013\nhttps://cgap.nci.nih.gov/Pathways/BioCarta_Pathways\n249\n4a293326037a5229aedb1ad7b2867283573d8bcd\n7\n\n\n3185\n73\nReactome_2013\nhttp://www.reactome.org/download/index.html\n78\nb343994a1b68483b0122b08650201c9b313d5c66\n7\n\n\n2854\n34\nWikiPathways_2013\nhttp://www.wikipathways.org/index.php/Download_Pathways\n199\n5c307674c8b97e098f8399c92f451c0ff21cbf68\n7\n\n\n15057\n300\nDisease_Signatures_from_GEO_up_2014\nhttp://www.ncbi.nlm.nih.gov/geo/\n142\n248c4ed8ea28352795190214713c86a39fd7afab\n7\n\n\n4128\n48\nKEGG_2013\nhttp://www.kegg.jp/kegg/download/\n200\neb26f55d3904cb0ea471998b6a932a9bf65d8e50\n7\n\n\n34061\n641\nTF-LOF_Expression_from_GEO\nhttp://www.ncbi.nlm.nih.gov/geo/\n269\n\n1\n\n\n7504\n155\nTargetScan_microRNA\nhttp://www.targetscan.org/cgi-bin/targetscan/data_download.cgi?db=vert_61\n222\nf4029bf6a62c91ab29401348e51df23b8c44c90f\n7\n\n\n16399\n247\nPPI_Hub_Proteins\nhttp://amp.pharm.mssm.edu/X2K\n385\n69c0cfe07d86f230a7ef01b365abcc7f6e52f138\n2\n\n\n12753\n57\nGO_Molecular_Function_2015\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n1136\nf531ac2b6acdf7587a54b79b465a5f4aab8f00f9\n7\n\n\n23726\n127\nGeneSigDB\nhttps://pubmed.ncbi.nlm.nih.gov/22110038/\n2139\n6d655e0aa3408a7accb3311fbda9b108681a8486\n4\n\n\n32740\n85\nChromosome_Location\nhttp://software.broadinstitute.org/gsea/msigdb/index.jsp\n386\n8dab0f96078977223646ff63eb6187e0813f1433\n7\n\n\n13373\n258\nHuman_Gene_Atlas\nhttp://biogps.org/downloads/\n84\n0741451470203d7c40a06274442f25f74b345c9c\n5\n\n\n19270\n388\nMouse_Gene_Atlas\nhttp://biogps.org/downloads/\n96\n31191bfadded5f96983f93b2a113cf2110ff5ddb\n5\n\n\n13236\n82\nGO_Cellular_Component_2015\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n641\ne1d004d5797cbd2363ef54b1c3b361adb68795c6\n7\n\n\n14264\n58\nGO_Biological_Process_2015\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n5192\nbf120b6e11242b1a64c80910d8e89f87e618e235\n7\n\n\n3096\n31\nHuman_Phenotype_Ontology\nhttp://www.human-phenotype-ontology.org/\n1779\n17a138b0b70aa0e143fe63c14f82afb70bc3ed0a\n3\n\n\n22288\n4368\nEpigenomics_Roadmap_HM_ChIP-seq\nhttp://www.roadmapepigenomics.org/\n383\ne1bc8a398e9b21f9675fb11bef18087eda21b1bf\n1\n\n\n4533\n37\nKEA_2013\nhttp://amp.pharm.mssm.edu/lib/keacommandline.jsp\n474\n462045609440fa1e628a75716b81a1baa5bd9145\n7\n\n\n10231\n158\nNURSA_Human_Endogenous_Complexome\nhttps://www.nursa.org/nursa/index.jsf\n1796\n7d3566b12ebc23dd23d9ca9bb97650f826377b16\n2\n\n\n2741\n5\nCORUM\nhttp://mips.helmholtz-muenchen.de/genre/proj/corum/\n1658\nd047f6ead7831b00566d5da7a3b027ed9196e104\n2\n\n\n5655\n342\nSILAC_Phosphoproteomics\nhttp://amp.pharm.mssm.edu/lib/keacommandline.jsp\n84\n54dcd9438b33301deb219866e162b0f9da7e63a0\n2\n\n\n10406\n715\nMGI_Mammalian_Phenotype_Level_3\nhttp://www.informatics.jax.org/\n71\nc3bfc90796cfca8f60cba830642a728e23a53565\n7\n\n\n10493\n200\nMGI_Mammalian_Phenotype_Level_4\nhttp://www.informatics.jax.org/\n476\n0b09a9a1aa0af4fc7ea22d34a9ae644d45864bd6\n7\n\n\n11251\n100\nOld_CMAP_up\nhttp://www.broadinstitute.org/cmap/\n6100\n9041f90cccbc18479138330228b336265e09021c\n7\n\n\n8695\n100\nOld_CMAP_down\nhttp://www.broadinstitute.org/cmap/\n6100\nebc0d905b3b3142f936d400c5f2a4ff926c81c37\n7\n\n\n1759\n25\nOMIM_Disease\nhttp://www.omim.org/downloads\n90\ncb2b92578a91e023d0498a334923ee84add34eca\n4\n\n\n2178\n89\nOMIM_Expanded\nhttp://www.omim.org/downloads\n187\n27eca242904d8e12a38cf8881395bc50d57a03e1\n4\n\n\n851\n15\nVirusMINT\nhttp://mint.bio.uniroma2.it/download.html\n85\n5abad1fc36216222b0420cadcd9be805a0dda63e\n4\n\n\n10061\n106\nMSigDB_Computational\nhttp://www.broadinstitute.org/gsea/msigdb/collections.jsp\n858\ne4cdcc7e259788fdf9b25586cce3403255637064\n4\n\n\n11250\n166\nMSigDB_Oncogenic_Signatures\nhttp://www.broadinstitute.org/gsea/msigdb/collections.jsp\n189\nc76f5319c33c4833c71db86a30d7e33cd63ff8cf\n4\n\n\n15406\n300\nDisease_Signatures_from_GEO_down_2014\nhttp://www.ncbi.nlm.nih.gov/geo/\n142\naabdf7017ae55ae75a004270924bcd336653b986\n7\n\n\n17711\n300\nVirus_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n323\n45268b7fc680d05dd9a29743c2f2b2840a7620bf\n4\n\n\n17576\n300\nVirus_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n323\n5f531580ccd168ee4acc18b02c6bdf8200e19d08\n4\n\n\n15797\n176\nCancer_Cell_Line_Encyclopedia\nhttps://portals.broadinstitute.org/ccle/home\n967\neb38dbc3fb20adafa9d6f9f0b0e36f378e75284f\n5\n\n\n12232\n343\nNCI-60_Cancer_Cell_Lines\nhttp://biogps.org/downloads/\n93\n75c81676d8d6d99d262c9660edc024b78cfb07c9\n5\n\n\n13572\n301\nTissue_Protein_Expression_from_ProteomicsDB\nhttps://www.proteomicsdb.org/\n207\n\n7\n\n\n6454\n301\nTissue_Protein_Expression_from_Human_Proteome_Map\nhttp://www.humanproteomemap.org/index.php\n30\n49351dc989f9e6ca97c55f8aca7778aa3bfb84b9\n5\n\n\n3723\n47\nHMDB_Metabolites\nhttp://www.hmdb.ca/downloads\n3906\n1905132115d22e4119bce543bdacaab074edb363\n6\n\n\n7588\n35\nPfam_InterPro_Domains\nftp://ftp.ebi.ac.uk/pub/databases/interpro/\n311\ne2b4912cfb799b70d87977808c54501544e4cdc9\n6\n\n\n7682\n78\nGO_Biological_Process_2013\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n941\n5216d1ade194ffa5a6c00f105e2b1899f64f45fe\n7\n\n\n7324\n172\nGO_Cellular_Component_2013\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n205\nfd1332a42395e0bc1dba82868b39be7983a48cc5\n7\n\n\n8469\n122\nGO_Molecular_Function_2013\nhttp://www.geneontology.org/GO.downloads.annotations.shtml\n402\n7e3e99e5aae02437f80b0697b197113ce3209ab0\n7\n\n\n13121\n305\nAllen_Brain_Atlas_up\nhttp://www.brain-map.org/\n2192\n3804715a63a308570e47aa1a7877f01147ca6202\n5\n\n\n26382\n1811\nENCODE_TF_ChIP-seq_2015\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n816\n56b6adb4dc8a2f540357ef992d6cd93dfa2907e5\n1\n\n\n29065\n2123\nENCODE_Histone_Modifications_2015\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n412\n55b56cd8cf2ff04b26a09b9f92904008b82f3a6f\n1\n\n\n280\n9\nPhosphatase_Substrates_from_DEPOD\nhttp://www.koehn.embl.de/depod/\n59\nd40701e21092b999f4720d1d2b644dd0257b6259\n2\n\n\n13877\n304\nAllen_Brain_Atlas_down\nhttp://www.brain-map.org/\n2192\nea67371adec290599ddf484ced2658cfae259304\n5\n\n\n15852\n912\nENCODE_Histone_Modifications_2013\nhttp://genome.ucsc.edu/ENCODE/downloads.html\n109\nc209ae527bc8e98e4ccd27a668d36cd2c80b35b4\n7\n\n\n4320\n129\nAchilles_fitness_increase\nhttp://www.broadinstitute.org/achilles\n216\n98366496a75f163164106e72439fb2bf2f77de4e\n4\n\n\n4271\n128\nAchilles_fitness_decrease\nhttp://www.broadinstitute.org/achilles\n216\n83a710c1ff67fd6b8af0d80fa6148c40dbd9bc64\n4\n\n\n10496\n201\nMGI_Mammalian_Phenotype_2013\nhttp://www.informatics.jax.org/\n476\na4c6e217a81a4a58ff5a1c9fc102b70beab298e9\n7\n\n\n1678\n21\nBioCarta_2015\nhttps://cgap.nci.nih.gov/Pathways/BioCarta_Pathways\n239\n70e4eb538daa7688691acfe5d9c3c19022be832b\n7\n\n\n756\n12\nHumanCyc_2015\nhttp://humancyc.org/\n125\n711f0c02b23f5e02a01207174943cfeee9d3ea9c\n7\n\n\n3800\n48\nKEGG_2015\nhttp://www.kegg.jp/kegg/download/\n179\ne80d25c56de53c704791ddfdc6ab5eec28ae7243\n7\n\n\n2541\n39\nNCI-Nature_2015\nhttp://pid.nci.nih.gov/\n209\n47edfc012bcbb368a10b717d8dca103f7814b5a4\n7\n\n\n1918\n39\nPanther_2015\nhttp://www.pantherdb.org/\n104\nab824aeeff0712bab61f372e43aebb870d1677a9\n7\n\n\n5863\n51\nWikiPathways_2015\nhttp://www.wikipathways.org/index.php/Download_Pathways\n404\n1f7eea2f339f37856522c1f1c70ec74c7b25325f\n7\n\n\n6768\n47\nReactome_2015\nhttp://www.reactome.org/download/index.html\n1389\n36e541bee015eddb8d53827579549e30fe7a3286\n7\n\n\n25651\n807\nESCAPE\nhttp://www.maayanlab.net/ESCAPE/\n315\na7acc741440264717ff77751a7e5fed723307835\n5\n\n\n19129\n1594\nHomoloGene\nhttp://www.ncbi.nlm.nih.gov/homologene\n12\n663b665b75a804ef98add689f838b68e612f0d2a\n6\n\n\n23939\n293\nDisease_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n839\n0f412e0802d76efa0374504c2c9f5e0624ff7f09\n8\n\n\n23561\n307\nDisease_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n839\n9ddc3902fb01fb9eaf1a2a7c2ff3acacbb48d37e\n8\n\n\n23877\n302\nDrug_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n906\n068623a05ecef3e4a5e0b4f8db64bb8faa3c897f\n8\n\n\n15886\n9\nGenes_Associated_with_NIH_Grants\nhttps://grants.nih.gov/grants/oer.htm\n32876\n76fc5ec6735130e287e62bae6770a3c5ee068645\n6\n\n\n24350\n299\nDrug_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n906\nc9c2155b5ac81ac496854fa61ba566dcae06cc80\n8\n\n\n3102\n25\nKEA_2015\nhttp://amp.pharm.mssm.edu/Enrichr\n428\n18a081774e6e0aaf60b1a4be7fd20afcf9e08399\n2\n\n\n31132\n298\nGene_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n2460\n53dedc29ce3100930d68e506f941ef59de05dc6b\n8\n\n\n30832\n302\nGene_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n2460\n499882af09c62dd6da545c15cb51c1dc5e234f78\n8\n\n\n48230\n1429\nChEA_2015\nhttp://amp.pharm.mssm.edu/Enrichr\n395\n712eb7b6edab04658df153605ec6079fa89fb5c7\n7\n\n\n5613\n36\ndbGaP\nhttp://www.ncbi.nlm.nih.gov/gap\n345\n010f1267055b1a1cb036e560ea525911c007a666\n4\n\n\n9559\n73\nLINCS_L1000_Chem_Pert_up\nhttps://clue.io/\n33132\n5e678b3debe8d8ea95187d0cd35c914017af5eb3\n7\n\n\n9448\n63\nLINCS_L1000_Chem_Pert_down\nhttps://clue.io/\n33132\nfedbf5e221f45ee60ebd944f92569b5eda7f2330\n7\n\n\n16725\n1443\nGTEx_Tissue_Expression_Down\nhttp://www.gtexportal.org/\n2918\n74b818bd299a9c42c1750ffe43616aa9f7929f02\n5\n\n\n19249\n1443\nGTEx_Tissue_Expression_Up\nhttp://www.gtexportal.org/\n2918\n103738763d89cae894bec9f145ac28167a90e611\n5\n\n\n15090\n282\nLigand_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n261\n1eb3c0426140340527155fd0ef67029db2a72191\n8\n\n\n16129\n292\nAging_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n286\ncd95fe1b505ba6f28cd722cfba50fdea979d3b4c\n8\n\n\n15309\n308\nAging_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n286\n74c4f0a0447777005b2a5c00c9882a56dfc62d7c\n8\n\n\n15103\n318\nLigand_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n261\n31baa39da2931ddd5f7aedf2d0bbba77d2ba7b46\n8\n\n\n15022\n290\nMCF7_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n401\n555f68aef0a29a67b614a0d7e20b6303df9069c6\n8\n\n\n15676\n310\nMCF7_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n401\n1bc2ba607f1ff0dda44e2a15f32a2c04767da18c\n8\n\n\n15854\n279\nMicrobe_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n312\n9e613dba78ef7e60676b13493a9dc49ccd3c8b3f\n8\n\n\n15015\n321\nMicrobe_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n312\nd0c3e2a68e8c611c669098df2c87b530cec3e132\n8\n\n\n3788\n159\nLINCS_L1000_Ligand_Perturbations_down\nhttps://clue.io/\n96\n957846cb05ef31fc8514120516b73cc65af7980e\n7\n\n\n3357\n153\nLINCS_L1000_Ligand_Perturbations_up\nhttps://clue.io/\n96\n3bd494146c98d8189898a947f5ef5710f1b7c4b2\n7\n\n\n12668\n300\nL1000_Kinase_and_GPCR_Perturbations_down\nhttps://clue.io/\n3644\n1ccc5bce553e0c2279f8e3f4ddcfbabcf566623b\n7\n\n\n12638\n300\nL1000_Kinase_and_GPCR_Perturbations_up\nhttps://clue.io/\n3644\nb54a0d4ba525eac4055c7314ca9d9312adcb220c\n7\n\n\n8973\n64\nReactome_2016\nhttp://www.reactome.org/download/index.html\n1530\n1f54638e8f45075fb79489f0e0ef906594cb0678\n7\n\n\n7010\n87\nKEGG_2016\nhttp://www.kegg.jp/kegg/download/\n293\n43f56da7540195ba3c94eb6e34c522a699b36da9\n7\n\n\n5966\n51\nWikiPathways_2016\nhttp://www.wikipathways.org/index.php/Download_Pathways\n437\n340be98b444cad50bb974df69018fd598e23e5e1\n7\n\n\n15562\n887\nENCODE_and_ChEA_Consensus_TFs_from_ChIP-X\n\n104\n5426f7747965c23ef32cff46fabf906e2cd76bfa\n1\n\n\n17850\n300\nKinase_Perturbations_from_GEO_down\nhttp://www.ncbi.nlm.nih.gov/geo/\n285\nbb9682d78b8fc43be842455e076166fcd02cefc3\n2\n\n\n17660\n300\nKinase_Perturbations_from_GEO_up\nhttp://www.ncbi.nlm.nih.gov/geo/\n285\n78618915009cac3a0663d6f99d359e39a31b6660\n2\n\n\n1348\n19\nBioCarta_2016\nhttp://cgap.nci.nih.gov/Pathways/BioCarta_Pathways\n237\n13d9ab18921d5314a5b2b366f6142b78ab0ff6aa\n2\n\n\n934\n13\nHumanCyc_2016\nhttp://humancyc.org/\n152\nd6a502ef9b4c789ed5e73ca5a8de372796e5c72a\n2\n\n\n2541\n39\nNCI-Nature_2016\nhttp://pid.nci.nih.gov/\n209\n3c1e1f7d1a651d9aaa198e73704030716fc09431\n2\n\n\n2041\n42\nPanther_2016\nhttp://www.pantherdb.org/pathway/\n112\nca5f6abf7f75d9baae03396e84d07300bf1fd051\n2\n\n\n5209\n300\nDrugMatrix\nhttps://ntp.niehs.nih.gov/drugmatrix/\n7876\n255c3db820d612f34310f22a6985dad50e9fe1fe\n4\n\n\n49238\n1550\nChEA_2016\nhttp://amp.pharm.mssm.edu/Enrichr\n645\naf271913344aa08e6a755af1d433ef15768d749a\n7\n\n\n2243\n19\nhuMAP\nhttp://proteincomplexes.org/\n995\n249247d2f686d3eb4b9e4eb976c51159fac80a89\n2\n\n\n19586\n545\nJensen_TISSUES\nhttp://tissues.jensenlab.org/\n1842\ne8879ab9534794721614d78fe2883e9e564d7759\n3\n\n\n22440\n505\nRNA-Seq_Disease_Gene_and_Drug_Signatures_from_GEO\nhttp://www.ncbi.nlm.nih.gov/geo/\n1302\nf0752e4d7f5198f86446678966b260c530d19d78\n8\n\n\n8184\n24\nMGI_Mammalian_Phenotype_2017\nhttp://www.informatics.jax.org/\n5231\n0705e59bff98deda6e9cbe00cfcdd871c85e7d04\n7\n\n\n18329\n161\nJensen_COMPARTMENTS\nhttp://compartments.jensenlab.org/\n2283\n56ec68c32d4e83edc2ee83bea0e9f6a3829b2279\n3\n\n\n15755\n28\nJensen_DISEASES\nhttp://diseases.jensenlab.org/\n1811\n3045dff8181367c1421627bb8e4c5a32c6d67f98\n3\n\n\n10271\n22\nBioPlex_2017\nhttp://bioplex.hms.harvard.edu/\n3915\nb8620b1a9d0d271d1a2747d8cfc63589dba39991\n2\n\n\n10427\n38\nGO_Cellular_Component_2017\nhttp://www.geneontology.org/\n636\n8fed21d22dfcc3015c05b31d942fdfc851cc8e04\n7\n\n\n10601\n25\nGO_Molecular_Function_2017\nhttp://www.geneontology.org/\n972\nb4018906e0a8b4e81a1b1afc51e0a2e7655403eb\n7\n\n\n13822\n21\nGO_Biological_Process_2017\nhttp://www.geneontology.org/\n3166\nd9da4dba4a3eb84d4a28a3835c06dfbbe5811f92\n7\n\n\n8002\n143\nGO_Cellular_Component_2017b\nhttp://www.geneontology.org/\n816\necf39c41fa5bc7deb625a2b5761a708676e9db7c\n7\n\n\n10089\n45\nGO_Molecular_Function_2017b\nhttp://www.geneontology.org/\n3271\n8d8340361dd36a458f1f0a401f1a3141de1f3200\n7\n\n\n13247\n49\nGO_Biological_Process_2017b\nhttp://www.geneontology.org/\n10125\n6404c38bffc2b3732de4e3fbe417b5043009fe34\n7\n\n\n21809\n2316\nARCHS4_Tissues\nhttp://amp.pharm.mssm.edu/archs4\n108\n4126374338235650ab158ba2c61cd2e2383b70df\n5\n\n\n23601\n2395\nARCHS4_Cell-lines\nhttp://amp.pharm.mssm.edu/archs4\n125\n5496ef9c9ae9429184d0b9485c23ba468ee522a8\n5\n\n\n20883\n299\nARCHS4_IDG_Coexp\nhttp://amp.pharm.mssm.edu/archs4\n352\nce60be284fdd5a9fc6240a355421a9e12b1ee84a\n4\n\n\n19612\n299\nARCHS4_Kinases_Coexp\nhttp://amp.pharm.mssm.edu/archs4\n498\n6721c5ed97b7772e4a19fdc3f797110df0164b75\n2\n\n\n25983\n299\nARCHS4_TFs_Coexp\nhttp://amp.pharm.mssm.edu/archs4\n1724\n8a468c3ae29fa68724f744cbef018f4f3b61c5ab\n1\n\n\n19500\n137\nSysMyo_Muscle_Gene_Sets\nhttp://sys-myo.rhcloud.com/\n1135\n\n8\n\n\n14893\n128\nmiRTarBase_2017\nhttp://mirtarbase.mbc.nctu.edu.tw/\n3240\n6b7c7fe2a97b19aecbfba12d8644af6875ad99c4\n1\n\n\n17598\n1208\nTargetScan_microRNA_2017\nhttp://www.targetscan.org/\n683\n79d13fb03d2fa6403f9be45c90eeda0f6822e269\n1\n\n\n5902\n109\nEnrichr_Libraries_Most_Popular_Genes\nhttp://amp.pharm.mssm.edu/Enrichr\n121\ne9b7d8ee237d0a690bd79d970a23a9fa849901ed\n6\n\n\n12486\n299\nEnrichr_Submissions_TF-Gene_Coocurrence\nhttp://amp.pharm.mssm.edu/Enrichr\n1722\nbe2ca8ef5a8c8e17d7e7bd290e7cbfe0951396c0\n1\n\n\n1073\n100\nData_Acquisition_Method_Most_Popular_Genes\nhttp://amp.pharm.mssm.edu/Enrichr\n12\n17ce5192b9eba7d109b6d228772ea8ab222e01ef\n6\n\n\n19513\n117\nDSigDB\nhttp://tanlab.ucdenver.edu/DSigDB/DSigDBv1.0/\n4026\n287476538ab98337dbe727b3985a436feb6d192a\n4\n\n\n14433\n36\nGO_Biological_Process_2018\nhttp://www.geneontology.org/\n5103\nb5b77681c46ac58cd050e60bcd4ad5041a9ab0a9\n7\n\n\n8655\n61\nGO_Cellular_Component_2018\nhttp://www.geneontology.org/\n446\ne9ebe46188efacbe1056d82987ff1c70218fa7ae\n7\n\n\n11459\n39\nGO_Molecular_Function_2018\nhttp://www.geneontology.org/\n1151\n79ff80ae9a69dd00796e52569e41422466fa0bee\n7\n\n\n19741\n270\nTF_Perturbations_Followed_by_Expression\nhttp://www.ncbi.nlm.nih.gov/geo/\n1958\n34d08a4878c19584aaf180377f2ea96faa6a6eb1\n1\n\n\n27360\n802\nChromosome_Location_hg19\nhttp://hgdownload.cse.ucsc.edu/downloads.html\n36\nfdab39c467ba6b0fb0288df1176d7dfddd7196d5\n6\n\n\n13072\n26\nNIH_Funded_PIs_2017_Human_GeneRIF\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n5687\n859b100fac3ca774ad84450b1fbb65a78fcc6b12\n6\n\n\n13464\n45\nNIH_Funded_PIs_2017_Human_AutoRIF\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n12558\nfc5bf033b932cf173633e783fc8c6228114211f8\n6\n\n\n13787\n200\nRare_Diseases_AutoRIF_ARCHS4_Predictions\nhttps://amp.pharm.mssm.edu/geneshot/\n3725\n375ff8cdd64275a916fa24707a67968a910329bb\n4\n\n\n13929\n200\nRare_Diseases_GeneRIF_ARCHS4_Predictions\nhttps://www.ncbi.nlm.nih.gov/gene/about-generif\n2244\n0f7fb7f347534779ecc6c87498e96b5460a8d652\n4\n\n\n16964\n200\nNIH_Funded_PIs_2017_AutoRIF_ARCHS4_Predictions\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n12558\nf77de51aaf0979dd6f56381cf67ba399b4640d28\n6\n\n\n17258\n200\nNIH_Funded_PIs_2017_GeneRIF_ARCHS4_Predictions\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n5684\n25fa899b715cd6a9137f6656499f89cd25144029\n6\n\n\n10352\n58\nRare_Diseases_GeneRIF_Gene_Lists\nhttps://www.ncbi.nlm.nih.gov/gene/about-generif\n2244\n0fb9ac92dbe52024661c088f71a1134f00567a8b\n4\n\n\n10471\n76\nRare_Diseases_AutoRIF_Gene_Lists\nhttps://amp.pharm.mssm.edu/geneshot/\n3725\nee3adbac2da389959410260b280e7df1fd3730df\n4\n\n\n12419\n491\nSubCell_BarCode\nhttp://www.subcellbarcode.org/\n104\nb50bb9480d8a77103fb75b331fd9dd927246939a\n2\n\n\n19378\n37\nGWAS_Catalog_2019\nhttps://www.ebi.ac.uk/gwas\n1737\nfef3864bcb5dd9e60cee27357eff30226116c49b\n7\n\n\n6201\n45\nWikiPathways_2019_Human\nhttps://www.wikipathways.org/\n472\nb0c9e9ebb9014f14561e896008087725a2db24b7\n7\n\n\n4558\n54\nWikiPathways_2019_Mouse\nhttps://www.wikipathways.org/\n176\ne7750958da20f585c8b6d5bc4451a5a4305514ba\n7\n\n\n3264\n22\nTRRUST_Transcription_Factors_2019\nhttps://www.grnpedia.org/trrust/\n571\n5f8cf93e193d2bcefa5a37ccdf0eefac576861b0\n1\n\n\n7802\n92\nKEGG_2019_Human\nhttps://www.kegg.jp/\n308\n3477bc578c4ea5d851dcb934fe2a41e9fd789bb4\n7\n\n\n8551\n98\nKEGG_2019_Mouse\nhttps://www.kegg.jp/\n303\n187eb44b2d6fa154ebf628eba1f18537f64e797c\n7\n\n\n12444\n23\nInterPro_Domains_2019\nhttps://www.ebi.ac.uk/interpro/\n1071\n18dd5ec520fdf589a93d6a7911289c205e1ddf22\n6\n\n\n9000\n20\nPfam_Domains_2019\nhttps://pfam.xfam.org/\n608\na6325ed264f9ac9e6518796076c46a1d885cca7a\n6\n\n\n7744\n363\nDepMap_WG_CRISPR_Screens_Broad_CellLines_2019\nhttps://depmap.org/\n558\n0b08b32b20854ac8a738458728a9ea50c2e04800\n7\n\n\n6204\n387\nDepMap_WG_CRISPR_Screens_Sanger_CellLines_2019\nhttps://depmap.org/\n325\nb7c4ead26d0eb64f1697c030d31682b581c8bb56\n4\n\n\n13420\n32\nMGI_Mammalian_Phenotype_Level_4_2019\nhttp://www.informatics.jax.org/\n5261\nf1bed632e89ebc054da44236c4815cdce03ef5ee\n7\n\n\n14148\n122\nUK_Biobank_GWAS_v1\nhttps://www.ukbiobank.ac.uk/tag/gwas/\n857\n958fb52e6215626673a5acf6e9289a1b84d11b4a\n4\n\n\n9813\n49\nBioPlanet_2019\nhttps://tripod.nih.gov/bioplanet/\n1510\ne110851dfc763d30946f2abedcc2cd571ac357a0\n2\n\n\n1397\n13\nClinVar_2019\nhttps://www.ncbi.nlm.nih.gov/clinvar/\n182\n0a95303f8059bec08836ecfe02ce3da951150547\n4\n\n\n9116\n22\nPheWeb_2019\nhttp://pheweb.sph.umich.edu/\n1161\n6a7c7321b6b72c5285b722f7902d26a2611117cb\n4\n\n\n17464\n63\nDisGeNET\nhttps://www.disgenet.org\n9828\n3c261626478ce9e6bf2c7f0a8014c5e901d43dc0\n4\n\n\n394\n73\nHMS_LINCS_KinomeScan\nhttp://lincs.hms.harvard.edu/kinomescan/\n148\n47ba06cdc92469ac79400fc57acd84ba343ba616\n2\n\n\n11851\n586\nCCLE_Proteomics_2020\nhttps://portals.broadinstitute.org/ccle\n378\n7094b097ae2301a1d6a5bd856a193b084cca993d\n5\n\n\n8189\n421\nProteomicsDB_2020\nhttps://www.proteomicsdb.org/\n913\n8c87c8346167bac2ba68195a32458aba9b1acfd1\n5\n\n\n18704\n100\nlncHUB_lncRNA_Co-Expression\nhttps://amp.pharm.mssm.edu/lnchub/\n3729\n45b597d7efa5693b7e4172b09c0ed2dda3305582\n1\n\n\n5605\n39\nVirus-Host_PPI_P-HIPSTer_2020\nhttp://phipster.org/\n6715\na592eed13e8e9496aedbab63003b965574e46a65\n2\n\n\n5718\n31\nElsevier_Pathway_Collection\nhttp://www.transgene.ru/disease-pathways/\n1721\n9196c760e3bcae9c9de1e3f87ad81f96bde24325\n2\n\n\n14156\n40\nTable_Mining_of_CRISPR_Studies\n\n802\nad580f3864fa8ff69eaca11f6d2e7f9b86378d08\n6\n\n\n16979\n295\nCOVID-19_Related_Gene_Sets\nhttps://amp.pharm.mssm.edu/covid19\n205\n72b0346849570f66a77a6856722601e711596cb4\n7\n\n\n4383\n146\nMSigDB_Hallmark_2020\nhttps://www.gsea-msigdb.org/gsea/msigdb/collections.jsp\n50\n6952efda94663d4bd8db09bf6eeb4e67d21ef58c\n2\n\n\n54974\n483\nEnrichr_Users_Contributed_Lists_2020\nhttps://maayanlab.cloud/Enrichr\n1482\n8dc362703b38b30ac3b68b6401a9b20a58e7d3ef\n6\n\n\n12118\n448\nTG_GATES_2020\nhttps://toxico.nibiohn.go.jp/english/\n1190\n9e32560437b11b4628b00ccf3d584360f7f7daee\n4\n\n\n12361\n124\nAllen_Brain_Atlas_10x_scRNA_2021\nhttps://portal.brain-map.org/\n766\n46f8235cb585829331799a71aec3f7c082170219\n5\n\n\n9763\n139\nDescartes_Cell_Types_and_Tissue_2021\nhttps://descartes.brotmanbaty.org/bbi/human-gene-expression-during-development/\n172\n\n5\n\n\n8078\n102\nKEGG_2021_Human\nhttps://www.kegg.jp/\n320\n\n2\n\n\n7173\n43\nWikiPathway_2021_Human\nhttps://www.wikipathways.org/\n622\n\n7\n\n\n5833\n100\nHuBMAP_ASCT_plus_B_augmented_w_RNAseq_Coexpression\nhttps://hubmapconsortium.github.io/ccf-asct-reporter/\n344\n\n5\n\n\n14937\n33\nGO_Biological_Process_2021\nhttp://www.geneontology.org/\n6036\n\n7\n\n\n11497\n80\nGO_Cellular_Component_2021\nhttp://www.geneontology.org/\n511\n\n7\n\n\n11936\n34\nGO_Molecular_Function_2021\nhttp://www.geneontology.org/\n1274\n\n7\n\n\n9767\n33\nMGI_Mammalian_Phenotype_Level_4_2021\nhttp://www.informatics.jax.org/\n4601\n\n3\n\n\n14167\n80\nCellMarker_Augmented_2021\nhttp://biocc.hrbmu.edu.cn/CellMarker/\n1097\n\n5\n\n\n17851\n102\nOrphanet_Augmented_2021\nhttp://www.orphadata.org/\n3774\n\n4\n\n\n16853\n360\nCOVID-19_Related_Gene_Sets_2021\nhttps://maayanlab.cloud/covid19/\n478\n\n4\n\n\n6654\n136\nPanglaoDB_Augmented_2021\nhttps://panglaodb.se/\n178\n\n5\n\n\n1683\n10\nAzimuth_Cell_Types_2021\nhttps://azimuth.hubmapconsortium.org/\n341\n\n5\n\n\n20414\n112\nPhenGenI_Association_2021\nhttps://www.ncbi.nlm.nih.gov/gap/phegeni\n950\n\n4\n\n\n26076\n250\nRNAseq_Automatic_GEO_Signatures_Human_Down\nhttps://maayanlab.cloud/archs4/\n4269\n\n8\n\n\n26338\n250\nRNAseq_Automatic_GEO_Signatures_Human_Up\nhttps://maayanlab.cloud/archs4/\n4269\n\n8\n\n\n25381\n250\nRNAseq_Automatic_GEO_Signatures_Mouse_Down\nhttps://maayanlab.cloud/archs4/\n4216\n\n8\n\n\n25409\n250\nRNAseq_Automatic_GEO_Signatures_Mouse_Up\nhttps://maayanlab.cloud/archs4/\n4216\n\n8\n\n\n11980\n250\nGTEx_Aging_Signatures_2021\nhttps://gtexportal.org/\n270\n\n4\n\n\n31158\n805\nHDSigDB_Human_2021\nhttps://www.hdinhd.org/\n2564\n\n4\n\n\n30006\n815\nHDSigDB_Mouse_2021\nhttps://www.hdinhd.org/\n2579\n\n4\n\n\n13370\n103\nHuBMAP_ASCTplusB_augmented_2022\nhttps://hubmapconsortium.github.io/ccf-asct-reporter/\n777\n\n5\n\n\n13697\n343\nFANTOM6_lncRNA_KD_DEGs\nhttps://fantom.gsc.riken.jp/6/\n350\n\n1\n\n\n2183\n18\nMAGMA_Drugs_and_Diseases\nhttps://github.com/nybell/drugsets/tree/main/DATA/GENESETS\n1395\n\n4\n\n\n12765\n13\nPFOCR_Pathways\nhttps://pfocr.wikipathways.org/\n17326\n\n7\n\n\n1509\n100\nTabula_Sapiens\nhttps://tabula-sapiens-portal.ds.czbiohub.org/\n469\n\n5\n\n\n18365\n1214\nChEA_2022\nhttps://maayanlab.cloud/chea3/\n757\n\n1\n\n\n13525\n175\nDiabetes_Perturbations_GEO_2022\nhttps://appyters.maayanlab.cloud/#/Gene_Expression_T2D_Signatures\n601\n\n4\n\n\n9525\n245\nLINCS_L1000_Chem_Pert_Consensus_Sigs\nhttps://maayanlab.cloud/sigcom-lincs/#/Download\n10850\n\n4\n\n\n9440\n245\nLINCS_L1000_CRISPR_KO_Consensus_Sigs\nhttps://maayanlab.cloud/sigcom-lincs/#/Download\n10424\n\n4\n\n\n3857\n80\nTabula_Muris\nhttps://tabula-muris.ds.czbiohub.org/\n106\n\n5\n\n\n10489\n61\nReactome_2022\nhttps://reactome.org/download-data\n1818\n\n2\n\n\n1198\n23\nSynGO_2022\nhttps://www.syngoportal.org/\n118\n\n3\n\n\n1882\n47\nGlyGen_Glycosylated_Proteins_2022\nhttps://www.glygen.org/\n338\n\n2\n\n\n1552\n16\nIDG_Drug_Targets_2022\nhttps://drugcentral.org/\n888\n\n4\n\n\n6713\n68\nKOMP2_Mouse_Phenotypes_2022\nhttps://www.mousephenotype.org/\n529\n\n3\n\n\n936\n15\nMetabolomics_Workbench_Metabolites_2022\nhttps://www.metabolomicsworkbench.org/\n233\n\n2\n\n\n8220\n146\nProteomics_Drug_Atlas_2023\nhttps://www.nature.com/articles/s41587-022-01539-0\n1748\n\n4\n\n\n9021\n793\nThe_Kinase_Library_2023\nhttps://kinase-library.phosphosite.org/site\n303\n\n2\n\n\n8076\n96\nGTEx_Tissues_V8_2023\nhttps://gtexportal.org/home/\n511\n\n5\n\n\n14698\n33\nGO_Biological_Process_2023\nhttp://www.geneontology.org/\n5407\n\n3\n\n\n10972\n85\nGO_Cellular_Component_2023\nhttp://www.geneontology.org/\n474\n\n3\n\n\n12126\n38\nGO_Molecular_Function_2023\nhttp://www.geneontology.org/\n1147\n\n3\n\n\n13662\n12\nPFOCR_Pathways_2023\nhttps://pfocr.wikipathways.org/\n21845\n\n2\n\n\n18290\n34\nGWAS_Catalog_2023\nhttps://www.ebi.ac.uk/gwas\n5271\n\n4\n\n\n12081\n50\nGeDiPNet_2023\nhttp://gedipnet.bicnirrh.res.in/\n2388\n\n4\n\n\n12853\n485\nMAGNET_2023\nhttps://magnet-winterlab.herokuapp.com/\n72\n\n5\n\n\n3712\n9\nAzimuth_2023\nhttps://azimuth.hubmapconsortium.org/\n1425\n\n5\n\n\n19178\n218\nRummagene_kinases\nhttps://rummagene.com/\n3810\n\n2\n\n\n19434\n369\nRummagene_signatures\nhttps://rummagene.com/\n11130\n\n8\n\n\n19379\n250\nRummagene_transcription_factors\nhttps://rummagene.com/\n7244\n\n1\n\n\n10428\n115\nMoTrPAC_2023\nhttps://motrpac-data.org/\n225\n\n5\n\n\n8044\n42\nWikiPathway_2023_Human\nhttps://www.wikipathways.org/\n801\n\n2\n\n\n9711\n414\nDepMap_CRISPR_GeneDependency_CellLines_2023\nhttps://depmap.org/\n1093\n\n4\n\n\n\n\n\n\nUploading data to Enrichr... Done.\n  Querying GO_Biological_Process_2017b... Done.\nParsing results... Done.\n\n\nSome databases of interest:\nGO_Biological_Process_2017bKEGG_2019_HumanKEGG_2019_MouseWikiPathways_2019_HumanWikiPathways_2019_Mouse\nYou visualize your results using a simple barplot, for example:\n\npar(mfrow = c(1, 1), mar = c(3, 25, 2, 1))\nbarplot(\n    height = -log10(enrich_results$P.value)[10:1],\n    names.arg = enrich_results$Term[10:1],\n    horiz = TRUE,\n    las = 1,\n    border = FALSE,\n    cex.names = .6\n)\nabline(v = c(-log10(0.05)), lty = 2)\nabline(v = 0, lty = 1)"
  },
  {
    "objectID": "labs/bioc/bioc_05_dge.html#meta-dge_gsea",
    "href": "labs/bioc/bioc_05_dge.html#meta-dge_gsea",
    "title": " Differential gene expression",
    "section": "4 Gene Set Enrichment Analysis (GSEA)",
    "text": "4 Gene Set Enrichment Analysis (GSEA)\nBesides the enrichment using hypergeometric test, we can also perform gene set enrichment analysis (GSEA), which scores ranked genes list (usually based on fold changes) and computes permutation test to check if a particular gene set is more present in the Up-regulated genes, among the DOWN_regulated genes or not differentially regulated.\n\n# Create a gene rank based on the gene expression fold change\ngene_rank &lt;- setNames(DGE_cell_selection$Covid[, grep(\"logFC.C\", colnames(DGE_cell_selection$Covid))], casefold(rownames(DGE_cell_selection$Covid), upper = T))\n\nOnce our list of genes are sorted, we can proceed with the enrichment itself. We can use the package to get gene set from the Molecular Signature Database (MSigDB) and select KEGG pathways as an example.\n\nlibrary(msigdbr)\n\n# Download gene sets\nmsigdbgmt &lt;- msigdbr::msigdbr(\"Homo sapiens\")\nmsigdbgmt &lt;- as.data.frame(msigdbgmt)\n\n# List available gene sets\nunique(msigdbgmt$gs_subcat)\n\n# Subset which gene set you want to use.\nmsigdbgmt_subset &lt;- msigdbgmt[msigdbgmt$gs_subcat == \"CP:WIKIPATHWAYS\", ]\ngmt &lt;- lapply(unique(msigdbgmt_subset$gs_name), function(x) {\n    msigdbgmt_subset[msigdbgmt_subset$gs_name == x, \"gene_symbol\"]\n})\nnames(gmt) &lt;- unique(paste0(msigdbgmt_subset$gs_name, \"_\", msigdbgmt_subset$gs_exact_source))\n\n [1] \"MIR:MIR_Legacy\"  \"TFT:TFT_Legacy\"  \"CGP\"             \"TFT:GTRD\"       \n [5] \"\"                \"VAX\"             \"CP:BIOCARTA\"     \"CGN\"            \n [9] \"GO:BP\"           \"GO:CC\"           \"IMMUNESIGDB\"     \"GO:MF\"          \n[13] \"HPO\"             \"CP:KEGG\"         \"MIR:MIRDB\"       \"CM\"             \n[17] \"CP\"              \"CP:PID\"          \"CP:REACTOME\"     \"CP:WIKIPATHWAYS\"\n\n\nNext, we will be using the GSEA. This will result in a table containing information for several pathways. We can then sort and filter those pathways to visualize only the top ones. You can select/filter them by either p-value or normalized enrichment score (NES).\n\nlibrary(fgsea)\n\n# Perform enrichemnt analysis\nfgseaRes &lt;- fgsea(pathways = gmt, stats = gene_rank, minSize = 15, maxSize = 500, nperm = 10000)\nfgseaRes &lt;- fgseaRes[order(fgseaRes$NES, decreasing = T), ]\n\n# Filter the results table to show only the top 10 UP or DOWN regulated processes (optional)\ntop10_UP &lt;- fgseaRes$pathway[1:10]\n\n# Nice summary table (shown as a plot)\ndev.off()\nplotGseaTable(gmt[top10_UP], gene_rank, fgseaRes, gseaParam = 0.5)\n\nnull device \n          1 \n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nWhich KEGG pathways are upregulated in this cluster?Which KEGG pathways are dowregulated in this cluster?\nChange the pathway source to another gene set (e.g. “CP:WIKIPATHWAYS” or “CP:REACTOME” or “CP:BIOCARTA” or “GO:BP”) and check the if you get similar results?\n\n\nFinally, lets save the integrated data for further analysis.\n\nsaveRDS(sce,\"data/results/covid_qc_dr_int_cl_dge.rds\")"
  },
  {
    "objectID": "labs/bioc/bioc_05_dge.html#meta-session",
    "href": "labs/bioc/bioc_05_dge.html#meta-session",
    "title": " Differential gene expression",
    "section": "5 Session info",
    "text": "5 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] fgsea_1.24.0                msigdbr_7.5.1              \n [3] enrichR_3.2                 dplyr_1.1.1                \n [5] igraph_1.5.0                pheatmap_1.0.12            \n [7] cowplot_1.1.1               scran_1.26.2               \n [9] scater_1.26.1               ggplot2_3.4.2              \n[11] scuttle_1.8.4               SingleCellExperiment_1.20.1\n[13] SummarizedExperiment_1.28.0 Biobase_2.58.0             \n[15] GenomicRanges_1.50.2        GenomeInfoDb_1.34.9        \n[17] IRanges_2.32.0              S4Vectors_0.36.2           \n[19] BiocGenerics_0.44.0         MatrixGenerics_1.10.0      \n[21] matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n [1] bitops_1.0-7              RColorBrewer_1.1-3       \n [3] httr_1.4.6                tools_4.2.3              \n [5] utf8_1.2.3                R6_2.5.1                 \n [7] irlba_2.3.5.1             vipor_0.4.5              \n [9] colorspace_2.1-0          withr_2.5.0              \n[11] tidyselect_1.2.0          gridExtra_2.3            \n[13] curl_5.0.1                compiler_4.2.3           \n[15] cli_3.6.1                 BiocNeighbors_1.16.0     \n[17] DelayedArray_0.24.0       labeling_0.4.2           \n[19] scales_1.2.1              digest_0.6.33            \n[21] rmarkdown_2.21            XVector_0.38.0           \n[23] pkgconfig_2.0.3           htmltools_0.5.5          \n[25] WriteXLS_6.4.0            sparseMatrixStats_1.10.0 \n[27] fastmap_1.1.1             limma_3.54.2             \n[29] htmlwidgets_1.6.2         rlang_1.1.1              \n[31] rstudioapi_0.14           DelayedMatrixStats_1.20.0\n[33] generics_0.1.3            farver_2.1.1             \n[35] jsonlite_1.8.7            BiocParallel_1.32.6      \n[37] RCurl_1.98-1.12           magrittr_2.0.3           \n[39] BiocSingular_1.14.0       GenomeInfoDbData_1.2.9   \n[41] Matrix_1.6-0              Rcpp_1.0.10              \n[43] ggbeeswarm_0.7.2          munsell_0.5.0            \n[45] fansi_1.0.4               babelgene_22.9           \n[47] viridis_0.6.3             lifecycle_1.0.3          \n[49] yaml_2.3.7                edgeR_3.40.2             \n[51] zlibbioc_1.44.0           grid_4.2.3               \n[53] parallel_4.2.3            ggrepel_0.9.3            \n[55] dqrng_0.3.0               lattice_0.20-45          \n[57] beachmat_2.14.2           locfit_1.5-9.8           \n[59] metapod_1.6.0             knitr_1.43               \n[61] pillar_1.9.0              rjson_0.2.21             \n[63] codetools_0.2-19          ScaledMatrix_1.6.0       \n[65] fastmatch_1.1-3           glue_1.6.2               \n[67] evaluate_0.21             data.table_1.14.8        \n[69] vctrs_0.6.3               gtable_0.3.3             \n[71] xfun_0.39                 rsvd_1.0.5               \n[73] viridisLite_0.4.2         tibble_3.2.1             \n[75] beeswarm_0.4.0            cluster_2.1.4            \n[77] bluster_1.8.0             statmod_1.5.0"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html",
    "href": "labs/bioc/bioc_06_celltyping.html",
    "title": " Celltype prediction",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nCelltype prediction can either be performed on indiviudal cells where each cell gets a predicted celltype label, or on the level of clusters. All methods are based on similarity to other datasets, single cell or sorted bulk RNAseq, or uses known marker genes for each celltype.\nWe will select one sample from the Covid data, ctrl_13 and predict celltype by cell on that sample.\nSome methods will predict a celltype to each cell based on what it is most similar to even if the celltype of that cell is not included in the reference. Other methods include an uncertainty so that cells with low similarity scores will be unclassified.\nThere are multiple different methods to predict celltypes, here we will just cover a few of those.\nHere we will use a reference PBMC dataset from the scPred package which is provided as a Seurat object with counts. And we will test classification based on the scPred and scMap methods. Finally we will use gene set enrichment predict celltype based on the DEGs of each cluster."
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#meta-ct_read",
    "href": "labs/bioc/bioc_06_celltyping.html#meta-ct_read",
    "title": " Celltype prediction",
    "section": "1 Read data",
    "text": "1 Read data\nFirst, lets load required libraries\n\nsuppressPackageStartupMessages({\n  library(scater)\n  library(scran)\n  library(dplyr)\n  library(cowplot)\n  library(ggplot2)\n  library(pheatmap)\n  library(rafalib)\n  library(scPred)\n  library(scmap)\n})\n\nLet’s read in the saved Covid-19 data object from the clustering step.\n\n#load the data and select 'ctrl_13` sample\nalldata &lt;- readRDS(\"data/results/covid_qc_dr_int_cl.rds\")\n\nLet’s read in the saved Covid-19 data object from the clustering step.\n\nctrl.sce &lt;- alldata[, alldata@colData$sample == 'ctrl.13']\n\n# remove all old dimensionality reductions as they will mess up the analysis further down\nreducedDims(ctrl.sce) &lt;- NULL"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#meta-ct_ref",
    "href": "labs/bioc/bioc_06_celltyping.html#meta-ct_ref",
    "title": " Celltype prediction",
    "section": "2 Reference data",
    "text": "2 Reference data\nLoad the reference dataset with annotated labels.\n\nreference &lt;- scPred::pbmc_1\nreference\n\nAn object of class Seurat \n32838 features across 3500 samples within 1 assay \nActive assay: RNA (32838 features, 0 variable features)\n\n\nConvert to a SCE object.\n\nref.sce = Seurat::as.SingleCellExperiment(reference)\n\nRerun analysis pipeline. Run normalization, feature selection and dimensionality reduction\n\n#Normalize\nref.sce &lt;- computeSumFactors(ref.sce)\nref.sce &lt;- logNormCounts(ref.sce)\n\n#Variable genes\nvar.out &lt;- modelGeneVar(ref.sce, method=\"loess\")\nhvg.ref &lt;- getTopHVGs(var.out, n=1000)  \n\n# Dim reduction\nref.sce &lt;- runPCA(ref.sce, exprs_values = \"logcounts\",  scale = T,\n              ncomponents = 30, subset_row = hvg.ref)\nref.sce &lt;- runUMAP(ref.sce, dimred = \"PCA\")\n\n\nplotReducedDim(ref.sce,dimred = \"UMAP\",colour_by = \"cell_type\")\n\n\n\n\n\n\n\n\nRun all steps of the analysis for the ctrl sample as well. Use the clustering from the integration lab with resolution 0.5.\n\n#Normalize\nctrl.sce &lt;- computeSumFactors(ctrl.sce)\nctrl.sce &lt;- logNormCounts(ctrl.sce)\n\n#Variable genes\nvar.out &lt;- modelGeneVar(ctrl.sce, method=\"loess\")\nhvg.ctrl &lt;- getTopHVGs(var.out, n=1000)  \n\n# Dim reduction\nctrl.sce &lt;- runPCA(ctrl.sce, exprs_values = \"logcounts\",  scale = T, ncomponents = 30, subset_row = hvg.ctrl)\nctrl.sce &lt;- runUMAP(ctrl.sce, dimred = \"PCA\")\n\n\nplotReducedDim(ctrl.sce,dimred = \"UMAP\",colour_by = \"louvain_SNNk15\")"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#scmap",
    "href": "labs/bioc/bioc_06_celltyping.html#scmap",
    "title": " Celltype prediction",
    "section": "3 scMap",
    "text": "3 scMap\nThe scMap package is one method for projecting cells from a scRNA-seq experiment on to the cell-types or individual cells identified in a different experiment. It can be run on different levels, either projecting by cluster or by single cell, here we will try out both.\nFor scmap cell type labels must be stored in the cell_type1 column of the colData slots, and gene ids that are consistent across both datasets must be stored in the feature_symbol column of the rowData slots.\n\n3.1 scMap cluster\n\n# add in slot cell_type1\nref.sce@colData$cell_type1 = ref.sce@colData$cell_type\n# create a rowData slot with feature_symbol\nrd = data.frame(feature_symbol=rownames(ref.sce))\nrownames(rd) = rownames(ref.sce)\nrowData(ref.sce) = rd\n\n# same for the ctrl dataset\n# create a rowData slot with feature_symbol\nrd = data.frame(feature_symbol=rownames(ctrl.sce))\nrownames(rd) = rownames(ctrl.sce)\nrowData(ctrl.sce) = rd\n\nThen we can select variable features in both datasets.\n\n# select features\ncounts(ctrl.sce) &lt;- as.matrix(counts(ctrl.sce))\nlogcounts(ctrl.sce) &lt;- as.matrix(logcounts(ctrl.sce))\nctrl.sce &lt;- selectFeatures(ctrl.sce, suppress_plot = TRUE)\n\ncounts(ref.sce) &lt;- as.matrix(counts(ref.sce))\nlogcounts(ref.sce) &lt;- as.matrix(logcounts(ref.sce))\nref.sce &lt;- selectFeatures(ref.sce, suppress_plot = TRUE)\n\nThen we need to index the reference dataset by cluster, default is the clusters in cell_type1.\n\nref.sce &lt;- indexCluster(ref.sce)\n\nNow we project the Covid-19 dataset onto that index.\n\nproject_cluster &lt;- scmapCluster(\n  projection = ctrl.sce,\n  index_list = list(\n    ref = metadata(ref.sce)$scmap_cluster_index\n  )\n)\n\n# projected labels\ntable(project_cluster$scmap_cluster_labs)\n\n\n     B cell  CD4 T cell  CD8 T cell         cDC       cMono      ncMono \n         66         108         133          38         217         144 \n    NK cell         pDC Plasma cell  unassigned \n        256           2           3         208 \n\n\nThen add the predictions to metadata and plot UMAP.\n\n# add in predictions\nctrl.sce@colData$scmap_cluster &lt;- project_cluster$scmap_cluster_labs\n\nplotReducedDim(ctrl.sce,dimred = \"UMAP\",colour_by = \"scmap_cluster\")"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#scmap-cell",
    "href": "labs/bioc/bioc_06_celltyping.html#scmap-cell",
    "title": " Celltype prediction",
    "section": "4 scMap cell",
    "text": "4 scMap cell\nWe can instead index the refernce data based on each single cell and project our data onto the closest neighbor in that dataset.\n\nref.sce &lt;- indexCell(ref.sce)\n\nAgain we need to index the reference dataset.\n\nproject_cell &lt;- scmapCell(\n  projection = ctrl.sce,\n  index_list = list(\n    ref = metadata(ref.sce)$scmap_cell_index\n  )\n)\n\nWe now get a table with index for the 5 nearest neigbors in the reference dataset for each cell in our dataset. We will select the celltype of the closest neighbor and assign it to the data.\n\ncell_type_pred &lt;- colData(ref.sce)$cell_type1[project_cell$ref[[1]][1,]]\ntable(cell_type_pred)\n\ncell_type_pred\n     B cell  CD4 T cell  CD8 T cell         cDC       cMono      ncMono \n         99         193         282          57         199         170 \n    NK cell         pDC Plasma cell \n        173           1           1 \n\n\nThen add the predictions to metadata and plot umap.\n\n# add in predictions\nctrl.sce@colData$scmap_cell &lt;- cell_type_pred\n\nplotReducedDim(ctrl.sce,dimred = \"UMAP\",colour_by = \"scmap_cell\")\n\n\n\n\n\n\n\n\nPlot both:\n\ncowplot::plot_grid( ncol = 2,\nplotReducedDim(ctrl.sce,dimred = \"UMAP\",colour_by = \"scmap_cluster\"),\nplotReducedDim(ctrl.sce,dimred = \"UMAP\",colour_by = \"scmap_cell\")\n)"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#meta-ct_scpred",
    "href": "labs/bioc/bioc_06_celltyping.html#meta-ct_scpred",
    "title": " Celltype prediction",
    "section": "5 scPred",
    "text": "5 scPred\nscPred will train a classifier based on all principal components. First, getFeatureSpace will create a scPred object stored in the @misc slot where it extracts the PCs that best separates the different celltypes. Then trainModel will do the actual training for each celltype.\nscPred works with Seurat objects, so we will convert both objects to seurat objects. You may see a lot of warnings about renaming things, but as long as you do not see an Error, you should be fine.\n\nsuppressPackageStartupMessages(library(Seurat))\n\nreference &lt;- Seurat::as.Seurat(ref.sce)\nctrl &lt;- Seurat::as.Seurat(ctrl.sce)\n\nThe loadings matrix is lost when converted to Seurat object, and scPred needs that information. So we need to rerun PCA with Seurat and the same hvgs.\n\nVariableFeatures(reference) = hvg.ref\nreference &lt;- reference %&gt;% ScaleData(verbose=F) %&gt;% RunPCA(verbose=F)\n\nVariableFeatures(ctrl) = hvg.ctrl\nctrl &lt;- ctrl %&gt;% ScaleData(verbose=F) %&gt;% RunPCA(verbose=F)\n\n\nreference &lt;- getFeatureSpace(reference, \"cell_type\")\nreference &lt;- trainModel(reference)\n\n●  Extracting feature space for each cell type...\nDONE!\n●  Training models for each cell type...\nDONE!\n\n\nscPred will train a classifier based on all principal components. First, getFeatureSpace will create a scPred object stored in the @misc slot where it extracts the PCs that best separates the different celltypes. Then trainModel will do the actual training for each celltype.\n\nget_scpred(reference)\n\n'scPred' object\n✔  Prediction variable = cell_type \n✔  Discriminant features per cell type\n✔  Training model(s)\nSummary\n\n|Cell type   |    n| Features|Method    |   ROC|  Sens|  Spec|\n|:-----------|----:|--------:|:---------|-----:|-----:|-----:|\n|B cell      |  280|       50|svmRadial | 1.000| 1.000| 1.000|\n|CD4 T cell  | 1620|       50|svmRadial | 0.994| 0.972| 0.963|\n|CD8 T cell  |  945|       50|svmRadial | 0.973| 0.859| 0.971|\n|cDC         |   26|       50|svmRadial | 0.994| 0.727| 0.999|\n|cMono       |  212|       50|svmRadial | 1.000| 0.957| 0.997|\n|ncMono      |   79|       50|svmRadial | 1.000| 0.962| 0.999|\n|NK cell     |  312|       50|svmRadial | 0.998| 0.926| 0.995|\n|pDC         |   20|       50|svmRadial | 1.000| 0.950| 1.000|\n|Plasma cell |    6|       50|svmRadial | 1.000| 1.000| 1.000|\n\n\nYou can optimize parameters for each dataset by chaning parameters and testing different types of models, see more at: https://powellgenomicslab.github.io/scPred/articles/introduction.html. But for now, we will continue with this model. Now, lets predict celltypes on our data, where scPred will align the two datasets with Harmony and then perform classification.\n\nctrl &lt;- scPredict(ctrl, reference)\n\n●  Matching reference with new dataset...\n     ─ 1000 features present in reference loadings\n     ─ 937 features shared between reference and new dataset\n     ─ 93.7% of features in the reference are present in new dataset\n●  Aligning new data to reference...\n●  Classifying cells...\nDONE!\n\n\n\nDimPlot(ctrl, group.by = \"scpred_prediction\", label = T, repel = T) + NoAxes()\n\n\n\n\n\n\n\n\nNow plot how many cells of each celltypes can be found in each cluster.\n\nggplot(ctrl@meta.data, aes(x=louvain_SNNk15, fill = scpred_prediction)) + geom_bar() + theme_classic()\n\n\n\n\n\n\n\n\nAdd the predictions into the SCE object\n\nctrl.sce@colData$scpred_prediction = ctrl$scpred_prediction"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#meta-ct_compare",
    "href": "labs/bioc/bioc_06_celltyping.html#meta-ct_compare",
    "title": " Celltype prediction",
    "section": "6 Compare results",
    "text": "6 Compare results\nNow we will compare the output of the two methods using the convenient function in scPred crossTab that prints the overlap between two metadata slots.\n\ncrossTab(ctrl, \"scmap_cell\", \"scpred_prediction\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nB cell\nCD4 T cell\nCD8 T cell\ncDC\ncMono\nncMono\nNK cell\npDC\nPlasma cell\n\n\n\n\nB cell\n98\n4\n0\n1\n1\n0\n1\n0\n0\n\n\nCD4 T cell\n0\n153\n48\n0\n2\n1\n0\n0\n0\n\n\nCD8 T cell\n0\n27\n186\n0\n0\n2\n66\n0\n0\n\n\ncDC\n0\n0\n0\n8\n8\n5\n0\n0\n0\n\n\ncMono\n0\n0\n0\n40\n167\n63\n0\n0\n0\n\n\nncMono\n0\n0\n0\n3\n10\n91\n0\n0\n0\n\n\nNK cell\n0\n0\n27\n0\n0\n0\n92\n0\n0\n\n\npDC\n0\n0\n0\n1\n0\n0\n0\n1\n0\n\n\nPlasma cell\n1\n1\n0\n0\n0\n0\n0\n0\n0\n\n\nunassigned\n0\n8\n21\n4\n11\n8\n14\n0\n1"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#meta-ct_gsea",
    "href": "labs/bioc/bioc_06_celltyping.html#meta-ct_gsea",
    "title": " Celltype prediction",
    "section": "7 GSEA with celltype markers",
    "text": "7 GSEA with celltype markers\nAnother option, where celltype can be classified on cluster level is to use gene set enrichment among the DEGs with known markers for different celltypes. Similar to how we did functional enrichment for the DEGs in the Differential expression exercise. There are some resources for celltype gene sets that can be used. Such as CellMarker, PanglaoDB or celltype gene sets at MSigDB. We can also look at overlap between DEGs in a reference dataset and the dataset you are analysing.\n\n7.1 DEG overlap\nFirst, lets extract top DEGs for our Covid-19 dataset and the reference dataset. When we run differential expression for our dataset, we want to report as many genes as possible, hence we set the cutoffs quite lenient.\n\n# run differential expression in our dataset, using clustering at resolution 0.3\nDGE_list &lt;- scran::findMarkers(\n  x = alldata,\n  groups = as.character(alldata@colData$louvain_SNNk15),\n  pval.type = \"all\",\n  min.prop = 0\n)\n\n\n# Compute differential gene expression in reference dataset (that has cell annotation)\nref_DGE &lt;- scran::findMarkers(\n  x = ref.sce,\n  groups = as.character(ref.sce@colData$cell_type),\n  pval.type = \"all\",\n  direction = \"up\"\n)\n\n# Identify the top cell marker genes in reference dataset\n# select top 50 with hihgest foldchange among top 100 signifcant genes.\nref_list &lt;- lapply(ref_DGE, function(x){\n  x$logFC &lt;- rowSums( as.matrix( x[,grep(\"logFC\",colnames(x))] ))\n  x %&gt;% as.data.frame() %&gt;% filter(p.value &lt; 0.01) %&gt;% top_n(-100, p.value) %&gt;% top_n(50, logFC) %&gt;% rownames()\n  }\n)\n\nunlist(lapply(ref_list, length))\n\n     B cell  CD4 T cell  CD8 T cell         cDC       cMono      ncMono \n         50          50          19          17          50          50 \n    NK cell         pDC Plasma cell \n         50          50          24 \n\n\nNow we can run GSEA for the DEGs from our dataset and check for enrichment of top DEGs in the reference dataset.\n\nsuppressPackageStartupMessages(library(fgsea))\n\n# run fgsea for each of the clusters in the list\nres &lt;- lapply(DGE_list, function(x){\n  x$logFC &lt;- rowSums( as.matrix( x[,grep(\"logFC\",colnames(x))] ))\n  gene_rank &lt;- setNames(x$logFC, rownames(x))\n  fgseaRes &lt;- fgsea( pathways=ref_list, stats=gene_rank,nperm=10000)\n  return(fgseaRes)\n})\nnames(res) &lt;- names(DGE_list)\n\n# You can filter and resort the table based on ES, NES or pvalue\nres &lt;- lapply(res, function(x) {x[ x$pval &lt; 0.1 , ]} )\nres &lt;- lapply(res, function(x) {x[ x$size &gt; 2 , ]} )\nres &lt;- lapply(res, function(x) {x[order(x$NES,decreasing = T), ]} )\nres\n\n$`1`\n      pathway         pval         padj         ES       NES nMoreExtreme size\n1:     B cell 0.0002180549 0.0004906236  0.9671224  2.027869            0   47\n2: CD4 T cell 0.0002171081 0.0004906236  0.8554854  1.811810            0   50\n3:        cDC 0.0004409171 0.0007936508  0.9504864  1.699947            1   17\n4: CD8 T cell 0.0023783388 0.0030578642 -0.8975126 -1.584178           12   17\n5:      cMono 0.0007385524 0.0011078287 -0.8079345 -1.678859            3   47\n6:     ncMono 0.0001855288 0.0004906236 -0.9057011 -1.891227            0   49\n7:    NK cell 0.0001855288 0.0004906236 -0.9117784 -1.903917            0   49\n                                               leadingEdge\n1:          MS4A1,CD37,TNFRSF13C,CXCR4,BANK1,LINC00926,...\n2:                   RPS29,RPS6,RPL32,RPL13,RPL3,RPL21,...\n3: HLA-DRA,HLA-DQB1,HLA-DPB1,HLA-DRB1,HLA-DPA1,HLA-DMA,...\n4:                        CCL5,IL32,GZMH,CD3D,CD2,LYAR,...\n5:                S100A6,S100A9,LYZ,S100A8,TYROBP,FCN1,...\n6:                S100A4,FCER1G,S100A11,AIF1,LST1,PSAP,...\n7:                     ITGB2,HCST,NKG7,GNLY,MYO1F,CST7,...\n\n$`2`\n      pathway         pval         padj         ES       NES nMoreExtreme size\n1:      cMono 0.0001941371 0.0006229236  0.9365013  1.957570            0   47\n2:     ncMono 0.0061776062 0.0092664093  0.7878105  1.657365           31   49\n3:        cDC 0.0357829935 0.0460067059 -0.8070491 -1.464850          185   17\n4: CD8 T cell 0.0015390535 0.0027702963 -0.8962858 -1.626821            7   17\n5:    NK cell 0.0004147657 0.0009332227 -0.8075202 -1.750269            1   49\n6:     B cell 0.0002061431 0.0006229236 -0.8594752 -1.850404            0   47\n7: CD4 T cell 0.0002076412 0.0006229236 -0.9362440 -2.035548            0   50\n                                                leadingEdge\n1:                  S100A8,S100A9,LYZ,S100A12,RETN,VCAN,...\n2:            S100A11,S100A4,AIF1,FCER1G,SERPINA1,COTL1,...\n3: HLA-DPB1,HLA-DPA1,HLA-DRB1,HLA-DRA,HLA-DQB1,HLA-DRB5,...\n4:                         IL32,CCL5,GZMH,CD3D,CD2,LYAR,...\n5:                       GNLY,B2M,GZMA,IFITM1,CTSW,NKG7,...\n6:                    RPL23A,RPS5,CXCR4,CD52,CD37,RPS23,...\n7:                   RPL14,RPL3,RPL5,EEF1A1,RPS4X,RPS3A,...\n\n$`3`\n      pathway         pval         padj         ES       NES nMoreExtreme size\n1: CD4 T cell 0.0002186748 0.0006560245  0.9811020  2.123162            0   50\n2:     B cell 0.0401756312 0.0516543829  0.6706823  1.434983          182   47\n3:    NK cell 0.0062557498 0.0093836247 -0.7505225 -1.585061           33   49\n4:        cDC 0.0009259259 0.0016666667 -0.9152055 -1.632181            4   17\n5:        pDC 0.0009179365 0.0016666667 -0.8110679 -1.701215            4   47\n6:      cMono 0.0001835873 0.0006560245 -0.9182570 -1.926044            0   47\n7:     ncMono 0.0001839926 0.0006560245 -0.9468007 -1.999590            0   49\n                                                leadingEdge\n1:                    IL7R,LDHB,PIK3IP1,RPL3,RPS12,RPS6,...\n2:                RPS5,RPL13A,RPL23A,RPL18A,RPS23,CXCR4,...\n3:                    NKG7,GNLY,ITGB2,MYO1F,CST7,FGFBP2,...\n4: HLA-DRA,HLA-DRB1,HLA-DPA1,HLA-DPB1,HLA-DQB1,HLA-DRB5,...\n5:                      PLEK,NPC2,PLAC8,CTSB,PTPRE,IRF8,...\n6:                 S100A9,S100A8,LYZ,TYROBP,FCN1,S100A6,...\n7:                 FCER1G,PSAP,AIF1,LST1,S100A11,IFITM3,...\n\n$`4`\n      pathway         pval         padj         ES       NES nMoreExtreme size\n1:        cDC 0.0117187500 0.0175781250  0.8037416  1.724026           11   17\n2:     ncMono 0.0031529164 0.0056752496 -0.7392347 -1.370565           29   49\n3:      cMono 0.0026362965 0.0056752496 -0.7491070 -1.383005           24   47\n4:    NK cell 0.0024172359 0.0056752496 -0.7525060 -1.395170           22   49\n5:     B cell 0.0002109037 0.0009490668 -0.7927710 -1.463617            1   47\n6: CD4 T cell 0.0001049648 0.0009446835 -0.9055666 -1.681245            0   50\n                                     leadingEdge\n1: HLA-DRB5,FCER1A,HLA-DRA,CLEC10A,CD1C,ENHO,...\n2: S100A4,IFITM2,CEBPB,SAT1,S100A11,TNFRSF1B,...\n3:      JUND,S100A6,NFKBIA,TSPO,TYROBP,APLP2,...\n4:         ITGB2,IFITM1,JAK1,HCST,MYO1F,CST7,...\n5:         CD52,RPL13A,CXCR4,RPS11,FAU,RPS23,...\n6:        RPL34,RPS29,RPS14,RPL36,RPL9,RPL30,...\n\n$`5`\n      pathway         pval         padj         ES       NES nMoreExtreme size\n1:      cMono 0.0001202212 0.0005409954  0.9501012  1.770007            0   47\n2:     ncMono 0.0001191469 0.0005409954  0.9006408  1.686379            0   49\n3:        cDC 0.0048699040 0.0062613051  0.8995793  1.497282           34   17\n4: CD8 T cell 0.0003552398 0.0009322561 -0.9238924 -1.809806            0   17\n5:    NK cell 0.0006215040 0.0009322561 -0.7997848 -1.934867            0   49\n6:     B cell 0.0005938242 0.0009322561 -0.8720951 -2.090722            0   47\n7: CD4 T cell 0.0006180470 0.0009322561 -0.8995014 -2.188924            0   50\n                                               leadingEdge\n1:                  S100A8,S100A9,LYZ,FCN1,VCAN,TYROBP,...\n2:                  AIF1,S100A11,PSAP,FCER1G,FTH1,MAFB,...\n3: HLA-DRA,HLA-DRB1,HLA-DRB5,HLA-DMA,HLA-DQB1,HLA-DPA1,...\n4:                        CCL5,IL32,GZMH,CD3D,CD2,CD8A,...\n5:                     NKG7,GNLY,CST7,GZMA,CTSW,FGFBP2,...\n6:                CXCR4,RPS5,RPL23A,CD52,RPL13A,RPL18A,...\n7:                   RPL3,RPS4X,RPS3,RPS29,RPS27A,IL7R,...\n\n$`6`\n      pathway         pval        padj         ES       NES nMoreExtreme size\n1:     ncMono 0.0001128159 0.001015343  0.9740505  1.774278            0   49\n2:        cDC 0.0046161963 0.008309153  0.9060929  1.488410           34   17\n3:     B cell 0.0334190231 0.050128535 -0.5862014 -1.441363           38   47\n4: CD8 T cell 0.0004132231 0.001859504 -0.9263363 -1.882484            0   17\n5:    NK cell 0.0008787346 0.002019749 -0.8311167 -2.060202            0   49\n6: CD4 T cell 0.0008976661 0.002019749 -0.8662252 -2.158966            0   50\n                                              leadingEdge\n1:               LST1,AIF1,COTL1,FCGR3A,FCER1G,CDKN1C,...\n2: HLA-DPA1,HLA-DRA,HLA-DPB1,HLA-DRB1,HLA-DRB5,MTMR14,...\n3:          CXCR4,RPL13A,MS4A1,TNFRSF13C,BANK1,RPL23A,...\n4:                       CCL5,IL32,GZMH,CD3D,CD2,LYAR,...\n5:                    NKG7,GNLY,CST7,GZMA,CTSW,FGFBP2,...\n6:                   LDHB,RPS3,IL7R,RPL31,MGAT4A,RPL3,...\n\n$`7`\n       pathway         pval         padj         ES       NES nMoreExtreme size\n1:     NK cell 0.0001890002 0.0003820845  0.9263320  1.967027            0   49\n2:  CD4 T cell 0.0001888574 0.0003820845  0.8988217  1.914776            0   50\n3:  CD8 T cell 0.0001934236 0.0003820845  0.9677072  1.740807            0   17\n4: Plasma cell 0.0217768356 0.0279987886  0.8084773  1.532320          112   24\n5:         cDC 0.0082781457 0.0124172185 -0.8715115 -1.586495           39   17\n6:      ncMono 0.0002122692 0.0003820845 -0.9129414 -1.988074            0   49\n7:       cMono 0.0002121341 0.0003820845 -0.9290836 -2.011091            0   47\n                                            leadingEdge\n1:                    NKG7,GNLY,CST7,GZMA,CTSW,GZMM,...\n2:                 IL7R,RPS3,RPS29,RPL3,RPS4X,RPL14,...\n3:                    CCL5,IL32,GZMH,CD3D,CD8A,LYAR,...\n4:             RPL36AL,FKBP11,PPIB,PEBP1,ISG20,SUB1,...\n5: HLA-DRA,HLA-DRB5,HLA-DMA,BASP1,HLA-DQB1,HLA-DRB1,...\n6:             FCER1G,AIF1,LST1,COTL1,SERPINA1,PSAP,...\n7:            S100A9,S100A8,LYZ,TYROBP,FCN1,S100A12,...\n\n$`8`\n      pathway         pval         padj         ES       NES nMoreExtreme size\n1:    NK cell 0.0002497502 0.0007492507  0.9801350  2.120810            0   49\n2: CD8 T cell 0.0119815668 0.0154048716  0.8764760  1.599284           51   17\n3:        cDC 0.0038855528 0.0058283292 -0.8888417 -1.576866           21   17\n4: CD4 T cell 0.0014992504 0.0026986507 -0.7883983 -1.650730            8   50\n5:     B cell 0.0005033557 0.0011325503 -0.8349815 -1.730143            2   47\n6:     ncMono 0.0001667222 0.0007492507 -0.8614469 -1.799198            0   49\n7:      cMono 0.0001677852 0.0007492507 -0.8926850 -1.849709            0   47\n                                               leadingEdge\n1:                     GNLY,NKG7,FGFBP2,PRF1,CTSW,CST7,...\n2:                   CCL5,GZMH,IL32,LYAR,LINC01871,CD2,...\n3: HLA-DRA,HLA-DRB1,HLA-DPA1,HLA-DQB1,HLA-DRB5,HLA-DMA,...\n4:                 RPS13,RPS28,TMEM123,RPL22,IL7R,TPT1,...\n5:                  CD37,RPS11,RPL18A,RPL12,CD52,RPS23,...\n6:                  COTL1,AIF1,FTH1,LST1,SAT1,SERPINA1,...\n7:                  S100A9,S100A8,LYZ,FCN1,TKT,S100A12,...\n\n\nSelecing top significant overlap per cluster, we can now rename the clusters according to the predicted labels. OBS! Be aware that if you have some clusters that have non-significant p-values for all the gene sets, the cluster label will not be very reliable. Also, the gene sets you are using may not cover all the celltypes you have in your dataset and hence predictions may just be the most similar celltype. Also, some of the clusters have very similar p-values to multiple celltypes, for instance the ncMono and cMono celltypes are equally good for some clusters.\n\nnew.cluster.ids &lt;- unlist(lapply(res,function(x){as.data.frame(x)[1,1]}))\n\nalldata@colData$ref_gsea &lt;- new.cluster.ids[as.character(alldata@colData$louvain_SNNk15)]\n\ncowplot::plot_grid( ncol = 2,\n   plotReducedDim(alldata, dimred = \"UMAP\",colour_by = \"louvain_SNNk15\"),\n   plotReducedDim(alldata, dimred = \"UMAP\",colour_by = \"ref_gsea\")\n)\n\n\n\n\n\n\n\n\nCompare to results with the other celltype prediction methods in the ctrl_13 sample.\n\nctrl.sce@colData$ref_gsea = alldata@colData$ref_gsea[alldata@colData$sample == \"ctrl.13\"]\n\ncowplot::plot_grid( ncol = 3,\n  plotReducedDim(ctrl.sce, dimred = \"UMAP\",colour_by = \"ref_gsea\"),\n  plotReducedDim(ctrl.sce, dimred = \"UMAP\",colour_by = \"scmap_cell\"),          \n  plotReducedDim(ctrl.sce, dimred = \"UMAP\",colour_by = \"scpred_prediction\")\n)\n\n\n\n\n\n\n\n\n\n\n7.2 With annotated gene sets\nRead in the gene lists and do some filtering.\n\n# Load the human marker table\nmarkers &lt;- read.delim(\"data/cellmarker/Human_cell_markers.txt\")\nmarkers &lt;- markers [ markers$speciesType == \"Human\", ]\nmarkers &lt;- markers [ markers$cancerType == \"Normal\", ]\n\n#Filter by tissue (to reduce computational time and have tissue-specific classification)\n# sort(unique(markers$tissueType))\n# grep(\"blood\",unique(markers$tissueType),value = T)\n# markers &lt;- markers [ markers$tissueType %in% c(\"Blood\",\"Venous blood\",\n#                                                \"Serum\",\"Plasma\",\n#                                                \"Spleen\",\"Bone marrow\",\"Lymph node\"), ]\n\n\n# remove strange characters etc.\ncelltype_list &lt;- lapply( unique(markers$cellName) , function(x){\n  x &lt;- paste(markers$geneSymbol[markers$cellName == x],sep=\",\")\n  x &lt;- gsub(\"[[]|[]]| |-\",\",\",x)\n  x &lt;- unlist(strsplit( x , split = \",\"))\n  x &lt;- unique(x [ ! x %in% c(\"\",\"NA\",\"family\") ])\n  x &lt;- casefold(x,upper = T)\n})\nnames(celltype_list) &lt;- unique(markers$cellName)\n# celltype_list &lt;- lapply(celltype_list , function(x) {x[1:min(length(x),50)]} )\ncelltype_list &lt;- celltype_list[ unlist(lapply(celltype_list,length)) &lt; 100 ]\ncelltype_list &lt;- celltype_list[ unlist(lapply(celltype_list,length)) &gt; 5 ]\n\n\n# run fgsea for each of the clusters in the list\nres &lt;- lapply(DGE_list, function(x) {\n  x$logFC &lt;- rowSums(as.matrix(x[, grep(\"logFC\", colnames(x))]))\n  gene_rank &lt;- setNames(x$logFC, rownames(x))\n  fgseaRes &lt;- fgsea(pathways = celltype_list, stats = gene_rank, nperm = 10000)\n  return(fgseaRes)\n})\nnames(res) &lt;- names(DGE_list)\n\n# You can filter and resort the table based on ES, NES or pvalue\nres &lt;- lapply(res, function(x) {x[ x$pval &lt; 0.01 , ]} )\nres &lt;- lapply(res, function(x) {x[ x$size &gt; 5 , ]} )\nres &lt;- lapply(res, function(x) {x[order(x$NES,decreasing = T), ]} )\n\n# show top 3 for each cluster.\nlapply(res,head,3)\n\n$`1`\n                       pathway        pval       padj         ES       NES\n1:              Pyramidal cell 0.006218202 0.06876600 -0.9655354 -1.468721\n2: Endothelial progenitor cell 0.009986810 0.08163132 -0.9485362 -1.470469\n3: CD4+CD25+ regulatory T cell 0.002261164 0.04132906 -0.9774280 -1.486812\n   nMoreExtreme size              leadingEdge\n1:           32    6                CD3E,NRGN\n2:           52    7             PTPRC,PECAM1\n3:           11    6 CD3E,CD3D,PTPRC,CD3G,CD4\n\n$`2`\n                           pathway         pval       padj        ES      NES\n1:                      Neutrophil 0.0001853568 0.01358774 0.9028571 2.024600\n2:          CD1C+_B dendritic cell 0.0001923077 0.01358774 0.9249100 1.952514\n3: Monocyte derived dendritic cell 0.0033284793 0.12205927 0.9212659 1.636858\n   nMoreExtreme size                                 leadingEdge\n1:            0   80 S100A8,S100A9,S100A12,MNDA,CD14,S100A11,...\n2:            0   53     S100A8,S100A9,LYZ,S100A12,RETN,VCAN,...\n3:           15   17     S100A8,S100A9,CD14,CST3,ITGAM,SIRPA,...\n\n$`3`\n             pathway         pval        padj        ES      NES nMoreExtreme\n1: Naive CD8+ T cell 0.0002230649 0.005990886 0.8569838 2.026610            0\n2: Naive CD4+ T cell 0.0002160761 0.005990886 0.9294169 1.884957            0\n3:       CD4+ T cell 0.0002148689 0.005990886 0.9199266 1.780937            0\n   size                            leadingEdge\n1:   91 LDHB,PIK3IP1,TCF7,NPM1,NOSIP,RCAN3,...\n2:   34    IL7R,RPS5,TCF7,EEF1B2,NOSIP,MAL,...\n3:   25        IL7R,LTB,CD3E,CD3D,CD3G,CD2,...\n\n$`4`\n                 pathway        pval       padj         ES       NES\n1:         Megakaryocyte 0.003636364 0.07166366  0.7629237  1.751943\n2:   Natural killer cell 0.007063159 0.10524600 -0.6789033 -1.306277\n3: CD4+ cytotoxic T cell 0.004193087 0.07166366 -0.6877647 -1.325606\n   nMoreExtreme size                             leadingEdge\n1:            2   26       PPBP,PF4,GP9,ITGA2B,CD9,GP1BA,...\n2:           68   84    PTPRC,CD69,CD81,CD3E,FCGR3A,IL7R,...\n3:           40   86 ZEB2,EFHD2,AHNAK,LITAF,FCGR3A,RUNX3,...\n\n$`5`\n                  pathway         pval       padj        ES      NES\n1:             Neutrophil 0.0001116819 0.01107707 0.9085238 1.770352\n2: CD1C+_B dendritic cell 0.0001178412 0.01107707 0.9157192 1.726452\n3:           Stromal cell 0.0004973887 0.02761782 0.8935504 1.626026\n   nMoreExtreme size                                 leadingEdge\n1:            0   80 S100A8,S100A9,CD14,S100A11,S100A12,MNDA,...\n2:            0   53        S100A8,S100A9,LYZ,FCN1,VCAN,CD14,...\n3:            3   38         VIM,CD44,ICAM1,TIMP2,BST1,TIMP1,...\n\n$`6`\n            pathway         pval       padj        ES      NES nMoreExtreme\n1: Mesenchymal cell 0.0002208968 0.02851077 0.8265400 1.525539            1\n2:     Stromal cell 0.0011657729 0.07305510 0.8484293 1.515484            9\n3:    Hemangioblast 0.0003033060 0.02851077 0.9919091 1.476510            1\n   size                           leadingEdge\n1:   59   COTL1,S100A4,CTSC,HES4,ZEB2,VIM,...\n2:   38 PECAM1,TIMP1,VIM,CD44,TIMP2,ICAM3,...\n3:    7                           PECAM1,CD34\n\n$`7`\n                 pathway         pval        padj        ES      NES\n1: CD4+ cytotoxic T cell 0.0001835199 0.008163265 0.8645620 1.977467\n2:   Natural killer cell 0.0001840943 0.008163265 0.7739282 1.762861\n3:           CD8+ T cell 0.0001944390 0.008163265 0.9494527 1.724328\n   nMoreExtreme size                       leadingEdge\n1:            0   86 CCL5,NKG7,GZMH,GNLY,CST7,GZMA,...\n2:            0   84 NKG7,CD3D,GNLY,CD3E,GZMA,CD3G,...\n3:            0   19 NKG7,CD3D,CD3E,CD3G,CD8A,GZMK,...\n\n$`8`\n                             pathway         pval        padj        ES\n1:             CD4+ cytotoxic T cell 0.0002572016 0.009670782 0.9427851\n2: Effector CD8+ memory T (Tem) cell 0.0002560164 0.009670782 0.8938425\n3:               Natural killer cell 0.0002572016 0.009670782 0.8411684\n        NES nMoreExtreme size                           leadingEdge\n1: 2.188768            0   86   GNLY,NKG7,GZMB,CCL5,FGFBP2,PRF1,...\n2: 2.054321            0   79 GNLY,GZMB,FGFBP2,KLRD1,GZMH,SPON2,...\n3: 1.948422            0   84   GNLY,NKG7,GZMB,GZMA,CD247,KLRD1,...\n\n\n#CT_GSEA8:\n\nnew.cluster.ids &lt;- unlist(lapply(res, function(x) {\n    as.data.frame(x)[1, 1]\n}))\nalldata@colData$cellmarker_gsea &lt;- new.cluster.ids[as.character(alldata@colData$louvain_SNNk15)]\n\ncowplot::plot_grid(\n    ncol = 2,\n    plotReducedDim(alldata, dimred = \"UMAP\", colour_by = \"cellmarker_gsea\"),\n    plotReducedDim(alldata, dimred = \"UMAP\", colour_by = \"ref_gsea\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nDo you think that the methods overlap well? Where do you see the most inconsistencies?\n\n\nIn this case we do not have any ground truth, and we cannot say which method performs best. You should keep in mind, that any celltype classification method is just a prediction, and you still need to use your common sense and knowledge of the biological system to judge if the results make sense.\nFinally, lets save the data with predictions.\n\nsaveRDS(ctrl.sce,\"data/results/ctrl13_qc_dr_int_cl_celltype.rds\")"
  },
  {
    "objectID": "labs/bioc/bioc_06_celltyping.html#meta-session",
    "href": "labs/bioc/bioc_06_celltyping.html#meta-session",
    "title": " Celltype prediction",
    "section": "8 Session info",
    "text": "8 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] fgsea_1.24.0                caret_6.0-94               \n [3] lattice_0.20-45             SeuratObject_4.1.3         \n [5] Seurat_4.3.0.1              scmap_1.20.2               \n [7] scPred_1.9.2                rafalib_1.0.0              \n [9] pheatmap_1.0.12             cowplot_1.1.1              \n[11] dplyr_1.1.1                 scran_1.26.2               \n[13] scater_1.26.1               ggplot2_3.4.2              \n[15] scuttle_1.8.4               SingleCellExperiment_1.20.1\n[17] SummarizedExperiment_1.28.0 Biobase_2.58.0             \n[19] GenomicRanges_1.50.2        GenomeInfoDb_1.34.9        \n[21] IRanges_2.32.0              S4Vectors_0.36.2           \n[23] BiocGenerics_0.44.0         MatrixGenerics_1.10.0      \n[25] matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n  [1] utf8_1.2.3                spatstat.explore_3.2-1   \n  [3] reticulate_1.30           tidyselect_1.2.0         \n  [5] htmlwidgets_1.6.2         grid_4.2.3               \n  [7] BiocParallel_1.32.6       Rtsne_0.16               \n  [9] pROC_1.18.5               munsell_0.5.0            \n [11] ScaledMatrix_1.6.0        codetools_0.2-19         \n [13] ica_1.0-3                 statmod_1.5.0            \n [15] future_1.33.0             miniUI_0.1.1.1           \n [17] withr_2.5.0               spatstat.random_3.1-5    \n [19] colorspace_2.1-0          progressr_0.13.0         \n [21] knitr_1.43                rstudioapi_0.14          \n [23] ROCR_1.0-11               tensor_1.5               \n [25] listenv_0.9.0             labeling_0.4.2           \n [27] GenomeInfoDbData_1.2.9    harmony_0.1.1            \n [29] polyclip_1.10-4           farver_2.1.1             \n [31] parallelly_1.36.0         vctrs_0.6.3              \n [33] generics_0.1.3            ipred_0.9-14             \n [35] xfun_0.39                 timechange_0.2.0         \n [37] randomForest_4.7-1.1      R6_2.5.1                 \n [39] ggbeeswarm_0.7.2          rsvd_1.0.5               \n [41] locfit_1.5-9.8            bitops_1.0-7             \n [43] spatstat.utils_3.0-3      DelayedArray_0.24.0      \n [45] promises_1.2.0.1          scales_1.2.1             \n [47] nnet_7.3-18               beeswarm_0.4.0           \n [49] gtable_0.3.3              beachmat_2.14.2          \n [51] globals_0.16.2            goftest_1.2-3            \n [53] timeDate_4022.108         rlang_1.1.1              \n [55] splines_4.2.3             lazyeval_0.2.2           \n [57] ModelMetrics_1.2.2.2      spatstat.geom_3.2-1      \n [59] yaml_2.3.7                reshape2_1.4.4           \n [61] abind_1.4-5               httpuv_1.6.11            \n [63] tools_4.2.3               lava_1.7.2.1             \n [65] ellipsis_0.3.2            RColorBrewer_1.1-3       \n [67] proxy_0.4-27              ggridges_0.5.4           \n [69] Rcpp_1.0.10               plyr_1.8.8               \n [71] sparseMatrixStats_1.10.0  zlibbioc_1.44.0          \n [73] purrr_1.0.1               RCurl_1.98-1.12          \n [75] deldir_1.0-9              rpart_4.1.19             \n [77] pbapply_1.7-2             viridis_0.6.3            \n [79] zoo_1.8-12                ggrepel_0.9.3            \n [81] cluster_2.1.4             magrittr_2.0.3           \n [83] data.table_1.14.8         scattermore_1.2          \n [85] lmtest_0.9-40             RANN_2.6.1               \n [87] fitdistrplus_1.1-11       patchwork_1.1.2          \n [89] mime_0.12                 evaluate_0.21            \n [91] xtable_1.8-4              gridExtra_2.3            \n [93] compiler_4.2.3            tibble_3.2.1             \n [95] crayon_1.5.2              KernSmooth_2.23-20       \n [97] htmltools_0.5.5           later_1.3.1              \n [99] tidyr_1.3.0               lubridate_1.9.2          \n[101] MASS_7.3-58.2             Matrix_1.6-0             \n[103] cli_3.6.1                 parallel_4.2.3           \n[105] metapod_1.6.0             gower_1.0.1              \n[107] igraph_1.5.0              pkgconfig_2.0.3          \n[109] sp_2.0-0                  plotly_4.10.2            \n[111] spatstat.sparse_3.0-2     recipes_1.0.6            \n[113] foreach_1.5.2             vipor_0.4.5              \n[115] hardhat_1.3.0             dqrng_0.3.0              \n[117] XVector_0.38.0            prodlim_2023.03.31       \n[119] stringr_1.5.0             digest_0.6.33            \n[121] sctransform_0.3.5         RcppAnnoy_0.0.21         \n[123] spatstat.data_3.0-1       fastmatch_1.1-3          \n[125] rmarkdown_2.21            leiden_0.4.3             \n[127] uwot_0.1.16               edgeR_3.40.2             \n[129] DelayedMatrixStats_1.20.0 googleVis_0.7.1          \n[131] kernlab_0.9-32            shiny_1.7.4              \n[133] lifecycle_1.0.3           nlme_3.1-162             \n[135] jsonlite_1.8.7            BiocNeighbors_1.16.0     \n[137] viridisLite_0.4.2         limma_3.54.2             \n[139] fansi_1.0.4               pillar_1.9.0             \n[141] fastmap_1.1.1             httr_1.4.6               \n[143] survival_3.5-3            glue_1.6.2               \n[145] FNN_1.1.3.2               png_0.1-8                \n[147] iterators_1.0.14          bluster_1.8.0            \n[149] class_7.3-21              stringi_1.7.12           \n[151] BiocSingular_1.14.0       irlba_2.3.5.1            \n[153] e1071_1.7-13              future.apply_1.11.0"
  },
  {
    "objectID": "labs/bioc/bioc_07_spatial.html",
    "href": "labs/bioc/bioc_07_spatial.html",
    "title": " Spatial Transcriptomics",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nSpatial transcriptomic data with the Visium platform is in many ways similar to scRNAseq data. It contains UMI counts for 5-20 cells instead of single cells, but is still quite sparse in the same way as scRNAseq data is, but with the additional information about spatial location in the tissue.\nHere we will first run quality control in a similar manner to scRNAseq data, then QC filtering, dimensionality reduction, integration and clustering. Then we will use scRNAseq data from mouse cortex to run LabelTransfer to predict celltypes in the Visium spots.\nWe will use two Visium spatial transcriptomics dataset of the mouse brain (Sagittal), which are publicly available from the 10x genomics website. Note, that these dataset have already been filtered for spots that does not overlap with the tissue."
  },
  {
    "objectID": "labs/bioc/bioc_07_spatial.html#meta-st_prep",
    "href": "labs/bioc/bioc_07_spatial.html#meta-st_prep",
    "title": " Spatial Transcriptomics",
    "section": "1 Preparation",
    "text": "1 Preparation\nLoad packages\n\n# BiocManager::install('DropletUtils',update = F)\n# BiocManager::install(\"Spaniel\",update = F)\n# remotes::install_github(\"RachelQueen1/Spaniel\", ref = \"Development\" ,upgrade = F,dependencies = F)\n# remotes::install_github(\"renozao/xbioc\")\n# remotes::install_github(\"meichendong/SCDC\")\n\nlibrary(Spaniel)\nlibrary(biomaRt)\nlibrary(SingleCellExperiment)\n\nsuppressPackageStartupMessages(require(Matrix))\nsuppressPackageStartupMessages(require(dplyr))\nsuppressPackageStartupMessages(require(scran))\nsuppressPackageStartupMessages(require(SingleR))\nsuppressPackageStartupMessages(require(scater))\nsuppressPackageStartupMessages(require(ggplot2))\nsuppressPackageStartupMessages(require(patchwork))\nsuppressPackageStartupMessages(require(cowplot))\n\nLoad ST data\n\nwebpath &lt;- \"https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Brain_Sagittal_Posterior/\"\npath &lt;- \"data/visium/Posterior\"\nif (!dir.exists(path)) dir.create(path, recursive = T)\nfile_list &lt;- c(\n    \"V1_Mouse_Brain_Sagittal_Posterior_filtered_feature_bc_matrix.tar.gz\",\n    \"V1_Mouse_Brain_Sagittal_Posterior_spatial.tar.gz\"\n)\nfor (i in file_list) {\n    if (!file.exists(file.path(path, i))) {\n      cat(paste0(\"Downloading \", paste0(webpath, i), \" to \", file.path(path, i), \"\\n\"))\n      download.file(url = paste0(webpath, i), destfile = file.path(path, i))\n    }\n    cat(paste0(\"Uncompressing \", file.path(path, i), \"\\n\"))\n    system(paste0(\"tar -xvzf \", file.path(path, i), \" -C \",path))\n}\n\nwebpath &lt;- \"https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Brain_Sagittal_Anterior/\"\npath &lt;- \"data/visium/Anterior\"\nif (!dir.exists(path)) dir.create(path, recursive = T)\nfile_list &lt;- c(\n    \"V1_Mouse_Brain_Sagittal_Anterior_filtered_feature_bc_matrix.tar.gz\",\n    \"V1_Mouse_Brain_Sagittal_Anterior_spatial.tar.gz\"\n)\nfor (i in file_list) {\n    if (!file.exists(file.path(path, i))) {\n        cat(paste0(\"Downloading \", paste0(webpath, i), \" to \", file.path(path, i), \"\\n\"))\n        download.file(url = paste0(webpath, i), destfile = file.path(path, i))\n    }\n    cat(paste0(\"Uncompressing \", file.path(path, i), \"\\n\"))\n    system(paste0(\"tar -xvzf \", file.path(path, i), \" -C \", path))\n}\n\nUncompressing data/visium/Posterior/V1_Mouse_Brain_Sagittal_Posterior_filtered_feature_bc_matrix.tar.gz\nUncompressing data/visium/Posterior/V1_Mouse_Brain_Sagittal_Posterior_spatial.tar.gz\nUncompressing data/visium/Anterior/V1_Mouse_Brain_Sagittal_Anterior_filtered_feature_bc_matrix.tar.gz\nUncompressing data/visium/Anterior/V1_Mouse_Brain_Sagittal_Anterior_spatial.tar.gz\n\n\nMerge the objects into one SCE object.\n\nsce.a &lt;- Spaniel::createVisiumSCE(tenXDir=\"data/visium/Anterior\", resolution=\"Low\")\nsce.p &lt;- Spaniel::createVisiumSCE(tenXDir=\"data/visium/Posterior\", resolution=\"Low\")\nsce &lt;- cbind(sce.a, sce.p)\n\nsce$Sample &lt;- sub( \".*[/]\" , \"\" ,  sub(\"/filtered_feature_bc_matrix\" , \"\", sce$Sample ))\n\nlll &lt;- list(sce.a , sce.p)\nlll &lt;- lapply( lll, function(x) x@metadata )\nnames(lll) &lt;- c(\"Anterior\",\"Posterior\")\nsce@metadata &lt;- lll\n\nWe can further convert the gene ensembl IDs to gene names.\n\nmart &lt;- biomaRt::useMart(biomart=\"ENSEMBL_MART_ENSEMBL\", dataset=\"mmusculus_gene_ensembl\")\nannot &lt;- biomaRt::getBM(attributes = c(\"ensembl_gene_id\", \"external_gene_name\",\"gene_biotype\"), mart = mart, useCache = F)\n\ngene_names &lt;- as.character ( annot[match(rownames(sce),annot[,\"ensembl_gene_id\"]),\"external_gene_name\"] )\ngene_names[is.na(gene_names) ] &lt;- \"\"\n\nsce &lt;- sce[gene_names != \"\",]\nrownames(sce) &lt;- gene_names[gene_names != \"\"]\ndim(sce)\n\n[1] 32053  6050"
  },
  {
    "objectID": "labs/bioc/bioc_07_spatial.html#meta-st_qc",
    "href": "labs/bioc/bioc_07_spatial.html#meta-st_qc",
    "title": " Spatial Transcriptomics",
    "section": "2 Quality control",
    "text": "2 Quality control\nSimilar to scRNA-seq we use statistics on number of counts, number of features and percent mitochondria for quality control.\nNow the counts and feature counts are calculated on the Spatial assay, so they are named nCount_Spatial and nFeature_Spatial.\n\n# Mitochondrial genes\nmito_genes &lt;- rownames(sce)[grep(\"^mt-\",rownames(sce))]\n\n# Ribosomal genes\nribo_genes &lt;- rownames(sce)[grep(\"^Rp[sl]\",rownames(sce))]\n\n# Hemoglobin genes - includes all genes starting with HB except HBP.\nhb_genes &lt;- rownames(sce)[grep(\"^Hb[^(p)]\",rownames(sce))]\n\nsce &lt;- addPerCellQC(sce, flatten = T, subsets = list(mt=mito_genes, hb=hb_genes, ribo=ribo_genes))\n\nhead(colData(sce))\n\nplot_grid(plotColData(sce,y = \"detected\",x = \"Sample\",colour_by = \"Sample\"),\n          plotColData(sce,y = \"total\",x = \"Sample\",colour_by = \"Sample\"),\n          plotColData(sce,y = \"subsets_mt_percent\",x = \"Sample\",colour_by = \"Sample\"),\n          plotColData(sce,y = \"subsets_ribo_percent\",x = \"Sample\",colour_by = \"Sample\"),\n          plotColData(sce,y = \"subsets_hb_percent\",x = \"Sample\",colour_by = \"Sample\"),ncol = 3)\n\n\n\n\n\n\n\n\nDataFrame with 6 rows and 24 columns\n       Sample            Barcode   Section    Spot_Y    Spot_X   Image_Y\n  &lt;character&gt;        &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\n1    Anterior AAACAAGTATCTCCCA-1         1        50       102      7474\n2    Anterior AAACACCAATAACTGC-1         1        59        19      8552\n3    Anterior AAACAGAGCGACTCCT-1         1        14        94      3163\n4    Anterior AAACAGCTTTCAGAAG-1         1        43         9      6636\n5    Anterior AAACAGGGTCTATATT-1         1        47        13      7115\n6    Anterior AAACATGGTGAGAGGA-1         1        62         0      8912\n    Image_X   pixel_x   pixel_y       sum  detected     total       sum\n  &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt;\n1      8500   438.898   214.079     13991      4462     13991     13960\n2      2788   143.959   158.417     39797      8126     39797     39742\n3      7950   410.499   436.678     29951      6526     29951     29905\n4      2100   108.434   257.349     42333      8190     42333     42262\n5      2375   122.633   232.616     35700      8090     35700     35660\n6      1480    76.420   139.828     22148      6518     22148     22096\n   detected subsets_mt_sum subsets_mt_detected subsets_mt_percent\n  &lt;integer&gt;      &lt;numeric&gt;           &lt;integer&gt;          &lt;numeric&gt;\n1      4458           1521                  12           10.89542\n2      8116           3977                  12           10.00705\n3      6520           4265                  12           14.26183\n4      8181           2870                  12            6.79097\n5      8083           1831                  13            5.13460\n6      6509           2390                  12           10.81644\n  subsets_hb_sum subsets_hb_detected subsets_hb_percent subsets_ribo_sum\n       &lt;numeric&gt;           &lt;integer&gt;          &lt;numeric&gt;        &lt;numeric&gt;\n1             60                   4           0.429799              826\n2            831                   6           2.090987             2199\n3            111                   5           0.371175             1663\n4            117                   5           0.276844             3129\n5             73                   5           0.204711             2653\n6            134                   5           0.606445             1478\n  subsets_ribo_detected subsets_ribo_percent     total\n              &lt;integer&gt;            &lt;numeric&gt; &lt;numeric&gt;\n1                    85              5.91691     13960\n2                    89              5.53319     39742\n3                    88              5.56094     29905\n4                    88              7.40381     42262\n5                    90              7.43971     35660\n6                    84              6.68899     22096\n\n\nWe can also plot the same data onto the tissue section.\n\nsamples &lt;- c(\"Anterior\", \"Posterior\")\nto_plot &lt;- c(\"detected\",\"total\",\"subsets_mt_percent\",\"subsets_ribo_percent\",\"subsets_hb_percent\")\n\nplist &lt;- list()\nn=1\nfor(j in to_plot){\n  for(i in samples){\n    temp &lt;- sce[,sce$Sample == i]\n    temp@metadata &lt;- temp@metadata[[i]]\n    plist[[n]]&lt;-spanielPlot(object = temp,\n        plotType = \"Cluster\",\n        clusterRes=j,customTitle = j,\n        techType = \"Visium\",\n        ptSizeMax = 1,ptSizeMin = .1)\n    n&lt;-n+1\n  }\n}\n\nplot_grid(ncol=2, plotlist = plist)\n\n\n\n\n\n\n\n\nAs you can see, the spots with low number of counts/features and high mitochondrial content are mainly towards the edges of the tissue. It is quite likely that these regions are damaged tissue. You may also see regions within a tissue with low quality if you have tears or folds in your section.\nBut remember, for some tissue types, the amount of genes expressed and proportion mitochondria may also be a biological features, so bear in mind what tissue you are working on and what these features mean.\n\n2.1 Filter spots\nSelect all spots with less than 25% mitocondrial reads, less than 20% hb-reads and 500 detected genes. You must judge for yourself based on your knowledge of the tissue what are appropriate filtering criteria for your dataset.\n\nsce &lt;- sce[ , sce$detected &gt; 500 &\n              sce$subsets_mt_percent &lt; 25 &\n              sce$subsets_hb_percent &lt; 20]\ndim(sce)\n\n[1] 32053  5804\n\n\nAnd replot onto tissue section:\n\nsamples &lt;- c(\"Anterior\", \"Posterior\")\nto_plot &lt;- c(\"detected\",\"total\",\"subsets_mt_percent\",\"subsets_mt_percent\",\"subsets_hb_percent\")\n\nplist &lt;- list()\nn=1\nfor(j in to_plot){\n  for(i in samples){\n    temp &lt;- sce[,sce$Sample == i]\n    temp@metadata &lt;- temp@metadata[[i]]\n    plist[[n]]&lt;-spanielPlot(object = temp,\n        plotType = \"Cluster\",\n        clusterRes=j,customTitle = j,\n        techType = \"Visium\",\n        ptSizeMax = 1,ptSizeMin = .1)\n    n&lt;-n+1\n  }\n}\n\nplot_grid(ncol=2, plotlist = plist)\n\n\n\n\n\n\n\n\n\n\n2.2 Top expressed genes\nAs for scRNA-seq data, we will look at what the top expressed genes are.\n\nC = counts(sce)\nC@x = C@x / rep.int(colSums(C), diff(C@p))\nmost_expressed &lt;- order(Matrix::rowSums( C ),decreasing = T)[20:1]\nboxplot( as.matrix(t(C[most_expressed,])),cex=.1, las=1, xlab=\"% total count per cell\",col=scales::hue_pal()(20)[20:1],horizontal=TRUE)\n\n\n\n\n\n\n\nrm(C)\n\nAs you can see, the mitochondrial genes are among the top expressed genes. Also the lncRNA gene Bc1 (brain cytoplasmic RNA 1). Also one hemoglobin gene.\n\n\n2.3 Filter genes\nWe will remove the Bc1 gene, hemoglobin genes (blood contamination) and the mitochondrial genes.\n\ndim(sce)\n\n# Filter Bl1\nsce &lt;- sce[!grepl(\"Bc1\", rownames(sce)), ]\n\n# Filter Mitocondrial\nsce &lt;- sce[!grepl(\"^mt-\", rownames(sce)), ]\n\n# Filter Hemoglobin gene (optional if that is a problem on your data)\nsce &lt;- sce[!grepl(\"^Hb.*-\", rownames(sce)), ]\n\ndim(sce)\n\n[1] 32053  5804\n[1] 32031  5804"
  },
  {
    "objectID": "labs/bioc/bioc_07_spatial.html#meta-st_analysis",
    "href": "labs/bioc/bioc_07_spatial.html#meta-st_analysis",
    "title": " Spatial Transcriptomics",
    "section": "3 Analysis",
    "text": "3 Analysis\nWe will proceed with the data in a very similar manner to scRNA-seq data.\n\nsce &lt;- computeSumFactors(sce, sizes=c(20, 40, 60, 80))\nsce &lt;- logNormCounts(sce)\n\nNow we can plot gene expression of individual genes, the gene Hpca is a strong hippocampal marker and Ttr is a marker of the choroid plexus.\n\nsamples &lt;- c(\"Anterior\", \"Posterior\")\nto_plot &lt;- c(\"Hpca\", \"Ttr\")\n\nplist &lt;- list()\nn=1\nfor(j in to_plot){\n  for(i in samples){\n    temp &lt;- sce[,sce$Sample == i]\n    temp@metadata &lt;- temp@metadata[[i]]\n    plist[[n]]&lt;-spanielPlot(object = temp,\n        plotType = \"Gene\",\n        gene=j,\n        customTitle = j,\n        techType = \"Visium\",\n        ptSizeMax = 1,ptSizeMin = .1)\n    n&lt;-n+1\n  }\n}\n\nplot_grid(ncol=2, plotlist = plist)\n\n\n\n\n\n\n\n\n\n3.1 Dimensionality reduction and clustering\nWe can then now run dimensionality reduction and clustering using the same workflow as we use for scRNA-seq analysis.\nBut make sure you run it on the SCT assay.\n\nvar.out &lt;- modelGeneVar(sce, method=\"loess\")\nhvgs = getTopHVGs(var.out, n=2000)\nsce &lt;- runPCA(sce, exprs_values = \"logcounts\",\n              subset_row=hvgs,\n              ncomponents = 50,\n              ntop = 100,\n              scale = T)\ng &lt;- buildSNNGraph(sce,k=5,use.dimred=\"PCA\")\nsce$louvain_SNNk5 &lt;- factor( igraph::cluster_louvain(g)$membership )\nsce &lt;- runUMAP(sce,dimred = \"PCA\", n_dimred = 50,   ncomponents = 2,min_dist=0.1,spread=.3,\n               metric=\"correlation\",name = \"UMAP_on_PCA\")\n\nWe can then plot clusters onto umap or onto the tissue section.\n\nsamples &lt;- c(\"Anterior\", \"Posterior\")\nto_plot &lt;- c(\"louvain_SNNk5\")\n\nplist &lt;- list()\nn=1\nfor(j in to_plot){\n  for(i in samples){\n    temp &lt;- sce[,sce$Sample == i]\n    temp@metadata &lt;- temp@metadata[[i]]\n    plist[[n]]&lt;-spanielPlot(object = temp,\n        plotType = \"Cluster\",clusterRes = j,\n        customTitle = j,\n        techType = \"Visium\",\n        ptSizeMax = 1,ptSizeMin = .1)\n    n&lt;-n+1\n  }\n}\n\nplist[[3]] &lt;- plotReducedDim(sce, dimred = \"UMAP_on_PCA\", colour_by = \"louvain_SNNk5\")\nplist[[4]] &lt;- plotReducedDim(sce, dimred = \"UMAP_on_PCA\", colour_by = \"Sample\")\n\nplot_grid(ncol=2, plotlist = plist)\n\n\n\n\n\n\n\n\n\n\n3.2 Integration\nQuite often there are strong batch effects between different ST sections, so it may be a good idea to integrate the data across sections.\nWe will do a similar integration as in the Data Integration lab.\n\nmnn_out &lt;- batchelor::fastMNN(sce, subset.row = hvgs, batch = factor(sce$Sample), k = 20, d = 50)\n\nreducedDim(sce, \"MNN\") &lt;- reducedDim(mnn_out,\"corrected\")\nrm(mnn_out)\ngc()\n\n            used   (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  10374236  554.1   17862084  954.0  17862084  954.0\nVcells 191981577 1464.8  374059080 2853.9 374055530 2853.9\n\n\nThen we run dimensionality reduction and clustering as before.\n\ng &lt;- buildSNNGraph(sce,k=5,use.dimred=\"MNN\")\nsce$louvain_SNNk5 &lt;- factor( igraph::cluster_louvain(g)$membership )\nsce &lt;- runUMAP(sce,dimred = \"MNN\", n_dimred = 50,   ncomponents = 2,min_dist=0.1,spread=.3,\n               metric=\"correlation\",name = \"UMAP_on_MNN\")\n\n\nsamples &lt;- c(\"Anterior\", \"Posterior\")\nto_plot &lt;- c(\"louvain_SNNk5\")\n\nplist &lt;- list()\nn=1\nfor(j in to_plot){\n  for(i in samples){\n    temp &lt;- sce[,sce$Sample == i]\n    temp@metadata &lt;- temp@metadata[[i]]\n    plist[[n]]&lt;-spanielPlot(object = temp,\n        plotType = \"Cluster\",clusterRes = j,\n        customTitle = j,\n        techType = \"Visium\",\n        ptSizeMax = 1,ptSizeMin = .1)\n    n&lt;-n+1\n  }\n}\n\nplist[[3]] &lt;- plotReducedDim(sce, dimred = \"UMAP_on_MNN\", colour_by = \"louvain_SNNk5\")\nplist[[4]] &lt;- plotReducedDim(sce, dimred = \"UMAP_on_MNN\", colour_by = \"Sample\")\n\nplot_grid(ncol=2, plotlist = plist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nDo you see any differences between the integrated and non-integrated clustering? Judge for yourself, which of the clusterings do you think looks best? As a reference, you can compare to brain regions in the Allen brain atlas.\n\n\n\n\n3.3 Spatially Variable Features\nThere are two main workflows to identify molecular features that correlate with spatial location within a tissue. The first is to perform differential expression based on spatially distinct clusters, the other is to find features that have spatial patterning without taking clusters or spatial annotation into account. First, we will do differential expression between clusters just as we did for the scRNAseq data before.\n\n# differential expression between cluster 4 and cluster 6\ncell_selection &lt;- sce[ , sce$louvain_SNNk5 %in% c(4,6) ]\ncell_selection$louvain_SNNk5 &lt;- factor(cell_selection$louvain_SNNk5)\n\nmarkers_genes &lt;- scran::findMarkers( x = cell_selection,\n                              groups = cell_selection$louvain_SNNk5,\n                              lfc=.25,\n                              pval.type = \"all\",\n                              direction = \"up\")\n\n#List of dataFrames with the results for each cluster\ntop5_cell_selection &lt;- lapply( names(markers_genes), function(x) { temp &lt;- markers_genes[[x]][1:5, 1:2] ; temp$gene &lt;- rownames(markers_genes[[x]])[1:5] ; temp$cluster &lt;- x ; return(temp) } )\ntop5_cell_selection &lt;- as_tibble(do.call(rbind, top5_cell_selection))\ntop5_cell_selection\n\n# plot top markers\nsamples &lt;- c(\"Anterior\", \"Posterior\")\nto_plot &lt;- top5_cell_selection$gene[1:5]\n\nplist &lt;- list()\nn=1\nfor(j in to_plot){\n  for(i in samples){\n    temp &lt;- sce[,sce$Sample == i]\n    temp@metadata &lt;- temp@metadata[[i]]\n    plist[[n]]&lt;-spanielPlot(object = temp,\n        plotType = \"Gene\",\n        gene=j,\n        customTitle = j,\n        techType = \"Visium\",\n        ptSizeMax = 1,ptSizeMin = .1)\n    n&lt;-n+1\n  }\n}\nplot_grid(ncol=2, plotlist = plist)\n\n\n\n\n\n\n\n\n\n\n\n\np.value\nFDR\ngene\ncluster\n\n\n\n\n0\n0\nGng4\n4\n\n\n0\n0\nGpsm1\n4\n\n\n0\n0\nSynpr\n4\n\n\n0\n0\nPcbp3\n4\n\n\n0\n0\nMeis2\n4\n\n\n0\n0\nPtgds\n6\n\n\n0\n0\nAtp1a2\n6\n\n\n0\n0\nId3\n6\n\n\n0\n0\nApoe\n6\n\n\n0\n0\nMgp\n6"
  },
  {
    "objectID": "labs/bioc/bioc_07_spatial.html#meta-st_ss",
    "href": "labs/bioc/bioc_07_spatial.html#meta-st_ss",
    "title": " Spatial Transcriptomics",
    "section": "4 Single cell data",
    "text": "4 Single cell data\nWe can use a scRNA-seq dataset as a reference to predict the proportion of different celltypes in the Visium spots. Keep in mind that it is important to have a reference that contains all the celltypes you expect to find in your spots. Ideally it should be a scRNA-seq reference from the exact same tissue. We will use a reference scRNA-seq dataset of ~14,000 adult mouse cortical cell taxonomy from the Allen Institute, generated with the SMART-Seq2 protocol.\nFirst dowload the seurat data from: https://www.dropbox.com/s/cuowvm4vrf65pvq/allen_cortex.rds?dl=1 to folder data/spatial/ with command:\n\nwebpath &lt;- \"https://www.dropbox.com/s/cuowvm4vrf65pvq/allen_cortex.rds?dl=1\"\npath &lt;- \"data/spatial/allen_cortex.rds\"\nif(!file.exists(path)){  \n  dir.create(\"data/spatial/\",recursive = T)\n  options(timeout=10000)\n  download.file( url = webpath , destfile = path)\n  options(timeout=60)\n}\n\nFor speed, and for a more fair comparison of the celltypes, we will subsample all celltypes to a maximum of 200 cells per class (subclass).\n\nallen_reference &lt;- readRDS(\"data/spatial/allen_cortex.rds\")\nallen_reference_sce &lt;- Seurat::as.SingleCellExperiment(allen_reference)\n\n# check number of cells per subclass\nallen_reference_sce$subclass &lt;- sub(\"/\",\"_\",sub(\" \",\"_\",allen_reference_sce$subclass))\ntable(allen_reference_sce$subclass)\n\n# select 20 cells per subclass, fist set subclass ass active.ident\nsubset_cells &lt;- lapply(unique(allen_reference_sce$subclass),function(x){\n  if( sum(allen_reference_sce$subclass == x) &gt; 20 ){\n    temp &lt;- sample(colnames(allen_reference_sce)[allen_reference_sce$subclass == x],size = 20)\n  } else {\n    temp &lt;- colnames(allen_reference_sce)[allen_reference_sce$subclass == x]\n  } })\nallen_reference_sce &lt;- allen_reference_sce[,unlist(subset_cells)]\n\n# check again number of cells per subclass\ntable(allen_reference_sce$subclass)\n\n\n     Astro         CR       Endo    L2_3_IT         L4      L5_IT      L5_PT \n       368          7         94        982       1401        880        544 \n     L6_CT      L6_IT        L6b      Lamp5 Macrophage      Meis2         NP \n       960       1872        358       1122         51         45        362 \n     Oligo       Peri      Pvalb   Serpinf1        SMC       Sncg        Sst \n        91         32       1337         27         55        125       1741 \n       Vip       VLMC \n      1728         67 \n\n     Astro         CR       Endo    L2_3_IT         L4      L5_IT      L5_PT \n        20          7         20         20         20         20         20 \n     L6_CT      L6_IT        L6b      Lamp5 Macrophage      Meis2         NP \n        20         20         20         20         20         20         20 \n     Oligo       Peri      Pvalb   Serpinf1        SMC       Sncg        Sst \n        20         20         20         20         20         20         20 \n       Vip       VLMC \n        20         20 \n\n\nThen run normalization and dimensionality reduction.\n\nallen_reference_sce &lt;- computeSumFactors(allen_reference_sce, sizes=c(20, 40, 60, 80))\nallen_reference_sce &lt;- logNormCounts(allen_reference_sce)\nallen.var.out &lt;- modelGeneVar(allen_reference_sce, method=\"loess\")\nallen.hvgs = getTopHVGs(allen.var.out, n=2000)"
  },
  {
    "objectID": "labs/bioc/bioc_07_spatial.html#meta-st_sub",
    "href": "labs/bioc/bioc_07_spatial.html#meta-st_sub",
    "title": " Spatial Transcriptomics",
    "section": "5 Subset ST for cortex",
    "text": "5 Subset ST for cortex\nSince the scRNAseq dataset was generated from the mouse cortex, we will subset the visium dataset in order to select mainly the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and therefore it should be interpreted with more care.\n\n5.1 Integrate with scRNAseq\nHere, will use SingleR for prediciting which cell types are present in the dataset. We can first select the anterior part as an example (to speed up predictions).\n\nsce.anterior &lt;- sce[,sce$Sample == \"Anterior\"]\nsce.anterior@metadata &lt;- sce.anterior@metadata[[\"Anterior\"]]\n\nNext, we select the highly variable genes that are present in both datasets.\n\n#Find common highly variable genes\ncommon_hvgs &lt;- allen.hvgs[allen.hvgs %in% hvgs]\n\n#Predict cell classes\npred.grun &lt;- SingleR(test=sce.anterior[common_hvgs,],\n                     ref=allen_reference_sce[common_hvgs,],\n                     labels=allen_reference_sce$subclass)\n\n#Transfer the classes to the SCE object\nsce.anterior$cell_prediction &lt;- pred.grun$labels\nsce.anterior@colData &lt;- cbind(sce.anterior@colData,\n                              as.data.frame.matrix(table(list(1:ncol(sce.anterior),sce.anterior$cell_prediction))))\n\nThen we can plot the predicted cell populations back to tissue.\n\n#Plot cell predictions\nspanielPlot(object = sce.anterior,\n        plotType = \"Cluster\",\n        clusterRes = \"cell_prediction\",\n        customTitle = \"cell_prediction\",\n        techType = \"Visium\",\n        ptSizeMax = 1,ptSizeMin = .1)\n\n\n\n\n\n\n\n\n\nplist &lt;- list()\nn=1\nfor(i in c(\"L2_3_IT\",\"L4\",\"L5_IT\",\"L6_IT\")){\n  plist[[n]] &lt;- spanielPlot(object = sce.anterior,\n        plotType = \"Cluster\",\n        clusterRes = i,\n        customTitle = i,\n        techType = \"Visium\",ptSize = .3,\n        ptSizeMax = 1,ptSizeMin = .1)\n  n &lt;- n+1\n}\nplot_grid(ncol=2, plotlist = plist)\n\n\n\n\n\n\n\n\nKeep in mind, that the scores are “just” prediction scores, and do not correspond to proportion of cells that are of a certain celltype or similar. It mainly tell you that gene expression in a certain spot is hihgly similar/dissimilar to gene expression of a celltype. If we look at the scores, we see that some spots got really clear predictions by celltype, while others did not have high scores for any of the celltypes.\nWe can also plot the gene expression and add filters together, too:\n\nspanielPlot(object = sce.anterior,\n        plotType = \"Gene\",\n        gene=\"Wfs1\",\n        showFilter = sce.anterior$L4 ,\n        customTitle = \"\",\n        techType = \"Visium\",\n        ptSize=0,ptSizeMin = -.3,ptSizeMax = 1)"
  },
  {
    "objectID": "labs/bioc/bioc_07_spatial.html#meta-session",
    "href": "labs/bioc/bioc_07_spatial.html#meta-session",
    "title": " Spatial Transcriptomics",
    "section": "6 Session info",
    "text": "6 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] cowplot_1.1.1               patchwork_1.1.2            \n [3] scater_1.26.1               ggplot2_3.4.2              \n [5] SingleR_2.0.0               scran_1.26.2               \n [7] scuttle_1.8.4               dplyr_1.1.1                \n [9] Matrix_1.6-0                SingleCellExperiment_1.20.1\n[11] SummarizedExperiment_1.28.0 Biobase_2.58.0             \n[13] GenomicRanges_1.50.2        GenomeInfoDb_1.34.9        \n[15] IRanges_2.32.0              S4Vectors_0.36.2           \n[17] BiocGenerics_0.44.0         MatrixGenerics_1.10.0      \n[19] matrixStats_1.0.0           biomaRt_2.54.1             \n[21] Spaniel_1.12.0             \n\nloaded via a namespace (and not attached):\n  [1] utf8_1.2.3                R.utils_2.12.2           \n  [3] spatstat.explore_3.2-1    reticulate_1.30          \n  [5] tidyselect_1.2.0          RSQLite_2.3.1            \n  [7] AnnotationDbi_1.60.2      htmlwidgets_1.6.2        \n  [9] grid_4.2.3                BiocParallel_1.32.6      \n [11] Rtsne_0.16                DropletUtils_1.18.1      \n [13] munsell_0.5.0             ScaledMatrix_1.6.0       \n [15] codetools_0.2-19          ica_1.0-3                \n [17] statmod_1.5.0             future_1.33.0            \n [19] miniUI_0.1.1.1            batchelor_1.14.1         \n [21] withr_2.5.0               spatstat.random_3.1-5    \n [23] colorspace_2.1-0          progressr_0.13.0         \n [25] filelock_1.0.2            knitr_1.43               \n [27] rstudioapi_0.14           Seurat_4.3.0.1           \n [29] ROCR_1.0-11               tensor_1.5               \n [31] listenv_0.9.0             labeling_0.4.2           \n [33] GenomeInfoDbData_1.2.9    polyclip_1.10-4          \n [35] farver_2.1.1              bit64_4.0.5              \n [37] rhdf5_2.42.1              parallelly_1.36.0        \n [39] vctrs_0.6.3               generics_0.1.3           \n [41] xfun_0.39                 BiocFileCache_2.6.1      \n [43] R6_2.5.1                  ggbeeswarm_0.7.2         \n [45] rsvd_1.0.5                locfit_1.5-9.8           \n [47] rhdf5filters_1.10.1       bitops_1.0-7             \n [49] spatstat.utils_3.0-3      cachem_1.0.8             \n [51] DelayedArray_0.24.0       promises_1.2.0.1         \n [53] scales_1.2.1              beeswarm_0.4.0           \n [55] gtable_0.3.3              beachmat_2.14.2          \n [57] globals_0.16.2            goftest_1.2-3            \n [59] rlang_1.1.1               splines_4.2.3            \n [61] lazyeval_0.2.2            spatstat.geom_3.2-1      \n [63] yaml_2.3.7                reshape2_1.4.4           \n [65] abind_1.4-5               httpuv_1.6.11            \n [67] tools_4.2.3               ellipsis_0.3.2           \n [69] RColorBrewer_1.1-3        ggridges_0.5.4           \n [71] Rcpp_1.0.10               plyr_1.8.8               \n [73] sparseMatrixStats_1.10.0  progress_1.2.2           \n [75] zlibbioc_1.44.0           purrr_1.0.1              \n [77] RCurl_1.98-1.12           prettyunits_1.1.1        \n [79] deldir_1.0-9              viridis_0.6.3            \n [81] pbapply_1.7-2             zoo_1.8-12               \n [83] SeuratObject_4.1.3        ggrepel_0.9.3            \n [85] cluster_2.1.4             magrittr_2.0.3           \n [87] data.table_1.14.8         scattermore_1.2          \n [89] ResidualMatrix_1.8.0      lmtest_0.9-40            \n [91] RANN_2.6.1                fitdistrplus_1.1-11      \n [93] hms_1.1.3                 mime_0.12                \n [95] evaluate_0.21             xtable_1.8-4             \n [97] XML_3.99-0.14             gridExtra_2.3            \n [99] compiler_4.2.3            tibble_3.2.1             \n[101] KernSmooth_2.23-20        crayon_1.5.2             \n[103] R.oo_1.25.0               htmltools_0.5.5          \n[105] later_1.3.1               tidyr_1.3.0              \n[107] DBI_1.1.3                 dbplyr_2.3.2             \n[109] MASS_7.3-58.2             rappdirs_0.3.3           \n[111] cli_3.6.1                 R.methodsS3_1.8.2        \n[113] parallel_4.2.3            metapod_1.6.0            \n[115] igraph_1.5.0              pkgconfig_2.0.3          \n[117] sp_2.0-0                  plotly_4.10.2            \n[119] spatstat.sparse_3.0-2     xml2_1.3.4               \n[121] vipor_0.4.5               dqrng_0.3.0              \n[123] XVector_0.38.0            stringr_1.5.0            \n[125] digest_0.6.33             sctransform_0.3.5        \n[127] RcppAnnoy_0.0.21          spatstat.data_3.0-1      \n[129] Biostrings_2.66.0         rmarkdown_2.21           \n[131] leiden_0.4.3              uwot_0.1.16              \n[133] edgeR_3.40.2              DelayedMatrixStats_1.20.0\n[135] curl_5.0.1                shiny_1.7.4              \n[137] lifecycle_1.0.3           nlme_3.1-162             \n[139] jsonlite_1.8.7            Rhdf5lib_1.20.0          \n[141] BiocNeighbors_1.16.0      viridisLite_0.4.2        \n[143] limma_3.54.2              fansi_1.0.4              \n[145] pillar_1.9.0              lattice_0.20-45          \n[147] KEGGREST_1.38.0           fastmap_1.1.1            \n[149] httr_1.4.6                survival_3.5-3           \n[151] glue_1.6.2                png_0.1-8                \n[153] bluster_1.8.0             bit_4.0.5                \n[155] HDF5Array_1.26.0          stringi_1.7.12           \n[157] blob_1.2.4                BiocSingular_1.14.0      \n[159] memoise_2.0.1             irlba_2.3.5.1            \n[161] future.apply_1.11.0"
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html",
    "href": "labs/seurat/seurat_06_celltyping.html",
    "title": " Celltype prediction",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nCelltype prediction can either be performed on indiviudal cells where each cell gets a predicted celltype label, or on the level of clusters. All methods are based on similarity to other datasets, single cell or sorted bulk RNAseq, or uses known marker genes for each celltype.\nWe will select one sample from the Covid data, ctrl_13 and predict celltype by cell on that sample.\nSome methods will predict a celltype to each cell based on what it is most similar to even if the celltype of that cell is not included in the reference. Other methods include an uncertainty so that cells with low similarity scores will be unclassified.\nThere are multiple different methods to predict celltypes, here we will just cover a few of those.\nHere we will use a reference PBMC dataset from the scPred package which is provided as a Seurat object with counts. And we will test classification based on the scPred and scMap methods. Finally we will use gene set enrichment predict celltype based on the DEGs of each cluster."
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html#meta-ct_read",
    "href": "labs/seurat/seurat_06_celltyping.html#meta-ct_read",
    "title": " Celltype prediction",
    "section": "1 Read data",
    "text": "1 Read data\nFirst, lets load required libraries\n\nsuppressPackageStartupMessages({\n  library(Seurat)\n  library(dplyr)\n  library(cowplot)\n  library(ggplot2)\n  library(pheatmap)\n  library(rafalib)\n  # remotes::install_github(\"powellgenomicslab/scPred\")\n  library(scPred)\n})\n\nLet’s read in the saved Covid-19 data object from the clustering step.\n\n#load the data and select 'ctrl_13` sample\nalldata &lt;- readRDS(\"data/results/covid_qc_dr_int_cl.rds\")\n\nSubset one patient.\n\nctrl = alldata[, alldata$orig.ident == 'ctrl_13']\n\n# set active assay to RNA and remove the CCA assay\nctrl@active.assay = 'RNA' \nctrl[['CCA']] = NULL\nctrl\n\nAn object of class Seurat \n18121 features across 1139 samples within 1 assay \nActive assay: RNA (18121 features, 0 variable features)\n 6 dimensional reductions calculated: umap, tsne, harmony, umap_harmony, scanorama, umap_scanorama"
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html#meta-ct_ref",
    "href": "labs/seurat/seurat_06_celltyping.html#meta-ct_ref",
    "title": " Celltype prediction",
    "section": "2 Reference data",
    "text": "2 Reference data\nLoad the reference dataset with annotated labels.\n\nreference &lt;- scPred::pbmc_1\nreference\n\nAn object of class Seurat \n32838 features across 3500 samples within 1 assay \nActive assay: RNA (32838 features, 0 variable features)\n\n\nRerun analysis pipeline. Run normalization, feature selection and dimensionality reduction\nHere, we will run all the steps that we did in previous labs in one go using the magittr package with the pipe-operator %&gt;%.\n\nreference &lt;- reference %&gt;%\n  NormalizeData() %&gt;%\n  FindVariableFeatures() %&gt;%\n  ScaleData() %&gt;%\n  RunPCA(verbose = F) %&gt;%\n  RunUMAP(dims = 1:30)\n\n\nDimPlot(reference, group.by = \"cell_type\", label = TRUE, repel = TRUE) + NoAxes()\n\n\n\n\n\n\n\n\nRun all steps of the analysis for the ctrl sample as well. Use the clustering from the integration lab with resolution 0.5.\n\n#Set the identity as louvain with resolution 0.3\nctrl &lt;- SetIdent(ctrl, value = \"CCA_snn_res.0.5\")\n  \nctrl &lt;- ctrl %&gt;%\n  NormalizeData() %&gt;%\n  FindVariableFeatures() %&gt;%\n  ScaleData() %&gt;%\n  RunPCA(verbose = F) %&gt;%\n  RunUMAP(dims = 1:30)\n\n\nDimPlot(ctrl,  label = TRUE, repel = TRUE) + NoAxes()"
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html#label-transfer",
    "href": "labs/seurat/seurat_06_celltyping.html#label-transfer",
    "title": " Celltype prediction",
    "section": "3 Label transfer",
    "text": "3 Label transfer\nFirst we will run label transfer using a similar method as in the integration exercise. But, instad of CCA the default for the ’FindTransferAnchors` function is to use “pcaproject”, e.g. the query dataset is projected onto the PCA of the reference dataset. Then, the labels of the reference data are predicted.\n\ntransfer.anchors &lt;- FindTransferAnchors(reference = reference, query = ctrl, \n    dims = 1:30)\npredictions &lt;- TransferData(anchorset = transfer.anchors, refdata = reference$cell_type, \n    dims = 1:30)\nctrl &lt;- AddMetaData(object = ctrl, metadata = predictions)\n\n\nDimPlot(ctrl, group.by = \"predicted.id\", label = T, repel = T) + NoAxes()\n\n\n\n\n\n\n\n\nNow plot how many cells of each celltypes can be found in each cluster.\n\nggplot(ctrl@meta.data, aes(x=CCA_snn_res.0.5, fill = predicted.id)) + geom_bar() + theme_classic()"
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html#meta-ct_scpred",
    "href": "labs/seurat/seurat_06_celltyping.html#meta-ct_scpred",
    "title": " Celltype prediction",
    "section": "4 scPred",
    "text": "4 scPred\nscPred will train a classifier based on all principal components. First, getFeatureSpace will create a scPred object stored in the @misc slot where it extracts the PCs that best separates the different celltypes. Then trainModel will do the actual training for each celltype.\n\nreference &lt;- getFeatureSpace(reference, \"cell_type\")\nreference &lt;- trainModel(reference)\n\n●  Extracting feature space for each cell type...\nDONE!\n●  Training models for each cell type...\nmaximum number of iterations reached 0.0001152056 -0.0001143117DONE!\n\n\nWe can then print how well the training worked for the different celltypes by printing the number of PCs used for each, the ROC value and Sensitivity/Specificity. Which celltypes do you think are harder to classify based on this dataset?\n\nget_scpred(reference)\n\n'scPred' object\n✔  Prediction variable = cell_type \n✔  Discriminant features per cell type\n✔  Training model(s)\nSummary\n\n|Cell type   |    n| Features|Method    |   ROC|  Sens|  Spec|\n|:-----------|----:|--------:|:---------|-----:|-----:|-----:|\n|B cell      |  280|       50|svmRadial | 1.000| 0.964| 1.000|\n|CD4 T cell  | 1620|       50|svmRadial | 0.997| 0.972| 0.975|\n|CD8 T cell  |  945|       50|svmRadial | 0.985| 0.899| 0.978|\n|cDC         |   26|       50|svmRadial | 0.995| 0.547| 1.000|\n|cMono       |  212|       50|svmRadial | 0.994| 0.958| 0.970|\n|ncMono      |   79|       50|svmRadial | 0.998| 0.570| 1.000|\n|NK cell     |  312|       50|svmRadial | 0.999| 0.933| 0.996|\n|pDC         |   20|       50|svmRadial | 1.000| 0.700| 1.000|\n|Plasma cell |    6|       50|svmRadial | 1.000| 0.800| 1.000|\n\n\nYou can optimize parameters for each dataset by chaning parameters and testing different types of models, see more at: https://powellgenomicslab.github.io/scPred/articles/introduction.html. But for now, we will continue with this model. Now, lets predict celltypes on our data, where scPred will align the two datasets with Harmony and then perform classification.\n\nctrl &lt;- scPredict(ctrl, reference)\n\n●  Matching reference with new dataset...\n     ─ 2000 features present in reference loadings\n     ─ 1774 features shared between reference and new dataset\n     ─ 88.7% of features in the reference are present in new dataset\n●  Aligning new data to reference...\n●  Classifying cells...\nDONE!\n\n\n\nDimPlot(ctrl, group.by = \"scpred_prediction\", label = T, repel = T) + NoAxes()\n\n\n\n\n\n\n\n\nNow plot how many cells of each celltypes can be found in each cluster.\n\nggplot(ctrl@meta.data, aes(x=CCA_snn_res.0.5, fill = scpred_prediction)) + geom_bar() + theme_classic()"
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html#meta-ct_compare",
    "href": "labs/seurat/seurat_06_celltyping.html#meta-ct_compare",
    "title": " Celltype prediction",
    "section": "5 Compare results",
    "text": "5 Compare results\nNow we will compare the output of the two methods using the convenient function in scPred crossTab that prints the overlap between two metadata slots.\n\ncrossTab(ctrl, \"predicted.id\", \"scpred_prediction\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nB cell\nCD4 T cell\nCD8 T cell\ncDC\ncMono\nncMono\nNK cell\npDC\nPlasma cell\n\n\n\n\nB cell\n103\n1\n2\n0\n2\n0\n0\n0\n0\n\n\nCD4 T cell\n0\n200\n1\n0\n0\n0\n0\n0\n0\n\n\nCD8 T cell\n0\n6\n225\n0\n1\n0\n5\n0\n0\n\n\ncDC\n0\n0\n0\n16\n8\n0\n0\n0\n0\n\n\ncMono\n0\n6\n2\n0\n198\n4\n0\n0\n0\n\n\nncMono\n0\n0\n0\n0\n8\n101\n0\n0\n0\n\n\nNK cell\n0\n0\n12\n0\n0\n0\n153\n0\n0\n\n\npDC\n0\n0\n0\n1\n0\n0\n0\n1\n0\n\n\nPlasma cell\n0\n1\n0\n0\n0\n0\n0\n0\n2\n\n\nunassigned\n0\n11\n12\n0\n55\n2\n0\n0\n0"
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html#meta-ct_gsea",
    "href": "labs/seurat/seurat_06_celltyping.html#meta-ct_gsea",
    "title": " Celltype prediction",
    "section": "6 GSEA with celltype markers",
    "text": "6 GSEA with celltype markers\nAnother option, where celltype can be classified on cluster level is to use gene set enrichment among the DEGs with known markers for different celltypes. Similar to how we did functional enrichment for the DEGs in the Differential expression exercise. There are some resources for celltype gene sets that can be used. Such as CellMarker, PanglaoDB or celltype gene sets at MSigDB. We can also look at overlap between DEGs in a reference dataset and the dataset you are analysing.\n\n6.1 DEG overlap\nFirst, lets extract top DEGs for our Covid-19 dataset and the reference dataset. When we run differential expression for our dataset, we want to report as many genes as possible, hence we set the cutoffs quite lenient.\n\n# run differential expression in our dataset, using clustering at resolution 0.5\nalldata &lt;- SetIdent(alldata,value = \"CCA_snn_res.0.5\")\nDGE_table &lt;- FindAllMarkers(\n  alldata,\n  logfc.threshold = 0,\n  test.use = \"wilcox\",\n  min.pct = 0.1,\n  min.diff.pct = 0,\n  only.pos = TRUE,\n  max.cells.per.ident = 20,\n  return.thresh = 1,\n  assay = \"RNA\"\n)\n\n# split into a list\nDGE_list &lt;- split(DGE_table, DGE_table$cluster)\n\nunlist(lapply(DGE_list, nrow))\n\n   0    1    2    3    4    5    6    7    8    9 \n3166 3314 2499 4072 2556 2036 3861 2218 2479 3343 \n\n\n\n# Compute differential gene expression in reference dataset (that has cell annotation)\nreference &lt;- SetIdent( reference, value = \"cell_type\")\nreference_markers &lt;- FindAllMarkers(\n  reference ,\n  min.pct = .1 , \n  min.diff.pct = .2,\n  only.pos = T, \n  max.cells.per.ident = 20 ,\n  return.thresh = 1 \n)\n\n# Identify the top cell marker genes in reference dataset\n# select top 50 with hihgest foldchange among top 100 signifcant genes.\nreference_markers &lt;- reference_markers [ order(reference_markers$avg_log2FC,decreasing = T), ]\nreference_markers %&gt;% \n  group_by(cluster) %&gt;% \n  top_n(-100, p_val) %&gt;% \n  top_n(50, avg_log2FC) -&gt; top50_cell_selection\n\n# Transform the markers into a list\nref_list = split(top50_cell_selection$gene, top50_cell_selection$cluster)\n\nunlist(lapply(ref_list, length))\n\n CD8 T cell  CD4 T cell       cMono      B cell     NK cell         pDC \n         30          15          50          50          50          50 \n     ncMono         cDC Plasma cell \n         50          50          50 \n\n\nNow we can run GSEA for the DEGs from our dataset and check for enrichment of top DEGs in the reference dataset.\n\nsuppressPackageStartupMessages(library(fgsea))\n\n# run fgsea for each of the clusters in the list\nres &lt;- lapply(DGE_list, function(x){\n  gene_rank &lt;- setNames(x$avg_log2FC, x$gene)\n  fgseaRes &lt;- fgsea( pathways=ref_list, stats=gene_rank,nperm=10000)\n  return(fgseaRes)\n})\nnames(res) &lt;- names(DGE_list)\n\n# You can filter and resort the table based on ES, NES or pvalue\nres &lt;- lapply(res, function(x) {x[ x$pval &lt; 0.1 , ]} )\nres &lt;- lapply(res, function(x) {x[ x$size &gt; 2 , ]} )\nres &lt;- lapply(res, function(x) {x[order(x$NES,decreasing = T), ]} )\nres\n\n$`0`\n   pathway        pval        padj        ES      NES nMoreExtreme size\n1:   cMono 0.000099990 0.000299970 0.9604823 2.082162            0   48\n2:  ncMono 0.000099990 0.000299970 0.8400708 1.817122            0   46\n3:     cDC 0.000099990 0.000299970 0.8137532 1.753954            0   43\n4:     pDC 0.001002506 0.002255639 0.7623781 1.564625            9   21\n5:  B cell 0.007857359 0.014143246 0.7385015 1.483444           77   16\n6: NK cell 0.016469377 0.024704066 0.7615592 1.466565          159   11\n                                    leadingEdge\n1:      S100A8,S100A9,LYZ,S100A12,VCAN,FCN1,...\n2:     CTSS,TYMP,CST3,S100A11,AIF1,SERPINA1,...\n3:              LYZ,GRN,TYMP,CST3,AIF1,SPI1,...\n4:         GRN,MS4A6A,CST3,MPEG1,CTSB,TGFBI,...\n5: NCF1,LY86,MARCH1,HLA-DRB5,POU2F2,PHACTR1,...\n6:       TYROBP,FCER1G,SRGN,CCL3,CD63,MYO1F,...\n\n$`1`\n       pathway         pval         padj        ES      NES nMoreExtreme size\n1:  CD8 T cell 0.0001000901 0.0003503153 0.9472460 2.204879            0   29\n2:     NK cell 0.0001000400 0.0003503153 0.8485185 1.988182            0   32\n3:  CD4 T cell 0.0015444015 0.0036036036 0.8753374 1.705631           13    7\n4: Plasma cell 0.0866606625 0.1172265547 0.5478953 1.278696          865   30\n                                  leadingEdge\n1:          CD8A,CD3D,GZMH,CCL5,CD3G,CD8B,...\n2:          CCL5,NKG7,GZMA,GZMM,CST7,CCL4,...\n3:                CD3D,CD3G,CD3E,IL7R,PIK3IP1\n4: FKBP11,PRDM1,PEBP1,SEC11C,PPIB,SELENOS,...\n\n$`2`\n       pathway         pval        padj        ES      NES nMoreExtreme size\n1:      B cell 0.0001000000 0.000800000 0.8988279 2.015474            0   46\n2:         cDC 0.0003053746 0.001221498 0.8772318 1.797614            2   14\n3:         pDC 0.0011067512 0.002951336 0.7753617 1.628458           10   18\n4: Plasma cell 0.0835030550 0.118339040 0.7150909 1.361282          778    8\n5:      ncMono 0.0887542797 0.118339040 0.8425481 1.344170          673    3\n                                            leadingEdge\n1:      CD79A,TCL1A,LINC00926,MS4A1,CD79B,TNFRSF13C,...\n2: CD74,HLA-DQB1,HLA-DRA,HLA-DPB1,HLA-DRB1,HLA-DQA1,...\n3:               CD74,TCF4,BCL11A,IRF8,HERPUD1,SPIB,...\n4:                PLPP5,ISG20,HERPUD1,MZB1,ITM2C,JCHAIN\n5:                                  HLA-DPA1,POU2F2,LYN\n\n$`3`\n       pathway         pval         padj        ES      NES nMoreExtreme size\n1:     NK cell 0.0001000000 0.0004019697 0.9400385 2.445529            0   50\n2:  CD8 T cell 0.0001004924 0.0004019697 0.9179690 2.251090            0   24\n3:         pDC 0.0006280750 0.0016748665 0.8051689 1.784358            5   11\n4:      ncMono 0.0197270329 0.0394540658 0.7970971 1.570700          171    6\n5: Plasma cell 0.0248422318 0.0397475709 0.5710832 1.429502          247   30\n                                  leadingEdge\n1:         SPON2,PRF1,GNLY,GZMB,CD7,CLIC3,...\n2:        PRF1,GNLY,GZMB,CTSW,NKG7,FGFBP2,...\n3:  GZMB,PLAC8,C12orf75,RRBP1,ALOX5AP,HSP90B1\n4:                    FCGR3A,IFITM2,RHOC,HES4\n5: CD38,FKBP11,SLAMF7,HSP90B1,SDF2L1,PPIB,...\n\n$`4`\n   pathway       pval      padj        ES      NES nMoreExtreme size\n1:  B cell 0.03324453 0.1496004 0.8571390 1.470997          286    5\n2:  ncMono 0.01910191 0.1496004 0.6490433 1.366874          190   35\n                                leadingEdge\n1:                PDLIM1,HLA-DRB5,STX7,NCF1\n2: OAZ1,TIMP1,FKBP1A,CST3,IFITM3,FCER1G,...\n\n$`5`\n      pathway         pval         padj        ES      NES nMoreExtreme size\n1: CD4 T cell 0.0001016984 0.0007118885 0.9134477 1.799050            0   14\n2: CD8 T cell 0.0014178209 0.0049623732 0.8957908 1.612853           12    7\n                         leadingEdge\n1: IL7R,LTB,LDHB,RCAN3,NOSIP,MAL,...\n2:      IL32,CD3D,CD3E,CD2,CD3G,CD8B\n\n$`6`\n       pathway         pval         padj        ES      NES nMoreExtreme size\n1:     NK cell 0.0001000000 0.0004010829 0.9241341 2.407067            0   45\n2:  CD8 T cell 0.0001002707 0.0004010829 0.9155580 2.278493            0   27\n3:      ncMono 0.0029816514 0.0079510703 0.8599246 1.697683           25    6\n4:         pDC 0.0243642941 0.0487285881 0.7067908 1.543200          228   10\n5:  CD4 T cell 0.0422912206 0.0676659529 0.8575282 1.445832          315    3\n6: Plasma cell 0.0991694186 0.1322258915 0.5055153 1.281763          990   32\n                                  leadingEdge\n1:        FGFBP2,GNLY,NKG7,CST7,GZMB,CTSW,...\n2:        FGFBP2,GNLY,NKG7,CST7,GZMB,CTSW,...\n3:                         FCGR3A,IFITM2,RHOC\n4:  GZMB,C12orf75,HSP90B1,ALOX5AP,PLAC8,RRBP1\n5:                                  CD3E,CD3D\n6: PRDM1,FKBP11,HSP90B1,PPIB,SPCS2,SLAMF7,...\n\n$`7`\n      pathway         pval         padj        ES      NES nMoreExtreme size\n1: CD4 T cell 0.0001016467 0.0006098801 0.9187840 1.953882            0   14\n2: CD8 T cell 0.0744383728 0.1488767456 0.7949413 1.357119          612    4\n                            leadingEdge\n1: IL7R,TCF7,LTB,TSHZ2,PIK3IP1,LEF1,...\n2:                   CD3E,CD3G,CD3D,CD2\n\n$`8`\n       pathway         pval        padj        ES      NES nMoreExtreme size\n1:      B cell 0.0000999900 0.000304909 0.8990233 1.910958            0   45\n2:         cDC 0.0001016363 0.000304909 0.8963109 1.763319            0   14\n3:         pDC 0.0001011122 0.000304909 0.8409385 1.676958            0   16\n4: Plasma cell 0.0010163635 0.002286818 0.8262721 1.625531            9   14\n5:      ncMono 0.0046046573 0.008288383 0.9587620 1.511378           34    3\n                                            leadingEdge\n1:        CD79A,MS4A1,BANK1,CD74,TNFRSF13C,HLA-DQA1,...\n2: CD74,HLA-DQA1,HLA-DRA,HLA-DPB1,HLA-DQB1,HLA-DPA1,...\n3:             CD74,JCHAIN,SPIB,HERPUD1,TCF4,CCDC50,...\n4:                JCHAIN,HERPUD1,ISG20,ITM2C,MZB1,PEBP1\n5:                                      HLA-DPA1,POU2F2\n\n$`9`\n   pathway        pval         padj        ES      NES nMoreExtreme size\n1:  ncMono 0.000099990 0.0002666933 0.9569912 2.036762            0   49\n2:   cMono 0.000100010 0.0002666933 0.8930249 1.861037            0   33\n3:     cDC 0.000100000 0.0002666933 0.8435239 1.767796            0   37\n4: NK cell 0.006547315 0.0130946292 0.7881824 1.522179           63   12\n5:  B cell 0.031278378 0.0500454041 0.6998417 1.386118          309   16\n6:     pDC 0.054854026 0.0731387009 0.6815870 1.342377          542   15\n                                              leadingEdge\n1:                CDKN1C,LST1,FCGR3A,COTL1,AIF1,MS4A7,...\n2:               LST1,COTL1,AIF1,SERPINA1,FCER1G,PSAP,...\n3:                   LST1,COTL1,AIF1,FCER1G,SPI1,CST3,...\n4:             FCGR3A,RHOC,FCER1G,TYROBP,IFITM2,MYO1F,...\n5: HLA-DPA1,POU2F2,HLA-DRB5,HLA-DPB1,HLA-DRA,HLA-DRB1,...\n6:                    CST3,NPC2,PLD4,MPEG1,TGFBI,CTSB,...\n\n\nSelecing top significant overlap per cluster, we can now rename the clusters according to the predicted labels. OBS! Be aware that if you have some clusters that have non-significant p-values for all the gene sets, the cluster label will not be very reliable. Also, the gene sets you are using may not cover all the celltypes you have in your dataset and hence predictions may just be the most similar celltype. Also, some of the clusters have very similar p-values to multiple celltypes, for instance the ncMono and cMono celltypes are equally good for some clusters.\n\nnew.cluster.ids &lt;- unlist(lapply(res,function(x){as.data.frame(x)[1,1]}))\n\nalldata$ref_gsea &lt;- new.cluster.ids[as.character(alldata@active.ident)]\n\ncowplot::plot_grid( ncol = 2,\nDimPlot(alldata,label = T,group.by = \"CCA_snn_res.0.5\") + NoAxes(),\nDimPlot(alldata,label = T, group.by = \"ref_gsea\") + NoAxes())\n\n\n\n\n\n\n\n\nCompare to results with the other celltype prediction methods in the ctrl_13 sample.\n\nctrl$ref_gsea = alldata$ref_gsea[alldata$orig.ident == \"ctrl_13\"]\n\ncowplot::plot_grid( ncol = 3,\nDimPlot(ctrl,label = T,group.by = \"ref_gsea\") + NoAxes() + ggtitle(\"GSEA\"),\nDimPlot(ctrl,label = T, group.by = \"predicted.id\") + NoAxes() + ggtitle(\"LabelTransfer\"),\nDimPlot(ctrl,label = T, group.by = \"scpred_prediction\") + NoAxes() + ggtitle(\"scPred\")\n)\n\n\n\n\n\n\n\n\n\n\n6.2 With annotated gene sets\nRead in the gene lists and do some filtering.\n\n# Load the human marker table\nmarkers &lt;- read.delim(\"data/cellmarker/Human_cell_markers.txt\")\nmarkers &lt;- markers [ markers$speciesType == \"Human\", ]\nmarkers &lt;- markers [ markers$cancerType == \"Normal\", ]\n\n#Filter by tissue (to reduce computational time and have tissue-specific classification)\nsort(unique(markers$tissueType))\ngrep(\"blood\",unique(markers$tissueType),value = T)\nmarkers &lt;- markers [ markers$tissueType %in% c(\"Blood\",\"Venous blood\",\n                                                \"Serum\",\"Plasma\",\n                                                \"Spleen\",\"Bone marrow\",\"Lymph node\"), ]\n\n# remove strange characters etc.\ncelltype_list &lt;- lapply( unique(markers$cellName) , function(x){\n  x &lt;- paste(markers$geneSymbol[markers$cellName == x],sep=\",\")\n  x &lt;- gsub(\"[[]|[]]| |-\",\",\",x)\n  x &lt;- unlist(strsplit( x , split = \",\"))\n  x &lt;- unique(x [ ! x %in% c(\"\",\"NA\",\"family\") ])\n  x &lt;- casefold(x,upper = T)\n})\nnames(celltype_list) &lt;- unique(markers$cellName)\n# celltype_list &lt;- lapply(celltype_list , function(x) {x[1:min(length(x),50)]} )\ncelltype_list &lt;- celltype_list[ unlist(lapply(celltype_list,length)) &lt; 100 ]\ncelltype_list &lt;- celltype_list[ unlist(lapply(celltype_list,length)) &gt; 5 ]\n\n  [1] \"Abdominal adipose tissue\"       \"Adipose tissue\"                \n  [3] \"Adrenal gland\"                  \"Adventitia\"                    \n  [5] \"Airway epithelium\"              \"Alveolus\"                      \n  [7] \"Amniotic fluid\"                 \"Amniotic membrane\"             \n  [9] \"Antecubital vein\"               \"Anterior cruciate ligament\"    \n [11] \"Artery\"                         \"Ascites\"                       \n [13] \"Bladder\"                        \"Blood\"                         \n [15] \"Blood vessel\"                   \"Bone\"                          \n [17] \"Bone marrow\"                    \"Brain\"                         \n [19] \"Breast\"                         \"Bronchoalveolar system\"        \n [21] \"Brown adipose tissue\"           \"Cartilage\"                     \n [23] \"Chorionic villus\"               \"Colon\"                         \n [25] \"Colorectum\"                     \"Cornea\"                        \n [27] \"Corneal endothelium\"            \"Corneal epithelium\"            \n [29] \"Corpus luteum\"                  \"Decidua\"                       \n [31] \"Deciduous tooth\"                \"Dental pulp\"                   \n [33] \"Dermis\"                         \"Dorsolateral prefrontal cortex\"\n [35] \"Duodenum\"                       \"Embryo\"                        \n [37] \"Embryoid body\"                  \"Embryonic brain\"               \n [39] \"Embryonic prefrontal cortex\"    \"Embryonic stem cell\"           \n [41] \"Endometrium\"                    \"Endometrium stroma\"            \n [43] \"Epithelium\"                     \"Esophagus\"                     \n [45] \"Eye\"                            \"Fat pad\"                       \n [47] \"Fetal brain\"                    \"Fetal gonad\"                   \n [49] \"Fetal kidney\"                   \"Fetal liver\"                   \n [51] \"Fetal pancreas\"                 \"Foreskin\"                      \n [53] \"Gastric corpus\"                 \"Gastric epithelium\"            \n [55] \"Gastric gland\"                  \"Gastrointestinal tract\"        \n [57] \"Germ\"                           \"Gingiva\"                       \n [59] \"Gonad\"                          \"Gut\"                           \n [61] \"Hair follicle\"                  \"Heart\"                         \n [63] \"Hippocampus\"                    \"Inferior colliculus\"           \n [65] \"Intervertebral disc\"            \"Intestinal crypt\"              \n [67] \"Intestine\"                      \"Jejunum\"                       \n [69] \"Kidney\"                         \"Lacrimal gland\"                \n [71] \"Large intestine\"                \"Laryngeal squamous epithelium\" \n [73] \"Ligament\"                       \"Limbal epithelium\"             \n [75] \"Liver\"                          \"Lung\"                          \n [77] \"Lymph\"                          \"Lymph node\"                    \n [79] \"Lymphoid tissue\"                \"Mammary epithelium\"            \n [81] \"Meniscus\"                       \"Midbrain\"                      \n [83] \"Molar\"                          \"Muscle\"                        \n [85] \"Myocardium\"                     \"Myometrium\"                    \n [87] \"Nasal concha\"                   \"Nasal epithelium\"              \n [89] \"Nerve\"                          \"Nucleus pulposus\"              \n [91] \"Optic nerve\"                    \"Oral mucosa\"                   \n [93] \"Osteoarthritic cartilage\"       \"Ovarian cortex\"                \n [95] \"Ovarian follicle\"               \"Ovary\"                         \n [97] \"Oviduct\"                        \"Pancreas\"                      \n [99] \"Pancreatic acinar tissue\"       \"Pancreatic islet\"              \n[101] \"Periodontal ligament\"           \"Periosteum\"                    \n[103] \"Peripheral blood\"               \"Placenta\"                      \n[105] \"Plasma\"                         \"Pluripotent stem cell\"         \n[107] \"Premolar\"                       \"Primitive streak\"              \n[109] \"Prostate\"                       \"Pyloric gland\"                 \n[111] \"Rectum\"                         \"Renal glomerulus\"              \n[113] \"Retina\"                         \"Retinal pigment epithelium\"    \n[115] \"Salivary gland\"                 \"Scalp\"                         \n[117] \"Sclerocorneal tissue\"           \"Seminal plasma\"                \n[119] \"Serum\"                          \"Sinonasal mucosa\"              \n[121] \"Skeletal muscle\"                \"Skin\"                          \n[123] \"Small intestinal crypt\"         \"Small intestine\"               \n[125] \"Spinal cord\"                    \"Spleen\"                        \n[127] \"Splenic red pulp\"               \"Sputum\"                        \n[129] \"Stomach\"                        \"Subcutaneous adipose tissue\"   \n[131] \"Submandibular gland\"            \"Sympathetic ganglion\"          \n[133] \"Synovial fluid\"                 \"Synovium\"                      \n[135] \"Tendon\"                         \"Testis\"                        \n[137] \"Thymus\"                         \"Thyroid\"                       \n[139] \"Tonsil\"                         \"Tooth\"                         \n[141] \"Umbilical cord\"                 \"Umbilical cord blood\"          \n[143] \"Umbilical vein\"                 \"Undefined\"                     \n[145] \"Urine\"                          \"Uterus\"                        \n[147] \"Vagina\"                         \"Venous blood\"                  \n[149] \"Visceral adipose tissue\"        \"Vocal fold\"                    \n[151] \"Whartons jelly\"                 \"White adipose tissue\"          \n[1] \"Peripheral blood\"     \"Umbilical cord blood\" \"Venous blood\"        \n\n\n\n# run fgsea for each of the clusters in the list\nres &lt;- lapply(DGE_list, function(x){\n  gene_rank &lt;- setNames(x$avg_log2FC, x$gene)\n  fgseaRes &lt;- fgsea( pathways=celltype_list, stats=gene_rank,nperm=10000)\n  return(fgseaRes)\n})\nnames(res) &lt;- names(DGE_list)\n\n# You can filter and resort the table based on ES, NES or pvalue\nres &lt;- lapply(res, function(x) {x[ x$pval &lt; 0.01 , ]} )\nres &lt;- lapply(res, function(x) {x[ x$size &gt; 5 , ]} )\nres &lt;- lapply(res, function(x) {x[order(x$NES,decreasing = T), ]} )\n\n# show top 3 for each cluster.\nlapply(res,head,3)\n\n$`0`\n                    pathway         pval        padj        ES      NES\n1:               Neutrophil 0.0002024496 0.003542869 0.8523815 1.711647\n2:   CD1C+_B dendritic cell 0.0000999900 0.003499650 0.7860707 1.711588\n3: Mesenchymal stromal cell 0.0033194132 0.029044866 0.8633935 1.609837\n   nMoreExtreme size                             leadingEdge\n1:            1   15 CD14,CSF3R,JAML,C5AR1,FCGR2A,FCGR1A,...\n2:            0   49 S100A8,S100A9,LYZ,S100A12,VCAN,FCN1,...\n3:           30    8              CD14,VIM,ANPEP,CD44,PECAM1\n\n$`1`\n                    pathway         pval        padj        ES      NES\n1:                   T cell 0.0001105217 0.000793454 0.9634109 1.880733\n2:             Myeloid cell 0.0001021868 0.000793454 0.8522776 1.852164\n3: Mesenchymal stromal cell 0.0038588128 0.012348201 0.8709271 1.649822\n   nMoreExtreme size                        leadingEdge\n1:            0    7    CD8A,CD3D,CD3G,CD3E,CD2,CD5,...\n2:            0   14 CD3D,CD3G,CD3E,CD81,PTPRC,CD84,...\n3:           33    6               CD81,B2M,PTPRC,ITGB1\n\n$`2`\n   pathway         pval        padj        ES      NES nMoreExtreme size\n1:  B cell 0.0001029866 0.002780639 0.9047629 1.801854            0   11\n                            leadingEdge\n1: CD79A,MS4A1,FCER2,PAX5,CD24,CD19,...\n\n$`3`\n                       pathway         pval        padj        ES      NES\n1:      CD1C+_A dendritic cell 0.0002217295 0.005127494 0.9084688 1.849273\n2:         Natural killer cell 0.0005543237 0.005127494 0.8964502 1.824808\n3: AXL+SIGLEC6+ dendritic cell 0.0004023335 0.005127494 0.7337906 1.776492\n   nMoreExtreme size                                leadingEdge\n1:            1    7                    AREG,LPCAT1,ADAM8,NR4A2\n2:            4    7              KLRD1,FCGR3A,KLRC1,NCAM1,NCR1\n3:            3   22 PTGDS,CTSW,BHLHE40,TSEN54,CX3CR1,PLAC8,...\n\n$`4`\nEmpty data.table (0 rows and 8 cols): pathway,pval,padj,ES,NES,nMoreExtreme...\n\n$`5`\n   pathway         pval        padj        ES      NES nMoreExtreme size\n1:  T cell 0.0001093135 0.003060778 0.9460238 1.702717            0    7\n              leadingEdge\n1: CD3D,CD3E,CD2,CD5,CD3G\n\n$`6`\n               pathway         pval        padj        ES      NES nMoreExtreme\n1: Natural killer cell 0.0001092180 0.004041066 0.8961044 1.884108            0\n2:            Platelet 0.0007526072 0.009282156 0.8302022 1.783614            6\n3:        Myeloid cell 0.0007159660 0.009282156 0.7635915 1.778575            6\n   size                          leadingEdge\n1:    8 KLRD1,FCGR3A,CD3E,CD2,NCR1,NCAM1,...\n2:    9     CCL5,CD63,SPN,BSG,CD47,CD226,...\n3:   15 FCGR3A,CD3E,CD81,ZAP70,IL2RB,SPN,...\n\n$`7`\nEmpty data.table (0 rows and 8 cols): pathway,pval,padj,ES,NES,nMoreExtreme...\n\n$`8`\n   pathway        pval       padj        ES      NES nMoreExtreme size\n1:  B cell 0.001330332 0.03724928 0.8203607 1.610929           12   13\n                                  leadingEdge\n1: CD79A,MS4A1,POU2AF1,CD24,FCGR2B,POU2F2,...\n\n$`9`\n        pathway         pval       padj        ES      NES nMoreExtreme size\n1: Myeloid cell 0.0002004008 0.00741483 0.8081754 1.642042            1   22\n2:   Neutrophil 0.0032241290 0.03976426 0.8299506 1.566163           30   10\n                              leadingEdge\n1: FCGR3A,CSF1R,PECAM1,CD68,ITGAX,SPN,...\n2:       FCGR3A,PECAM1,ITGAX,C5AR1,FCGR2A\n\n\n#CT_GSEA8:\n\nnew.cluster.ids &lt;- unlist(lapply(res,function(x){as.data.frame(x)[1,1]}))\nalldata$cellmarker_gsea &lt;- new.cluster.ids[as.character(alldata@active.ident)]\n\ncowplot::plot_grid( ncol = 2,\nDimPlot(alldata,label = T,group.by = \"ref_gsea\") + NoAxes(),\nDimPlot(alldata,label = T, group.by = \"cellmarker_gsea\") + NoAxes()\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nDo you think that the methods overlap well? Where do you see the most inconsistencies?\n\n\nIn this case we do not have any ground truth, and we cannot say which method performs best. You should keep in mind, that any celltype classification method is just a prediction, and you still need to use your common sense and knowledge of the biological system to judge if the results make sense.\nFinally, lets save the data with predictions.\n\nsaveRDS(ctrl,\"data/results/ctrl13_qc_dr_int_cl_celltype.rds\")"
  },
  {
    "objectID": "labs/seurat/seurat_06_celltyping.html#meta-session",
    "href": "labs/seurat/seurat_06_celltyping.html#meta-session",
    "title": " Celltype prediction",
    "section": "7 Session info",
    "text": "7 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] fgsea_1.24.0       caret_6.0-94       lattice_0.20-45    scPred_1.9.2      \n [5] rafalib_1.0.0      pheatmap_1.0.12    ggplot2_3.4.2      cowplot_1.1.1     \n [9] dplyr_1.1.1        SeuratObject_4.1.3 Seurat_4.3.0.1    \n\nloaded via a namespace (and not attached):\n  [1] fastmatch_1.1-3        plyr_1.8.8             igraph_1.5.0          \n  [4] lazyeval_0.2.2         sp_2.0-0               splines_4.2.3         \n  [7] BiocParallel_1.32.6    listenv_0.9.0          scattermore_1.2       \n [10] digest_0.6.33          foreach_1.5.2          htmltools_0.5.5       \n [13] fansi_1.0.4            magrittr_2.0.3         tensor_1.5            \n [16] cluster_2.1.4          ROCR_1.0-11            limma_3.54.2          \n [19] recipes_1.0.6          globals_0.16.2         gower_1.0.1           \n [22] matrixStats_1.0.0      hardhat_1.3.0          timechange_0.2.0      \n [25] spatstat.sparse_3.0-2  colorspace_2.1-0       ggrepel_0.9.3         \n [28] xfun_0.39              crayon_1.5.2           jsonlite_1.8.7        \n [31] progressr_0.13.0       spatstat.data_3.0-1    survival_3.5-3        \n [34] zoo_1.8-12             iterators_1.0.14       glue_1.6.2            \n [37] polyclip_1.10-4        gtable_0.3.3           ipred_0.9-14          \n [40] leiden_0.4.3           kernlab_0.9-32         future.apply_1.11.0   \n [43] abind_1.4-5            scales_1.2.1           spatstat.random_3.1-5 \n [46] miniUI_0.1.1.1         Rcpp_1.0.10            viridisLite_0.4.2     \n [49] xtable_1.8-4           reticulate_1.30        stats4_4.2.3          \n [52] lava_1.7.2.1           prodlim_2023.03.31     htmlwidgets_1.6.2     \n [55] httr_1.4.6             RColorBrewer_1.1-3     ellipsis_0.3.2        \n [58] ica_1.0-3              pkgconfig_2.0.3        farver_2.1.1          \n [61] nnet_7.3-18            uwot_0.1.16            deldir_1.0-9          \n [64] utf8_1.2.3             tidyselect_1.2.0       labeling_0.4.2        \n [67] rlang_1.1.1            reshape2_1.4.4         later_1.3.1           \n [70] munsell_0.5.0          tools_4.2.3            cli_3.6.1             \n [73] generics_0.1.3         ggridges_0.5.4         evaluate_0.21         \n [76] stringr_1.5.0          fastmap_1.1.1          yaml_2.3.7            \n [79] goftest_1.2-3          ModelMetrics_1.2.2.2   knitr_1.43            \n [82] fitdistrplus_1.1-11    purrr_1.0.1            RANN_2.6.1            \n [85] pbapply_1.7-2          future_1.33.0          nlme_3.1-162          \n [88] mime_0.12              compiler_4.2.3         rstudioapi_0.14       \n [91] beeswarm_0.4.0         plotly_4.10.2          png_0.1-8             \n [94] spatstat.utils_3.0-3   tibble_3.2.1           stringi_1.7.12        \n [97] Matrix_1.6-0           vctrs_0.6.3            pillar_1.9.0          \n[100] lifecycle_1.0.3        spatstat.geom_3.2-1    lmtest_0.9-40         \n[103] RcppAnnoy_0.0.21       data.table_1.14.8      irlba_2.3.5.1         \n[106] httpuv_1.6.11          patchwork_1.1.2        R6_2.5.1              \n[109] promises_1.2.0.1       KernSmooth_2.23-20     gridExtra_2.3         \n[112] vipor_0.4.5            parallelly_1.36.0      codetools_0.2-19      \n[115] MASS_7.3-58.2          withr_2.5.0            sctransform_0.3.5     \n[118] harmony_0.1.1          parallel_4.2.3         grid_4.2.3            \n[121] rpart_4.1.19           timeDate_4022.108      tidyr_1.3.0           \n[124] class_7.3-21           rmarkdown_2.21         Rtsne_0.16            \n[127] spatstat.explore_3.2-1 pROC_1.18.5            shiny_1.7.4           \n[130] lubridate_1.9.2        ggbeeswarm_0.7.2"
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html",
    "href": "labs/seurat/seurat_07_spatial.html",
    "title": " Spatial Transcriptomics",
    "section": "",
    "text": "Note\n\n\n\nCode chunks run R commands unless otherwise specified.\nThis tutorial is adapted from the (Seurat vignette)[https://satijalab.org/seurat/v3.2/spatial_vignette.html].\nSpatial transcriptomic data with the Visium platform is in many ways similar to scRNAseq data. It contains UMI counts for 5-20 cells instead of single cells, but is still quite sparse in the same way as scRNAseq data is, but with the additional information about spatial location in the tissue.\nHere we will first run quality control in a similar manner to scRNAseq data, then QC filtering, dimensionality reduction, integration and clustering. Then we will use scRNAseq data from mouse cortex to run LabelTransfer to predict celltypes in the Visium spots.\nWe will use two Visium spatial transcriptomics dataset of the mouse brain (Sagittal), which are publicly available from the 10x genomics website. Note, that these dataset have already been filtered for spots that does not overlap with the tissue."
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html#meta-st_prep",
    "href": "labs/seurat/seurat_07_spatial.html#meta-st_prep",
    "title": " Spatial Transcriptomics",
    "section": "1 Preparation",
    "text": "1 Preparation\nLoad packages\n\n# devtools::install_github('satijalab/seurat-data', dependencies=FALSE)\n\nsuppressPackageStartupMessages({\n  require(Matrix)\n  require(dplyr)\n  require(SeuratData)\n  require(Seurat)\n  require(ggplot2)\n  require(patchwork)\n  require(dplyr)\n})\n\nLoad ST data\nThe package SeuratData has some seurat objects for different datasets. Among those are spatial transcriptomics data from mouse brain and kidney. Here we will download and process sections from the mouse brain.\n\noutdir = \"data/spatial/\"\nif(!dir.exists(outdir)) dir.create(outdir, showWarnings = F)\n\n# to list available datasets in SeuratData you can run AvailableData()\n\n# first we dowload the dataset\nif (!(\"stxBrain.SeuratData\" %in% rownames(InstalledData()))){\n  InstallData(\"stxBrain\")\n}\n\n# now we can list what datasets we have downloaded\nInstalledData()\n\n# now we will load the seurat object for one section\nbrain1 &lt;- LoadData(\"stxBrain\", type = \"anterior1\")\nbrain2 &lt;- LoadData(\"stxBrain\", type = \"posterior1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDataset\nVersion\nSummary\nspecies\nsystem\nncells\ntech\nseurat\ndefault.dataset\ndisk.datasets\nother.datasets\nnotes\nInstalled\nInstalledVersion\n\n\n\n\nbmcite.SeuratData\nbmcite\n0.3.0\n30k Bone Marrow Cells\nhuman\nbone marrow\n30672\nNA\n3.2.2\nNA\nNA\nNA\nNA\nTRUE\n0.3.0\n\n\nhcabm40k.SeuratData\nhcabm40k\n3.0.0\n40,000 Cells From the Human Cell Atlas ICA Bone Marrow Dataset\nhuman\nbone marrow\n40000\n10x v2\nNA\nraw\nNA\nNA\nNA\nTRUE\n3.0.0\n\n\nstxBrain.SeuratData\nstxBrain\n0.1.1\n10X Genomics Visium Mouse Brain Dataset\nmouse\nbrain\n12167\nvisium\nNA\nNA\nNA\nposterior1, posterior2, anterior1, anterior2\nOne sample split across four datasets as paired anterior/posterior slices\nTRUE\n0.1.1\n\n\n\n\n\n\nMerge into one seurat object\n\nbrain &lt;- merge(brain1, brain2)\nbrain\n\nAn object of class Seurat \n31053 features across 6049 samples within 1 assay \nActive assay: Spatial (31053 features, 0 variable features)\n 2 images present: anterior1, posterior1\n\n\nAs you can see, now we do not have the assay “RNA”, but instead an assay called “Spatial”."
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html#meta-st_qc",
    "href": "labs/seurat/seurat_07_spatial.html#meta-st_qc",
    "title": " Spatial Transcriptomics",
    "section": "2 Quality control",
    "text": "2 Quality control\nSimilar to scRNA-seq we use statistics on number of counts, number of features and percent mitochondria for quality control.\nNow the counts and feature counts are calculated on the Spatial assay, so they are named “nCount_Spatial” and “nFeature_Spatial”.\n\nbrain &lt;- PercentageFeatureSet(brain, \"^mt-\", col.name = \"percent_mito\")\nbrain &lt;- PercentageFeatureSet(brain, \"^Hb.*-\", col.name = \"percent_hb\")\n\nVlnPlot(brain, features = c(\"nCount_Spatial\", \"nFeature_Spatial\",\"percent_mito\",\"percent_hb\"), pt.size = 0.1, ncol = 2) + NoLegend()\n\n\n\n\n\n\n\n\nWe can also plot the same data onto the tissue section.\n\nSpatialFeaturePlot(brain, features = c(\"nCount_Spatial\", \"nFeature_Spatial\",\"percent_mito\",\"percent_hb\")) \n\n\n\n\n\n\n\n\nAs you can see, the spots with low number of counts/features and high mitochondrial content are mainly towards the edges of the tissue. It is quite likely that these regions are damaged tissue. You may also see regions within a tissue with low quality if you have tears or folds in your section.\nBut remember, for some tissue types, the amount of genes expressed and proportion mitochondria may also be a biological features, so bear in mind what tissue you are working on and what these features mean.\n\n2.1 Filter spots\nSelect all spots with less than 25% mitocondrial reads, less than 20% hb-reads and 500 detected genes. You must judge for yourself based on your knowledge of the tissue what are appropriate filtering criteria for your dataset.\n\nbrain &lt;- brain[, brain$nFeature_Spatial&gt;500 & brain$percent_mito &lt; 25 & brain$percent_hb &lt; 20]\n\nAnd replot onto tissue section:\n\nSpatialFeaturePlot(brain, features = c(\"nCount_Spatial\", \"nFeature_Spatial\",\"percent_mito\"))\n\n\n\n\n\n\n\n\n\n\n2.2 Top expressed genes\nAs for scRNA-seq data, we will look at what the top expressed genes are.\n\nC &lt;- brain@assays$Spatial@counts\nC@x &lt;- C@x / rep.int(colSums(C), diff(C@p))\nmost_expressed &lt;- order(Matrix::rowSums(C), decreasing = T)[20:1]\nboxplot(as.matrix(t(C[most_expressed, ])),\n    cex = 0.1, las = 1, xlab = \"% total count per cell\",\n    col = (scales::hue_pal())(20)[20:1], horizontal = TRUE\n)\n\n\n\n\n\n\n\n\nAs you can see, the mitochondrial genes are among the top expressed genes. Also the lncRNA gene Bc1 (brain cytoplasmic RNA 1). Also one hemoglobin gene.\n\n\n2.3 Filter genes\nWe will remove the Bc1 gene, hemoglobin genes (blood contamination) and the mitochondrial genes.\n\ndim(brain)\n\n# Filter Bl1\nbrain &lt;- brain[!grepl(\"Bc1\", rownames(brain)), ]\n\n# Filter Mitocondrial\nbrain &lt;- brain[!grepl(\"^mt-\", rownames(brain)), ]\n\n# Filter Hemoglobin gene (optional if that is a problem on your data)\nbrain &lt;- brain[!grepl(\"^Hb.*-\", rownames(brain)), ]\n\ndim(brain)\n\n[1] 31053  5789\n[1] 31031  5789"
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html#meta-st_analysis",
    "href": "labs/seurat/seurat_07_spatial.html#meta-st_analysis",
    "title": " Spatial Transcriptomics",
    "section": "3 Analysis",
    "text": "3 Analysis\nWe will proceed with the data in a very similar manner to scRNA-seq data.\nFor ST data, the Seurat team recommends to use SCTranform for normalization, so we will do that. SCTransform will select variable genes and normalize in one step.\n\nbrain &lt;- SCTransform(brain, assay = \"Spatial\", verbose = TRUE, method = 'poisson')\n\nNow we can plot gene expression of individual genes, the gene Hpca is a strong hippocampal marker and Ttr is a marker of the choroid plexus.\n\nSpatialFeaturePlot(brain, features = c(\"Hpca\", \"Ttr\"))\n\n\n\n\n\n\n\n\nIf you want to see the tissue better you can modify point size and transparency of the points.\n\nSpatialFeaturePlot(brain, features = \"Ttr\", pt.size.factor = 1, alpha = c(0.1, 1))\n\n\n\n\n\n\n\n\n\n3.1 Dimensionality reduction and clustering\nWe can then now run dimensionality reduction and clustering using the same workflow as we use for scRNA-seq analysis.\nBut make sure you run it on the SCT assay.\n\nbrain &lt;- RunPCA(brain, assay = \"SCT\", verbose = FALSE)\nbrain &lt;- FindNeighbors(brain, reduction = \"pca\", dims = 1:30)\nbrain &lt;- FindClusters(brain, verbose = FALSE)\nbrain &lt;- RunUMAP(brain, reduction = \"pca\", dims = 1:30)\n\nWe can then plot clusters onto umap or onto the tissue section.\n\nDimPlot(brain, reduction = \"umap\", group.by = c(\"ident\", \"orig.ident\"))\n\n\n\n\n\n\n\n\n\nSpatialDimPlot(brain)\n\n\n\n\n\n\n\n\nWe can also plot each cluster separately\n\nSpatialDimPlot(brain, cells.highlight = CellsByIdentities(brain), facet.highlight = TRUE, ncol = 5)\n\n\n\n\n\n\n\n\n\n\n3.2 Integration\nQuite often there are strong batch effects between different ST sections, so it may be a good idea to integrate the data across sections.\nWe will do a similar integration as in the Data Integration lab, but this time we will use the SCT assay for integration. Therefore we need to run PrepSCTIntegration which will compute the sctransform residuals for all genes in both the datasets.\n\n# create a list of the original data that we loaded to start with\nst.list = list(anterior1=brain1, posterior1=brain2)\n\n# run SCT on both datasets\nst.list = lapply(st.list, SCTransform, assay = \"Spatial\", method='poisson')\n\n# need to set maxSize for PrepSCTIntegration to work\noptions(future.globals.maxSize = 2000 * 1024^2) # set allowed size to 2K MiB\n\nst.features = SelectIntegrationFeatures(st.list, nfeatures = 3000, verbose = FALSE)\nst.list &lt;- PrepSCTIntegration(object.list = st.list, anchor.features = st.features, \n    verbose = FALSE)\n\nNow we can perform the actual integration.\n\nint.anchors &lt;- FindIntegrationAnchors(object.list = st.list, normalization.method = \"SCT\",   verbose = FALSE, anchor.features = st.features)\nbrain.integrated &lt;- IntegrateData(anchorset = int.anchors, normalization.method = \"SCT\", \n    verbose = FALSE)\n\nrm(int.anchors, st.list)\ngc()\n\n            used   (Mb) gc trigger   (Mb)   max used   (Mb)\nNcells   3531578  188.7    5288780  282.5    5288780  282.5\nVcells 590722638 4506.9 1192401510 9097.4 1176016297 8972.3\n\n\nThen we run dimensionality reduction and clustering as before.\n\nbrain.integrated &lt;- RunPCA(brain.integrated, verbose = FALSE)\nbrain.integrated &lt;- FindNeighbors(brain.integrated, dims = 1:30)\nbrain.integrated &lt;- FindClusters(brain.integrated, verbose = FALSE)\nbrain.integrated &lt;- RunUMAP(brain.integrated, dims = 1:30)\n\n\nDimPlot(brain.integrated, reduction = \"umap\", group.by = c(\"ident\", \"orig.ident\"))\n\n\n\n\n\n\n\n\n\nSpatialDimPlot(brain.integrated)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nDo you see any differences between the integrated and non-integrated clustering? Judge for yourself, which of the clusterings do you think looks best? As a reference, you can compare to brain regions in the Allen brain atlas.\n\n\n\n\n3.3 Spatially Variable Features\nThere are two main workflows to identify molecular features that correlate with spatial location within a tissue. The first is to perform differential expression based on spatially distinct clusters, the other is to find features that have spatial patterning without taking clusters or spatial annotation into account. First, we will do differential expression between clusters just as we did for the scRNAseq data before.\n\n# differential expression between cluster 1 and cluster 6\nde_markers &lt;- FindMarkers(brain.integrated, ident.1 = 5, ident.2 = 6)\n\n# plot top markers\nSpatialFeaturePlot(object = brain.integrated, features = rownames(de_markers)[1:3], alpha = c(0.1, 1), ncol = 3)\n\n\n\n\n\n\n\n\nSpatial transcriptomics allows researchers to investigate how gene expression trends varies in space, thus identifying spatial patterns of gene expression. For this purpose there are multiple methods, such as SpatailDE, SPARK, Trendsceek, HMRF and Splotch.\nIn FindSpatiallyVariables the default method in Seurat (method = ‘markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ’variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma(r) values measuring the dependence between two spots a certain “r” distance apart. By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.\n\n\n\n\n\n\nCaution\n\n\n\nTakes a long time to run, so skip this step for now!\n\n\n\n# brain &lt;- FindSpatiallyVariableFeatures(brain, assay = \"SCT\", features = VariableFeatures(brain)[1:1000], \n#     selection.method = \"markvariogram\")\n\n# We would get top features from SpatiallyVariableFeatures\n# top.features &lt;- head(SpatiallyVariableFeatures(brain, selection.method = \"markvariogram\"), 6)"
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html#meta-st_ss",
    "href": "labs/seurat/seurat_07_spatial.html#meta-st_ss",
    "title": " Spatial Transcriptomics",
    "section": "4 Single cell data",
    "text": "4 Single cell data\nWe can use a scRNA-seq dataset as a reference to predict the proportion of different celltypes in the Visium spots. Keep in mind that it is important to have a reference that contains all the celltypes you expect to find in your spots. Ideally it should be a scRNA-seq reference from the exact same tissue. We will use a reference scRNA-seq dataset of ~14,000 adult mouse cortical cell taxonomy from the Allen Institute, generated with the SMART-Seq2 protocol.\nFirst download the seurat data from: https://www.dropbox.com/s/cuowvm4vrf65pvq/allen_cortex.rds?dl=1 to folder data/spatial/ with command:\n\n\nFILE=\"./data/spatial/allen_cortex.rds\"\n\nif [ -e $FILE ]\nthen\n   echo \"File $FILE is downloaded.\"\nelse\n   echo \"Downloading $FILE\"\n   mkdir -p data/spatial\n   wget  -O data/spatial/allen_cortex.rds https://www.dropbox.com/s/cuowvm4vrf65pvq/allen_cortex.rds?dl=1\nfi\n\nFile ./data/spatial/allen_cortex.rds is downloaded.\n\n\nFor speed, and for a more fair comparison of the celltypes, we will subsample all celltypes to a maximum of 200 cells per class (subclass).\n\nallen_reference &lt;- readRDS(\"data/spatial/allen_cortex.rds\")\n\n# check number of cells per subclass\ntable(allen_reference$subclass)\n\n# select 200 cells per subclass, fist set subclass ass active.ident\nIdents(allen_reference) &lt;- allen_reference$subclass\nallen_reference &lt;- subset(allen_reference, cells = WhichCells(allen_reference, downsample = 200))\n\n# check again number of cells per subclass\ntable(allen_reference$subclass)\n\n\n     Astro         CR       Endo    L2/3 IT         L4      L5 IT      L5 PT \n       368          7         94        982       1401        880        544 \n     L6 CT      L6 IT        L6b      Lamp5 Macrophage      Meis2         NP \n       960       1872        358       1122         51         45        362 \n     Oligo       Peri      Pvalb   Serpinf1        SMC       Sncg        Sst \n        91         32       1337         27         55        125       1741 \n       Vip       VLMC \n      1728         67 \n\n     Astro         CR       Endo    L2/3 IT         L4      L5 IT      L5 PT \n       200          7         94        200        200        200        200 \n     L6 CT      L6 IT        L6b      Lamp5 Macrophage      Meis2         NP \n       200        200        200        200         51         45        200 \n     Oligo       Peri      Pvalb   Serpinf1        SMC       Sncg        Sst \n        91         32        200         27         55        125        200 \n       Vip       VLMC \n       200         67 \n\n\nThen run normalization and dimensionality reduction.\n\n# First run SCTransform and PCA \nallen_reference &lt;- SCTransform(allen_reference, ncells = 3000, verbose = FALSE, method = 'poisson') %&gt;% RunPCA(verbose = FALSE) %&gt;%    RunUMAP(dims = 1:30)\n\n# the annotation is stored in the 'subclass' column of object metadata\nDimPlot(allen_reference, label = TRUE)"
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html#meta-st_sub",
    "href": "labs/seurat/seurat_07_spatial.html#meta-st_sub",
    "title": " Spatial Transcriptomics",
    "section": "5 Subset ST for cortex",
    "text": "5 Subset ST for cortex\nSince the scRNAseq dataset was generated from the mouse cortex, we will subset the visium dataset in order to select mainly the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and therefore it should be interpreted with more care.\n\n# subset for the anterior dataset\ncortex &lt;- subset(brain.integrated, orig.ident == \"anterior1\")\n\n# there seems to be an error in the subsetting, so the posterior1 image is not removed, do it manually\ncortex@images$posterior1 = NULL\n\n# subset for a specific region\ncortex &lt;- subset(cortex, anterior1_imagerow &gt; 400 | anterior1_imagecol &lt; 150, invert = TRUE)\ncortex &lt;- subset(cortex, anterior1_imagerow &gt; 275 & anterior1_imagecol &gt; 370, invert = TRUE)\ncortex &lt;- subset(cortex, anterior1_imagerow &gt; 250 & anterior1_imagecol &gt; 440, invert = TRUE)\n\n# also subset for Frontal cortex clusters\ncortex &lt;- subset(cortex, idents = c(1,2,3,4,5))\n\np1 &lt;- SpatialDimPlot(cortex, crop = TRUE, label = TRUE)\np2 &lt;- SpatialDimPlot(cortex, crop = FALSE, label = TRUE, pt.size.factor = 1, label.size = 3)\np1 + p2"
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html#meta-st_deconv",
    "href": "labs/seurat/seurat_07_spatial.html#meta-st_deconv",
    "title": " Spatial Transcriptomics",
    "section": "6 Deconvolution",
    "text": "6 Deconvolution\nDeconvolution is a method to estimate the abundance (or proportion) of different celltypes in a bulkRNAseq dataset using a single cell reference. As the Visium data can be seen as a small bulk, we can both use methods for traditional bulkRNAseq as well as methods especially developed for Visium data. Some methods for deconvolution are DWLS, cell2location, Tangram, Stereoscope, RCTD, SCDC and many more.\nHere we will use SCDC for deconvolution of celltypes in the Visium spots. For more information on the tool please check their website: https://meichendong.github.io/SCDC/articles/SCDC.html. First, make sure the packages you need are installed. All dependencies should be in the conda environment.\n\ninst = installed.packages()\n\nif (!(\"xbioc\" %in% rownames(inst))){\n  remotes::install_github(\"renozao/xbioc\", dependencies = FALSE)\n}\nif (!(\"SCDC\" %in% rownames(inst))){\n  remotes::install_github(\"meichendong/SCDC\", dependencies = FALSE)\n}\n\nsuppressPackageStartupMessages(require(SCDC))\nsuppressPackageStartupMessages(require(Biobase))\n\n\n6.1 Select genes for deconvolution\nMost deconvolution methods does a prior gene selection and there are different options that are used: - Use variable genes in the SC data. - Use variable genes in both SC and ST data - DE genes between clusters in the SC data.\nIn this case we will use top DE genes per cluster, so first we have to run DGE detection on the scRNAseq data.\nFor SCDC we want to find unique markers per cluster, so we select top 20 DEGs per cluster. Ideally you should run with a larger set of genes, perhaps 100 genes per cluster to get better results. However, for the sake of speed, we are now selecting only top20 genes and it still takes about 10 minutes to run.\n\nallen_reference@active.assay = \"RNA\"\n\nmarkers_sc &lt;- FindAllMarkers(allen_reference,\n                            only.pos = TRUE,\n                            logfc.threshold = 0.1,\n                            test.use = \"wilcox\",\n                            min.pct = 0.05,\n                            min.diff.pct = 0.1,\n                            max.cells.per.ident = 200,\n                            return.thresh = 0.05,\n                            assay = \"RNA\")\n\n# Filter for genes that are also present in the ST data\nmarkers_sc &lt;- markers_sc[markers_sc$gene %in% rownames(cortex),]\n\n\n# Select top 20 genes per cluster, select top by first p-value, then absolute diff in pct, then quota of pct.\nmarkers_sc$pct.diff &lt;- markers_sc$pct.1 - markers_sc$pct.2\nmarkers_sc$log.pct.diff &lt;- log2( (markers_sc$pct.1*99+1) / (markers_sc$pct.2*99+1) )\nmarkers_sc %&gt;% group_by(cluster)  %&gt;% top_n(-100, p_val) %&gt;% top_n(50, pct.diff) %&gt;% top_n(20, log.pct.diff)-&gt; top20\nm_feats &lt;- unique(as.character(top20$gene))\n\n\n\n6.2 Create Expression Sets\nFor SCDC both the SC and the ST data need to be in the format of an Expression set with the count matrices as AssayData. We also subset the matrices for the genes we selected in the previous step.\n\neset_SC &lt;- ExpressionSet(assayData=as.matrix(allen_reference@assays$RNA@counts[m_feats,]),\n                         phenoData =  AnnotatedDataFrame(allen_reference@meta.data))\neset_ST &lt;- ExpressionSet(assayData=as.matrix(cortex@assays$Spatial@counts[m_feats,]),phenoData = AnnotatedDataFrame(cortex@meta.data))\n\n\n\n6.3 Deconvolve\nWe then run the deconvolution defining the celltype of interest as “subclass” column in the single cell data.\n\ndeconvolution_crc &lt;- SCDC::SCDC_prop(bulk.eset = eset_ST,\n                       sc.eset = eset_SC,\n                       ct.varname = \"subclass\",\n                       ct.sub = as.character(unique(eset_SC$subclass)) )\n\nNow we have a matrix with predicted proportions of each celltypes for each visium spot in prop.est.mvw.\n\nhead(deconvolution_crc$prop.est.mvw)\n\n                     Lamp5 Sncg Serpinf1          Vip          Sst      Pvalb\nAAACTCGTGATATAAG-1_1     0    0        0 0.000000e+00 0.0003020068 0.00000000\nAAACTGCTGGCTCCAA-1_1     0    0        0 0.000000e+00 0.1544641392 0.07943494\nAAAGGGATGTAGCAAG-1_1     0    0        0 0.000000e+00 0.2742639441 0.00000000\nAAATACCTATAAGCAT-1_1     0    0        0 0.000000e+00 0.0803576731 0.40436150\nAAATCGTGTACCACAA-1_1     0    0        0 0.000000e+00 0.0692640621 0.00000000\nAAATGATTCGATCAGC-1_1     0    0        0 1.705303e-06 0.0169468859 0.08888082\n                           Endo         Peri        L6 CT          L6b\nAAACTCGTGATATAAG-1_1 0.00000000 0.000000e+00 0.0000000000 1.512806e-01\nAAACTGCTGGCTCCAA-1_1 0.02562850 0.000000e+00 0.0280520546 1.959849e-05\nAAAGGGATGTAGCAAG-1_1 0.01131595 0.000000e+00 0.0000000000 0.000000e+00\nAAATACCTATAAGCAT-1_1 0.07365610 1.399958e-05 0.0036921008 0.000000e+00\nAAATCGTGTACCACAA-1_1 0.02785003 5.235782e-06 0.0002147064 2.458057e-01\nAAATGATTCGATCAGC-1_1 0.01403814 2.633453e-02 0.2657130174 0.000000e+00\n                            L6 IT CR    L2/3 IT        L5 PT NP        L4\nAAACTCGTGATATAAG-1_1 0.000000e+00  0 0.00000000 0.0000000000  0 0.0000000\nAAACTGCTGGCTCCAA-1_1 1.699877e-05  0 0.38974934 0.0000000000  0 0.0000000\nAAAGGGATGTAGCAAG-1_1 2.237113e-04  0 0.00000000 0.0000000000  0 0.1814651\nAAATACCTATAAGCAT-1_1 0.000000e+00  0 0.00000000 0.0000793099  0 0.0000000\nAAATCGTGTACCACAA-1_1 2.755082e-05  0 0.31058665 0.0000000000  0 0.0000000\nAAATGATTCGATCAGC-1_1 1.350970e-01  0 0.01172995 0.1013133001  0 0.1530583\n                           Oligo      L5 IT Meis2      Astro  Macrophage VLMC\nAAACTCGTGATATAAG-1_1 0.606350282 0.00000000     0 0.00000000 0.242067127    0\nAAACTGCTGGCTCCAA-1_1 0.070102264 0.00000000     0 0.20493666 0.047592071    0\nAAAGGGATGTAGCAAG-1_1 0.000000000 0.36553725     0 0.15879807 0.008395941    0\nAAATACCTATAAGCAT-1_1 0.090470397 0.00000000     0 0.32968096 0.017682500    0\nAAATCGTGTACCACAA-1_1 0.205850104 0.00000000     0 0.11515601 0.025239945    0\nAAATGATTCGATCAGC-1_1 0.002151596 0.09261913     0 0.08687805 0.005237623    0\n                              SMC\nAAACTCGTGATATAAG-1_1 0.000000e+00\nAAACTGCTGGCTCCAA-1_1 3.440261e-06\nAAAGGGATGTAGCAAG-1_1 0.000000e+00\nAAATACCTATAAGCAT-1_1 5.461144e-06\nAAATCGTGTACCACAA-1_1 0.000000e+00\nAAATGATTCGATCAGC-1_1 0.000000e+00\n\n\nNow we take the deconvolution output and add it to the Seurat object as a new assay.\n\ncortex@assays[[\"SCDC\"]] &lt;- CreateAssayObject(data = t(deconvolution_crc$prop.est.mvw))\n\n# Seems to be a bug in SeuratData package that the key is not set and any plotting function etc. will throw an error.\nif (length(cortex@assays$SCDC@key) == 0 ){\n  cortex@assays$SCDC@key = \"scdc_\"\n}\n\n\nDefaultAssay(cortex) &lt;- \"SCDC\"\nSpatialFeaturePlot(cortex, features = c(\"L2/3 IT\", \"L4\"), pt.size.factor = 1.6, ncol = 2, crop = TRUE)\n\n\n\n\n\n\n\n\nBased on these prediction scores, we can also predict cell types whose location is spatially restricted. We use the same methods based on marked point processes to define spatially variable features, but use the cell type prediction scores as the “marks” rather than gene expression.\n\ncortex &lt;- FindSpatiallyVariableFeatures(cortex, assay = \"SCDC\", selection.method = \"markvariogram\", \n    features = rownames(cortex), r.metric = 5, slot = \"data\")\ntop.clusters &lt;- head(SpatiallyVariableFeatures(cortex), 4)\nSpatialPlot(object = cortex, features = top.clusters, ncol = 2)\n\n\n\n\n\n\n\n\nWe can also visualize the scores per cluster in ST data.\n\nVlnPlot(cortex, group.by = \"seurat_clusters\", features = top.clusters, pt.size = 0, ncol=2)\n\n\n\n\n\n\n\n\nKeep in mind that the deconvolution results are just predictions, depending on how well your scRNAseq data covers the celltypes that are present in the ST data and on how parameters, gene selection etc. are tuned you may get different results.\n\n\n\n\n\n\nDiscuss\n\n\n\nSubset for another region that does not contain cortex cells and check what you get from the label transfer. Suggested region is the right end of the posterial section that you can select like this:\n\n# subset for the anterior dataset\nsubregion &lt;- subset(brain.integrated, orig.ident == \"posterior1\")\n\n# there seems to be an error in the subsetting, so the posterior1 image is not removed, do it manually\nsubregion@images$anterior1 = NULL\n\n# subset for a specific region\nsubregion &lt;- subset(subregion,  posterior1_imagecol &gt; 400, invert = FALSE)\n\np1 &lt;- SpatialDimPlot(subregion, crop = TRUE, label = TRUE)\np2 &lt;- SpatialDimPlot(subregion, crop = FALSE, label = TRUE, pt.size.factor = 1, label.size = 3)\np1 + p2"
  },
  {
    "objectID": "labs/seurat/seurat_07_spatial.html#meta-session",
    "href": "labs/seurat/seurat_07_spatial.html#meta-session",
    "title": " Spatial Transcriptomics",
    "section": "7 Session info",
    "text": "7 Session info\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] Biobase_2.58.0            BiocGenerics_0.44.0      \n [3] SCDC_0.0.0.9000           patchwork_1.1.2          \n [5] ggplot2_3.4.2             SeuratObject_4.1.3       \n [7] Seurat_4.3.0.1            stxBrain.SeuratData_0.1.1\n [9] hcabm40k.SeuratData_3.0.0 bmcite.SeuratData_0.3.0  \n[11] SeuratData_0.2.2          dplyr_1.1.1              \n[13] Matrix_1.6-0             \n\nloaded via a namespace (and not attached):\n  [1] backports_1.4.1        plyr_1.8.8             igraph_1.5.0          \n  [4] lazyeval_0.2.2         sp_2.0-0               splines_4.2.3         \n  [7] listenv_0.9.0          scattermore_1.2        GenomeInfoDb_1.34.9   \n [10] digest_0.6.33          htmltools_0.5.5        fansi_1.0.4           \n [13] checkmate_2.2.0        magrittr_2.0.3         memoise_2.0.1         \n [16] tensor_1.5             cluster_2.1.4          ROCR_1.0-11           \n [19] limma_3.54.2           Biostrings_2.66.0      globals_0.16.2        \n [22] matrixStats_1.0.0      spatstat.sparse_3.0-2  colorspace_2.1-0      \n [25] blob_1.2.4             rappdirs_0.3.3         ggrepel_0.9.3         \n [28] xfun_0.39              RCurl_1.98-1.12        crayon_1.5.2          \n [31] jsonlite_1.8.7         progressr_0.13.0       spatstat.data_3.0-1   \n [34] survival_3.5-3         zoo_1.8-12             glue_1.6.2            \n [37] polyclip_1.10-4        registry_0.5-1         gtable_0.3.3          \n [40] zlibbioc_1.44.0        XVector_0.38.0         nnls_1.4              \n [43] leiden_0.4.3           future.apply_1.11.0    abind_1.4-5           \n [46] scales_1.2.1           pheatmap_1.0.12        DBI_1.1.3             \n [49] spatstat.random_3.1-5  miniUI_0.1.1.1         Rcpp_1.0.10           \n [52] viridisLite_0.4.2      xtable_1.8-4           reticulate_1.30       \n [55] bit_4.0.5              stats4_4.2.3           htmlwidgets_1.6.2     \n [58] httr_1.4.6             RColorBrewer_1.1-3     ellipsis_0.3.2        \n [61] ica_1.0-3              pkgconfig_2.0.3        farver_2.1.1          \n [64] uwot_0.1.16            deldir_1.0-9           utf8_1.2.3            \n [67] tidyselect_1.2.0       labeling_0.4.2         rlang_1.1.1           \n [70] reshape2_1.4.4         later_1.3.1            AnnotationDbi_1.60.2  \n [73] cachem_1.0.8           munsell_0.5.0          tools_4.2.3           \n [76] cli_3.6.1              generics_0.1.3         RSQLite_2.3.1         \n [79] xbioc_0.1.19           ggridges_0.5.4         evaluate_0.21         \n [82] stringr_1.5.0          fastmap_1.1.1          yaml_2.3.7            \n [85] goftest_1.2-3          fastmatrix_0.5         knitr_1.43            \n [88] bit64_4.0.5            fitdistrplus_1.1-11    purrr_1.0.1           \n [91] RANN_2.6.1             KEGGREST_1.38.0        pbapply_1.7-2         \n [94] future_1.33.0          nlme_3.1-162           mime_0.12             \n [97] ggrastr_1.0.2          compiler_4.2.3         rstudioapi_0.14       \n[100] beeswarm_0.4.0         plotly_4.10.2          png_0.1-8             \n[103] spatstat.utils_3.0-3   tibble_3.2.1           stringi_1.7.12        \n[106] lattice_0.20-45        vctrs_0.6.3            pillar_1.9.0          \n[109] lifecycle_1.0.3        BiocManager_1.30.21.1  spatstat.geom_3.2-1   \n[112] lmtest_0.9-40          RcppAnnoy_0.0.21       bitops_1.0-7          \n[115] data.table_1.14.8      cowplot_1.1.1          irlba_2.3.5.1         \n[118] httpuv_1.6.11          R6_2.5.1               promises_1.2.0.1      \n[121] KernSmooth_2.23-20     gridExtra_2.3          IRanges_2.32.0        \n[124] vipor_0.4.5            parallelly_1.36.0      codetools_0.2-19      \n[127] assertthat_0.2.1       MASS_7.3-58.2          pkgmaker_0.32.8       \n[130] withr_2.5.0            sctransform_0.3.5      GenomeInfoDbData_1.2.9\n[133] S4Vectors_0.36.2       parallel_4.2.3         grid_4.2.3            \n[136] tidyr_1.3.0            L1pack_0.41-2          rmarkdown_2.21        \n[139] Rtsne_0.16             spatstat.explore_3.2-1 shiny_1.7.4           \n[142] ggbeeswarm_0.7.2"
  }
]